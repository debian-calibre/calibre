From 7cd7d23fc1fdb2b2aea29c4a66f376454183bf97 Mon Sep 17 00:00:00 2001
From: Kovid Goyal <kovid@kovidgoyal.net>
Date: Mon, 18 Nov 2019 20:26:29 +0530
Subject: [PATCH 010/201] Drop the custom lzma module

Use the builtin one from the python stdlib
---
 setup/extensions.json            |    6 -
 src/calibre/gui2/icon_theme.py   |    7 +-
 src/calibre/test_build.py        |    4 +-
 src/calibre/utils/rapydscript.py |   15 +-
 src/calibre_lzma/7zTypes.h       |  256 ----
 src/calibre_lzma/Compiler.h      |   32 -
 src/calibre_lzma/LzFind.c        | 1044 -------------
 src/calibre_lzma/LzFind.h        |  117 --
 src/calibre_lzma/LzHash.h        |   57 -
 src/calibre_lzma/Lzma2Dec.c      |  378 -----
 src/calibre_lzma/Lzma2Dec.h      |   80 -
 src/calibre_lzma/Lzma2Enc.c      |  520 -------
 src/calibre_lzma/Lzma2Enc.h      |   62 -
 src/calibre_lzma/LzmaDec.c       | 1100 --------------
 src/calibre_lzma/LzmaDec.h       |  227 ---
 src/calibre_lzma/LzmaEnc.c       | 2351 ------------------------------
 src/calibre_lzma/LzmaEnc.h       |   78 -
 src/calibre_lzma/Precomp.h       |   10 -
 src/calibre_lzma/__init__.py     |    9 -
 src/calibre_lzma/errors.py       |   24 -
 src/calibre_lzma/lzma1.py        |   42 -
 src/calibre_lzma/lzma_binding.c  |  472 ------
 src/calibre_lzma/xz.py           |  503 -------
 23 files changed, 13 insertions(+), 7381 deletions(-)
 delete mode 100644 src/calibre_lzma/7zTypes.h
 delete mode 100644 src/calibre_lzma/Compiler.h
 delete mode 100644 src/calibre_lzma/LzFind.c
 delete mode 100644 src/calibre_lzma/LzFind.h
 delete mode 100644 src/calibre_lzma/LzHash.h
 delete mode 100644 src/calibre_lzma/Lzma2Dec.c
 delete mode 100644 src/calibre_lzma/Lzma2Dec.h
 delete mode 100644 src/calibre_lzma/Lzma2Enc.c
 delete mode 100644 src/calibre_lzma/Lzma2Enc.h
 delete mode 100644 src/calibre_lzma/LzmaDec.c
 delete mode 100644 src/calibre_lzma/LzmaDec.h
 delete mode 100644 src/calibre_lzma/LzmaEnc.c
 delete mode 100644 src/calibre_lzma/LzmaEnc.h
 delete mode 100644 src/calibre_lzma/Precomp.h
 delete mode 100644 src/calibre_lzma/__init__.py
 delete mode 100644 src/calibre_lzma/errors.py
 delete mode 100644 src/calibre_lzma/lzma1.py
 delete mode 100644 src/calibre_lzma/lzma_binding.c
 delete mode 100644 src/calibre_lzma/xz.py

diff --git a/setup/extensions.json b/setup/extensions.json
index ca9097cbd4..0d33ca3418 100644
--- a/setup/extensions.json
+++ b/setup/extensions.json
@@ -144,12 +144,6 @@
         "sip_files": "calibre/utils/imageops/imageops.sip",
         "inc_dirs": "calibre/utils/imageops"
     },
-    {
-        "name": "lzma_binding",
-        "sources": "calibre_lzma/*.c",
-        "headers": "calibre_lzma/*.h",
-        "defines": "_7ZIP_ST"
-    },
     {
         "name": "winutil",
         "only": "windows",
diff --git a/src/calibre/gui2/icon_theme.py b/src/calibre/gui2/icon_theme.py
index 278e147eb1..1d9ec34a8e 100644
--- a/src/calibre/gui2/icon_theme.py
+++ b/src/calibre/gui2/icon_theme.py
@@ -37,7 +37,6 @@ from calibre.utils.icu import numeric_sort_key as sort_key
 from calibre.utils.img import image_from_data, Canvas, optimize_png, optimize_jpeg
 from calibre.utils.zipfile import ZipFile, ZIP_STORED
 from calibre.utils.filenames import atomic_rename
-from calibre_lzma.xz import compress, decompress
 from polyglot.builtins import iteritems, map, range, reraise, filter, as_bytes, unicode_type
 from polyglot import http_client
 from polyglot.queue import Queue, Empty
@@ -390,7 +389,8 @@ def create_themeball(report, progress=None, abort=None):
         return None, None
     if progress is not None:
         progress(next(num), _('Compressing theme file'))
-    compress(buf, out, level=9)
+    import lzma
+    lzma.compress(buf.getvalue(), format=lzma.FORMAT_XZ, preset=9)
     buf = BytesIO()
     prefix = report.name
     if abort is not None and abort.is_set():
@@ -794,8 +794,9 @@ class ChooseTheme(Dialog):
         dt = self.downloaded_theme
 
         def commit_changes():
+            import lzma
             dt.seek(0)
-            f = decompress(dt)
+            f = BytesIO(lzma.decompress(dt.getvalue()))
             f.seek(0)
             remove_icon_theme()
             install_icon_theme(theme, f)
diff --git a/src/calibre/test_build.py b/src/calibre/test_build.py
index a8e532d7f2..3b1ca5721c 100644
--- a/src/calibre/test_build.py
+++ b/src/calibre/test_build.py
@@ -65,8 +65,8 @@ class BuildTest(unittest.TestCase):
         self.assertEqual(detector.result['encoding'], 'utf-8')
 
     def test_lzma(self):
-        from calibre_lzma.xz import test_lzma2
-        test_lzma2()
+        import lzma
+        lzma.open
 
     def test_html5lib(self):
         import html5lib.html5parser  # noqa
diff --git a/src/calibre/utils/rapydscript.py b/src/calibre/utils/rapydscript.py
index e4a20c87c8..7b3f26264a 100644
--- a/src/calibre/utils/rapydscript.py
+++ b/src/calibre/utils/rapydscript.py
@@ -9,7 +9,6 @@ import os
 import re
 import subprocess
 import sys
-from io import BytesIO
 
 from calibre import force_unicode
 from calibre.constants import (
@@ -30,7 +29,7 @@ def abspath(x):
 
 
 def update_rapydscript():
-    from calibre_lzma.xz import compress
+    import lzma
     d = os.path.dirname
     base = d(d(d(d(d(abspath(__file__))))))
     base = os.path.join(base, 'rapydscript')
@@ -39,8 +38,8 @@ def update_rapydscript():
         with open(os.path.join(tdir, 'rapydscript.js'), 'rb') as f:
             raw = f.read()
     path = P(COMPILER_PATH, allow_user_override=False)
-    with open(path, 'wb') as f:
-        compress(raw, f, 9)
+    with lzma.open(path, 'wb', format=lzma.FORMAT_XZ) as f:
+        f.write(raw)
 # }}}
 
 # Compiler {{{
@@ -51,7 +50,7 @@ def to_dict(obj):
 
 
 def compiler():
-    from calibre_lzma.xz import decompress
+    import lzma
     ans = getattr(compiler, 'ans', None)
     if ans is not None:
         return ans
@@ -62,8 +61,8 @@ def compiler():
     from PyQt5.Qt import QApplication, QEventLoop
     must_use_qt()
 
-    buf = BytesIO()
-    decompress(P(COMPILER_PATH, data=True, allow_user_override=False), buf)
+    with lzma.open(P(COMPILER_PATH, allow_user_override=False)) as lzf:
+        compiler_script = lzf.read().decode('utf-8')
 
     base = base_dir()
     rapydscript_dir = os.path.join(base, 'src', 'pyj')
@@ -127,7 +126,7 @@ document.title = 'compiler initialized';
             QWebEnginePage.__init__(self)
             self.errors = []
             secure_webengine(self)
-            script = buf.getvalue().decode('utf-8')
+            script = compiler_script
             script += '\n\n;;\n\n' + vfs_script()
             self.scripts().insert(create_script(script, 'rapydscript.js'))
             self.setHtml('<p>initialize')
diff --git a/src/calibre_lzma/7zTypes.h b/src/calibre_lzma/7zTypes.h
deleted file mode 100644
index 903047b10f..0000000000
--- a/src/calibre_lzma/7zTypes.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/* 7zTypes.h -- Basic types
-2013-11-12 : Igor Pavlov : Public domain */
-
-#ifndef __7Z_TYPES_H
-#define __7Z_TYPES_H
-
-#ifdef _WIN32
-/* #include <windows.h> */
-#endif
-
-#include <stddef.h>
-
-#ifndef EXTERN_C_BEGIN
-#ifdef __cplusplus
-#define EXTERN_C_BEGIN extern "C" {
-#define EXTERN_C_END }
-#else
-#define EXTERN_C_BEGIN
-#define EXTERN_C_END
-#endif
-#endif
-
-EXTERN_C_BEGIN
-
-#define SZ_OK 0
-
-#define SZ_ERROR_DATA 1
-#define SZ_ERROR_MEM 2
-#define SZ_ERROR_CRC 3
-#define SZ_ERROR_UNSUPPORTED 4
-#define SZ_ERROR_PARAM 5
-#define SZ_ERROR_INPUT_EOF 6
-#define SZ_ERROR_OUTPUT_EOF 7
-#define SZ_ERROR_READ 8
-#define SZ_ERROR_WRITE 9
-#define SZ_ERROR_PROGRESS 10
-#define SZ_ERROR_FAIL 11
-#define SZ_ERROR_THREAD 12
-
-#define SZ_ERROR_ARCHIVE 16
-#define SZ_ERROR_NO_ARCHIVE 17
-
-typedef int SRes;
-
-#ifdef _WIN32
-/* typedef DWORD WRes; */
-typedef unsigned WRes;
-#else
-typedef int WRes;
-#endif
-
-#ifndef RINOK
-#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
-#endif
-
-typedef unsigned char Byte;
-typedef short Int16;
-typedef unsigned short UInt16;
-
-#ifdef _LZMA_UINT32_IS_ULONG
-typedef long Int32;
-typedef unsigned long UInt32;
-#else
-typedef int Int32;
-typedef unsigned int UInt32;
-#endif
-
-#ifdef _SZ_NO_INT_64
-
-/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
-   NOTES: Some code will work incorrectly in that case! */
-
-typedef long Int64;
-typedef unsigned long UInt64;
-
-#else
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-typedef __int64 Int64;
-typedef unsigned __int64 UInt64;
-#define UINT64_CONST(n) n
-#else
-typedef long long int Int64;
-typedef unsigned long long int UInt64;
-#define UINT64_CONST(n) n ## ULL
-#endif
-
-#endif
-
-#ifdef _LZMA_NO_SYSTEM_SIZE_T
-typedef UInt32 SizeT;
-#else
-typedef size_t SizeT;
-#endif
-
-typedef int Bool;
-#define True 1
-#define False 0
-
-
-#ifdef _WIN32
-#define MY_STD_CALL __stdcall
-#else
-#define MY_STD_CALL
-#endif
-
-#ifdef _MSC_VER
-
-#if _MSC_VER >= 1300
-#define MY_NO_INLINE __declspec(noinline)
-#else
-#define MY_NO_INLINE
-#endif
-
-#define MY_CDECL __cdecl
-#define MY_FAST_CALL __fastcall
-
-#else
-
-#define MY_NO_INLINE
-#define MY_CDECL
-#define MY_FAST_CALL
-
-#endif
-
-
-/* The following interfaces use first parameter as pointer to structure */
-
-typedef struct
-{
-  Byte (*Read)(void *p); /* reads one byte, returns 0 in case of EOF or error */
-} IByteIn;
-
-typedef struct
-{
-  void (*Write)(void *p, Byte b);
-} IByteOut;
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-       (output(*size) < input(*size)) is allowed */
-} ISeqInStream;
-
-/* it can return SZ_ERROR_INPUT_EOF */
-SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
-SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
-SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);
-
-typedef struct
-{
-  size_t (*Write)(void *p, const void *buf, size_t size);
-    /* Returns: result - the number of actually written bytes.
-       (result < size) means error */
-} ISeqOutStream;
-
-typedef enum
-{
-  SZ_SEEK_SET = 0,
-  SZ_SEEK_CUR = 1,
-  SZ_SEEK_END = 2
-} ESzSeek;
-
-typedef struct
-{
-  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ISeekInStream;
-
-typedef struct
-{
-  SRes (*Look)(void *p, const void **buf, size_t *size);
-    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
-       (output(*size) > input(*size)) is not allowed
-       (output(*size) < input(*size)) is allowed */
-  SRes (*Skip)(void *p, size_t offset);
-    /* offset must be <= output(*size) of Look */
-
-  SRes (*Read)(void *p, void *buf, size_t *size);
-    /* reads directly (without buffer). It's same as ISeqInStream::Read */
-  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
-} ILookInStream;
-
-SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
-SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);
-
-/* reads via ILookInStream::Read */
-SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
-SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);
-
-#define LookToRead_BUF_SIZE (1 << 14)
-
-typedef struct
-{
-  ILookInStream s;
-  ISeekInStream *realStream;
-  size_t pos;
-  size_t size;
-  Byte buf[LookToRead_BUF_SIZE];
-} CLookToRead;
-
-void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
-void LookToRead_Init(CLookToRead *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToLook;
-
-void SecToLook_CreateVTable(CSecToLook *p);
-
-typedef struct
-{
-  ISeqInStream s;
-  ILookInStream *realStream;
-} CSecToRead;
-
-void SecToRead_CreateVTable(CSecToRead *p);
-
-typedef struct
-{
-  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
-    /* Returns: result. (result != SZ_OK) means break.
-       Value (UInt64)(Int64)-1 for size means unknown value. */
-} ICompressProgress;
-
-typedef struct
-{
-  void *(*Alloc)(void *p, size_t size);
-  void (*Free)(void *p, void *address); /* address can be 0 */
-} ISzAlloc;
-
-#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
-#define IAlloc_Free(p, a) (p)->Free((p), a)
-
-#ifdef _WIN32
-
-#define CHAR_PATH_SEPARATOR '\\'
-#define WCHAR_PATH_SEPARATOR L'\\'
-#define STRING_PATH_SEPARATOR "\\"
-#define WSTRING_PATH_SEPARATOR L"\\"
-
-#else
-
-#define CHAR_PATH_SEPARATOR '/'
-#define WCHAR_PATH_SEPARATOR L'/'
-#define STRING_PATH_SEPARATOR "/"
-#define WSTRING_PATH_SEPARATOR L"/"
-
-#endif
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/Compiler.h b/src/calibre_lzma/Compiler.h
deleted file mode 100644
index de8fab3749..0000000000
--- a/src/calibre_lzma/Compiler.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* Compiler.h
-2015-08-02 : Igor Pavlov : Public domain */
-
-#ifndef __7Z_COMPILER_H
-#define __7Z_COMPILER_H
-
-#ifdef _MSC_VER
-
-  #ifdef UNDER_CE
-    #define RPC_NO_WINDOWS_H
-    /* #pragma warning(disable : 4115) // '_RPC_ASYNC_STATE' : named type definition in parentheses */
-    #pragma warning(disable : 4201) // nonstandard extension used : nameless struct/union
-    #pragma warning(disable : 4214) // nonstandard extension used : bit field types other than int
-  #endif
-
-  #if _MSC_VER >= 1300
-    #pragma warning(disable : 4996) // This function or variable may be unsafe
-  #else
-    #pragma warning(disable : 4511) // copy constructor could not be generated
-    #pragma warning(disable : 4512) // assignment operator could not be generated
-    #pragma warning(disable : 4514) // unreferenced inline function has been removed
-    #pragma warning(disable : 4702) // unreachable code
-    #pragma warning(disable : 4710) // not inlined
-    #pragma warning(disable : 4786) // identifier was truncated to '255' characters in the debug information
-  #endif
-
-#endif
-
-#define UNUSED_VAR(x) (void)x;
-/* #define UNUSED_VAR(x) x=x; */
-
-#endif
diff --git a/src/calibre_lzma/LzFind.c b/src/calibre_lzma/LzFind.c
deleted file mode 100644
index 73251ef1e0..0000000000
--- a/src/calibre_lzma/LzFind.c
+++ /dev/null
@@ -1,1044 +0,0 @@
-/* LzFind.c -- Match finder for LZ algorithms
-2015-10-15 : Igor Pavlov : Public domain */
-
-#include "Precomp.h"
-
-#include <string.h>
-
-#include "LzFind.h"
-#include "LzHash.h"
-
-#define kEmptyHashValue 0
-#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
-#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
-#define kNormalizeMask (~(UInt32)(kNormalizeStepMin - 1))
-#define kMaxHistorySize ((UInt32)7 << 29)
-
-#define kStartMaxLen 3
-
-static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  if (!p->directInput)
-  {
-    alloc->Free(alloc, p->bufferBase);
-    p->bufferBase = NULL;
-  }
-}
-
-/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */
-
-static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
-{
-  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
-  if (p->directInput)
-  {
-    p->blockSize = blockSize;
-    return 1;
-  }
-  if (!p->bufferBase || p->blockSize != blockSize)
-  {
-    LzInWindow_Free(p, alloc);
-    p->blockSize = blockSize;
-    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
-  }
-  return (p->bufferBase != NULL);
-}
-
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-
-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
-
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
-{
-  p->posLimit -= subValue;
-  p->pos -= subValue;
-  p->streamPos -= subValue;
-}
-
-static void MatchFinder_ReadBlock(CMatchFinder *p)
-{
-  if (p->streamEndWasReached || p->result != SZ_OK)
-    return;
-
-  /* We use (p->streamPos - p->pos) value. (p->streamPos < p->pos) is allowed. */
-
-  if (p->directInput)
-  {
-    UInt32 curSize = 0xFFFFFFFF - (p->streamPos - p->pos);
-    if (curSize > p->directInputRem)
-      curSize = (UInt32)p->directInputRem;
-    p->directInputRem -= curSize;
-    p->streamPos += curSize;
-    if (p->directInputRem == 0)
-      p->streamEndWasReached = 1;
-    return;
-  }
-
-  for (;;)
-  {
-    Byte *dest = p->buffer + (p->streamPos - p->pos);
-    size_t size = (p->bufferBase + p->blockSize - dest);
-    if (size == 0)
-      return;
-
-    p->result = p->stream->Read(p->stream, dest, &size);
-    if (p->result != SZ_OK)
-      return;
-    if (size == 0)
-    {
-      p->streamEndWasReached = 1;
-      return;
-    }
-    p->streamPos += (UInt32)size;
-    if (p->streamPos - p->pos > p->keepSizeAfter)
-      return;
-  }
-}
-
-void MatchFinder_MoveBlock(CMatchFinder *p)
-{
-  memmove(p->bufferBase,
-      p->buffer - p->keepSizeBefore,
-      (size_t)(p->streamPos - p->pos) + p->keepSizeBefore);
-  p->buffer = p->bufferBase + p->keepSizeBefore;
-}
-
-int MatchFinder_NeedMove(CMatchFinder *p)
-{
-  if (p->directInput)
-    return 0;
-  /* if (p->streamEndWasReached) return 0; */
-  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
-}
-
-void MatchFinder_ReadIfRequired(CMatchFinder *p)
-{
-  if (p->streamEndWasReached)
-    return;
-  if (p->keepSizeAfter >= p->streamPos - p->pos)
-    MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
-{
-  if (MatchFinder_NeedMove(p))
-    MatchFinder_MoveBlock(p);
-  MatchFinder_ReadBlock(p);
-}
-
-static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
-{
-  p->cutValue = 32;
-  p->btMode = 1;
-  p->numHashBytes = 4;
-  p->bigHash = 0;
-}
-
-#define kCrcPoly 0xEDB88320
-
-void MatchFinder_Construct(CMatchFinder *p)
-{
-  UInt32 i;
-  p->bufferBase = NULL;
-  p->directInput = 0;
-  p->hash = NULL;
-  MatchFinder_SetDefaultSettings(p);
-
-  for (i = 0; i < 256; i++)
-  {
-    UInt32 r = i;
-    unsigned j;
-    for (j = 0; j < 8; j++)
-      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
-    p->crc[i] = r;
-  }
-}
-
-static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
-{
-  alloc->Free(alloc, p->hash);
-  p->hash = NULL;
-}
-
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
-{
-  MatchFinder_FreeThisClassMemory(p, alloc);
-  LzInWindow_Free(p, alloc);
-}
-
-static CLzRef* AllocRefs(size_t num, ISzAlloc *alloc)
-{
-  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
-  if (sizeInBytes / sizeof(CLzRef) != num)
-    return NULL;
-  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
-}
-
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc)
-{
-  UInt32 sizeReserv;
-
-  if (historySize > kMaxHistorySize)
-  {
-    MatchFinder_Free(p, alloc);
-    return 0;
-  }
-
-  sizeReserv = historySize >> 1;
-       if (historySize >= ((UInt32)3 << 30)) sizeReserv = historySize >> 3;
-  else if (historySize >= ((UInt32)2 << 30)) sizeReserv = historySize >> 2;
-
-  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);
-
-  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
-  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
-
-  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
-
-  if (LzInWindow_Create(p, sizeReserv, alloc))
-  {
-    UInt32 newCyclicBufferSize = historySize + 1;
-    UInt32 hs;
-    p->matchMaxLen = matchMaxLen;
-    {
-      p->fixedHashSize = 0;
-      if (p->numHashBytes == 2)
-        hs = (1 << 16) - 1;
-      else
-      {
-        hs = historySize - 1;
-        hs |= (hs >> 1);
-        hs |= (hs >> 2);
-        hs |= (hs >> 4);
-        hs |= (hs >> 8);
-        hs >>= 1;
-        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
-        if (hs > (1 << 24))
-        {
-          if (p->numHashBytes == 3)
-            hs = (1 << 24) - 1;
-          else
-            hs >>= 1;
-          /* if (bigHash) mode, GetHeads4b() in LzFindMt.c needs (hs >= ((1 << 24) - 1))) */
-        }
-      }
-      p->hashMask = hs;
-      hs++;
-      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
-      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
-      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
-      hs += p->fixedHashSize;
-    }
-
-    {
-      size_t newSize;
-      size_t numSons;
-      p->historySize = historySize;
-      p->hashSizeSum = hs;
-      p->cyclicBufferSize = newCyclicBufferSize;
-
-      numSons = newCyclicBufferSize;
-      if (p->btMode)
-        numSons <<= 1;
-      newSize = hs + numSons;
-
-      if (p->hash && p->numRefs == newSize)
-        return 1;
-
-      MatchFinder_FreeThisClassMemory(p, alloc);
-      p->numRefs = newSize;
-      p->hash = AllocRefs(newSize, alloc);
-
-      if (p->hash)
-      {
-        p->son = p->hash + p->hashSizeSum;
-        return 1;
-      }
-    }
-  }
-
-  MatchFinder_Free(p, alloc);
-  return 0;
-}
-
-static void MatchFinder_SetLimits(CMatchFinder *p)
-{
-  UInt32 limit = kMaxValForNormalize - p->pos;
-  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
-
-  if (limit2 < limit)
-    limit = limit2;
-  limit2 = p->streamPos - p->pos;
-
-  if (limit2 <= p->keepSizeAfter)
-  {
-    if (limit2 > 0)
-      limit2 = 1;
-  }
-  else
-    limit2 -= p->keepSizeAfter;
-
-  if (limit2 < limit)
-    limit = limit2;
-
-  {
-    UInt32 lenLimit = p->streamPos - p->pos;
-    if (lenLimit > p->matchMaxLen)
-      lenLimit = p->matchMaxLen;
-    p->lenLimit = lenLimit;
-  }
-  p->posLimit = p->pos + limit;
-}
-
-void MatchFinder_Init_2(CMatchFinder *p, int readData)
-{
-  UInt32 i;
-  UInt32 *hash = p->hash;
-  UInt32 num = p->hashSizeSum;
-  for (i = 0; i < num; i++)
-    hash[i] = kEmptyHashValue;
-
-  p->cyclicBufferPos = 0;
-  p->buffer = p->bufferBase;
-  p->pos = p->streamPos = p->cyclicBufferSize;
-  p->result = SZ_OK;
-  p->streamEndWasReached = 0;
-
-  if (readData)
-    MatchFinder_ReadBlock(p);
-
-  MatchFinder_SetLimits(p);
-}
-
-void MatchFinder_Init(CMatchFinder *p)
-{
-  MatchFinder_Init_2(p, True);
-}
-
-static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
-{
-  return (p->pos - p->historySize - 1) & kNormalizeMask;
-}
-
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, size_t numItems)
-{
-  size_t i;
-  for (i = 0; i < numItems; i++)
-  {
-    UInt32 value = items[i];
-    if (value <= subValue)
-      value = kEmptyHashValue;
-    else
-      value -= subValue;
-    items[i] = value;
-  }
-}
-
-static void MatchFinder_Normalize(CMatchFinder *p)
-{
-  UInt32 subValue = MatchFinder_GetSubValue(p);
-  MatchFinder_Normalize3(subValue, p->hash, p->numRefs);
-  MatchFinder_ReduceOffsets(p, subValue);
-}
-
-static void MatchFinder_CheckLimits(CMatchFinder *p)
-{
-  if (p->pos == kMaxValForNormalize)
-    MatchFinder_Normalize(p);
-  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
-    MatchFinder_CheckAndMoveAndRead(p);
-  if (p->cyclicBufferPos == p->cyclicBufferSize)
-    p->cyclicBufferPos = 0;
-  MatchFinder_SetLimits(p);
-}
-
-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  son[_cyclicBufferPos] = curMatch;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-      return distances;
-    {
-      const Byte *pb = cur - delta;
-      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
-      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
-      {
-        UInt32 len = 0;
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        if (maxLen < len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-            return distances;
-        }
-      }
-    }
-  }
-}
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
-    UInt32 *distances, UInt32 maxLen)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return distances;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 < len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        if (++len != lenLimit && pb[len] == cur[len])
-          while (++len != lenLimit)
-            if (pb[len] != cur[len])
-              break;
-        if (maxLen < len)
-        {
-          *distances++ = maxLen = len;
-          *distances++ = delta - 1;
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return distances;
-          }
-        }
-      }
-      if (pb[len] < cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
-{
-  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
-  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
-  UInt32 len0 = 0, len1 = 0;
-  for (;;)
-  {
-    UInt32 delta = pos - curMatch;
-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
-    {
-      *ptr0 = *ptr1 = kEmptyHashValue;
-      return;
-    }
-    {
-      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
-      const Byte *pb = cur - delta;
-      UInt32 len = (len0 < len1 ? len0 : len1);
-      if (pb[len] == cur[len])
-      {
-        while (++len != lenLimit)
-          if (pb[len] != cur[len])
-            break;
-        {
-          if (len == lenLimit)
-          {
-            *ptr1 = pair[0];
-            *ptr0 = pair[1];
-            return;
-          }
-        }
-      }
-      if (pb[len] < cur[len])
-      {
-        *ptr1 = curMatch;
-        ptr1 = pair + 1;
-        curMatch = *ptr1;
-        len1 = len;
-      }
-      else
-      {
-        *ptr0 = curMatch;
-        ptr0 = pair;
-        curMatch = *ptr0;
-        len0 = len;
-      }
-    }
-  }
-}
-
-#define MOVE_POS \
-  ++p->cyclicBufferPos; \
-  p->buffer++; \
-  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
-
-#define MOVE_POS_RET MOVE_POS return offset;
-
-static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
-
-#define GET_MATCHES_HEADER2(minLen, ret_op) \
-  UInt32 lenLimit; UInt32 hv; const Byte *cur; UInt32 curMatch; \
-  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
-  cur = p->buffer;
-
-#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
-#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)
-
-#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue
-
-#define GET_MATCHES_FOOTER(offset, maxLen) \
-  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
-  distances + offset, maxLen) - distances); MOVE_POS_RET;
-
-#define SKIP_FOOTER \
-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
-
-#define UPDATE_maxLen { \
-    ptrdiff_t diff = (ptrdiff_t)0 - d2; \
-    const Byte *c = cur + maxLen; \
-    const Byte *lim = cur + lenLimit; \
-    for (; c != lim; c++) if (*(c + diff) != *c) break; \
-    maxLen = (UInt32)(c - cur); }
-
-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(2)
-  HASH2_CALC;
-  curMatch = p->hash[hv];
-  p->hash[hv] = p->pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 1)
-}
-
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p->hash[hv];
-  p->hash[hv] = p->pos;
-  offset = 0;
-  GET_MATCHES_FOOTER(offset, 2)
-}
-
-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 h2, d2, maxLen, offset, pos;
-  UInt32 *hash;
-  GET_MATCHES_HEADER(3)
-
-  HASH3_CALC;
-
-  hash = p->hash;
-  pos = p->pos;
-
-  d2 = pos - hash[h2];
-
-  curMatch = hash[kFix3HashSize + hv];
-
-  hash[h2] = pos;
-  hash[kFix3HashSize + hv] = pos;
-
-  maxLen = 2;
-  offset = 0;
-
-  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)
-  {
-    UPDATE_maxLen
-    distances[0] = maxLen;
-    distances[1] = d2 - 1;
-    offset = 2;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 h2, h3, d2, d3, maxLen, offset, pos;
-  UInt32 *hash;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  hash = p->hash;
-  pos = p->pos;
-
-  d2 = pos - hash[                h2];
-  d3 = pos - hash[kFix3HashSize + h3];
-
-  curMatch = hash[kFix4HashSize + hv];
-
-  hash[                h2] = pos;
-  hash[kFix3HashSize + h3] = pos;
-  hash[kFix4HashSize + hv] = pos;
-
-  maxLen = 0;
-  offset = 0;
-
-  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = d2 - 1;
-    offset = 2;
-  }
-
-  if (d2 != d3 && d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = d3 - 1;
-    offset += 2;
-    d2 = d3;
-  }
-
-  if (offset != 0)
-  {
-    UPDATE_maxLen
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-
-  if (maxLen < 3)
-    maxLen = 3;
-
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-
-/*
-static UInt32 Bt5_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 h2, h3, h4, d2, d3, d4, maxLen, offset, pos;
-  UInt32 *hash;
-  GET_MATCHES_HEADER(5)
-
-  HASH5_CALC;
-
-  hash = p->hash;
-  pos = p->pos;
-
-  d2 = pos - hash[                h2];
-  d3 = pos - hash[kFix3HashSize + h3];
-  d4 = pos - hash[kFix4HashSize + h4];
-
-  curMatch = hash[kFix5HashSize + hv];
-
-  hash[                h2] = pos;
-  hash[kFix3HashSize + h3] = pos;
-  hash[kFix4HashSize + h4] = pos;
-  hash[kFix5HashSize + hv] = pos;
-
-  maxLen = 0;
-  offset = 0;
-
-  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = d2 - 1;
-    offset = 2;
-    if (*(cur - d2 + 2) == cur[2])
-      distances[0] = maxLen = 3;
-    else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-    {
-      distances[2] = maxLen = 3;
-      distances[3] = d3 - 1;
-      offset = 4;
-      d2 = d3;
-    }
-  }
-  else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-  {
-    distances[0] = maxLen = 3;
-    distances[1] = d3 - 1;
-    offset = 2;
-    d2 = d3;
-  }
-
-  if (d2 != d4 && d4 < p->cyclicBufferSize
-      && *(cur - d4) == *cur
-      && *(cur - d4 + 3) == *(cur + 3))
-  {
-    maxLen = 4;
-    distances[offset + 1] = d4 - 1;
-    offset += 2;
-    d2 = d4;
-  }
-
-  if (offset != 0)
-  {
-    UPDATE_maxLen
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
-      MOVE_POS_RET;
-    }
-  }
-
-  if (maxLen < 4)
-    maxLen = 4;
-
-  GET_MATCHES_FOOTER(offset, maxLen)
-}
-*/
-
-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 h2, h3, d2, d3, maxLen, offset, pos;
-  UInt32 *hash;
-  GET_MATCHES_HEADER(4)
-
-  HASH4_CALC;
-
-  hash = p->hash;
-  pos = p->pos;
-
-  d2 = pos - hash[                h2];
-  d3 = pos - hash[kFix3HashSize + h3];
-
-  curMatch = hash[kFix4HashSize + hv];
-
-  hash[                h2] = pos;
-  hash[kFix3HashSize + h3] = pos;
-  hash[kFix4HashSize + hv] = pos;
-
-  maxLen = 0;
-  offset = 0;
-
-  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = d2 - 1;
-    offset = 2;
-  }
-
-  if (d2 != d3 && d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-  {
-    maxLen = 3;
-    distances[offset + 1] = d3 - 1;
-    offset += 2;
-    d2 = d3;
-  }
-
-  if (offset != 0)
-  {
-    UPDATE_maxLen
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      p->son[p->cyclicBufferPos] = curMatch;
-      MOVE_POS_RET;
-    }
-  }
-
-  if (maxLen < 3)
-    maxLen = 3;
-
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-      distances + offset, maxLen) - (distances));
-  MOVE_POS_RET
-}
-
-/*
-static UInt32 Hc5_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 h2, h3, h4, d2, d3, d4, maxLen, offset, pos
-  UInt32 *hash;
-  GET_MATCHES_HEADER(5)
-
-  HASH5_CALC;
-
-  hash = p->hash;
-  pos = p->pos;
-
-  d2 = pos - hash[                h2];
-  d3 = pos - hash[kFix3HashSize + h3];
-  d4 = pos - hash[kFix4HashSize + h4];
-
-  curMatch = hash[kFix5HashSize + hv];
-
-  hash[                h2] = pos;
-  hash[kFix3HashSize + h3] = pos;
-  hash[kFix4HashSize + h4] = pos;
-  hash[kFix5HashSize + hv] = pos;
-
-  maxLen = 0;
-  offset = 0;
-
-  if (d2 < p->cyclicBufferSize && *(cur - d2) == *cur)
-  {
-    distances[0] = maxLen = 2;
-    distances[1] = d2 - 1;
-    offset = 2;
-    if (*(cur - d2 + 2) == cur[2])
-      distances[0] = maxLen = 3;
-    else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-    {
-      distances[2] = maxLen = 3;
-      distances[3] = d3 - 1;
-      offset = 4;
-      d2 = d3;
-    }
-  }
-  else if (d3 < p->cyclicBufferSize && *(cur - d3) == *cur)
-  {
-    distances[0] = maxLen = 3;
-    distances[1] = d3 - 1;
-    offset = 2;
-    d2 = d3;
-  }
-
-  if (d2 != d4 && d4 < p->cyclicBufferSize
-      && *(cur - d4) == *cur
-      && *(cur - d4 + 3) == *(cur + 3))
-  {
-    maxLen = 4;
-    distances[offset + 1] = d4 - 1;
-    offset += 2;
-    d2 = d4;
-  }
-
-  if (offset != 0)
-  {
-    UPDATE_maxLen
-    distances[offset - 2] = maxLen;
-    if (maxLen == lenLimit)
-    {
-      p->son[p->cyclicBufferPos] = curMatch;
-      MOVE_POS_RET;
-    }
-  }
-
-  if (maxLen < 4)
-    maxLen = 4;
-
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-      distances + offset, maxLen) - (distances));
-  MOVE_POS_RET
-}
-*/
-
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
-{
-  UInt32 offset;
-  GET_MATCHES_HEADER(3)
-  HASH_ZIP_CALC;
-  curMatch = p->hash[hv];
-  p->hash[hv] = p->pos;
-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
-      distances, 2) - (distances));
-  MOVE_POS_RET
-}
-
-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(2)
-    HASH2_CALC;
-    curMatch = p->hash[hv];
-    p->hash[hv] = p->pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p->hash[hv];
-    p->hash[hv] = p->pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 h2;
-    UInt32 *hash;
-    SKIP_HEADER(3)
-    HASH3_CALC;
-    hash = p->hash;
-    curMatch = hash[kFix3HashSize + hv];
-    hash[h2] =
-    hash[kFix3HashSize + hv] = p->pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 h2, h3;
-    UInt32 *hash;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    hash = p->hash;
-    curMatch = hash[kFix4HashSize + hv];
-    hash[                h2] =
-    hash[kFix3HashSize + h3] =
-    hash[kFix4HashSize + hv] = p->pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-
-/*
-static void Bt5_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 h2, h3, h4;
-    UInt32 *hash;
-    SKIP_HEADER(5)
-    HASH5_CALC;
-    hash = p->hash;
-    curMatch = hash[kFix5HashSize + hv];
-    hash[                h2] =
-    hash[kFix3HashSize + h3] =
-    hash[kFix4HashSize + h4] =
-    hash[kFix5HashSize + hv] = p->pos;
-    SKIP_FOOTER
-  }
-  while (--num != 0);
-}
-*/
-
-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 h2, h3;
-    UInt32 *hash;
-    SKIP_HEADER(4)
-    HASH4_CALC;
-    hash = p->hash;
-    curMatch = hash[kFix4HashSize + hv];
-    hash[                h2] =
-    hash[kFix3HashSize + h3] =
-    hash[kFix4HashSize + hv] = p->pos;
-    p->son[p->cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-/*
-static void Hc5_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    UInt32 h2, h3, h4;
-    UInt32 *hash;
-    SKIP_HEADER(5)
-    HASH5_CALC;
-    hash = p->hash;
-    curMatch = p->hash[kFix5HashSize + hv];
-    hash[                h2] =
-    hash[kFix3HashSize + h3] =
-    hash[kFix4HashSize + h4] =
-    hash[kFix5HashSize + hv] = p->pos;
-    p->son[p->cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-*/
-
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
-{
-  do
-  {
-    SKIP_HEADER(3)
-    HASH_ZIP_CALC;
-    curMatch = p->hash[hv];
-    p->hash[hv] = p->pos;
-    p->son[p->cyclicBufferPos] = curMatch;
-    MOVE_POS
-  }
-  while (--num != 0);
-}
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
-{
-  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
-  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
-  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-  if (!p->btMode)
-  {
-    /* if (p->numHashBytes <= 4) */
-    {
-      vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
-      vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
-    }
-    /*
-    else
-    {
-      vTable->GetMatches = (Mf_GetMatches_Func)Hc5_MatchFinder_GetMatches;
-      vTable->Skip = (Mf_Skip_Func)Hc5_MatchFinder_Skip;
-    }
-    */
-  }
-  else if (p->numHashBytes == 2)
-  {
-    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
-    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
-  }
-  else if (p->numHashBytes == 3)
-  {
-    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
-    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
-  }
-  else /* if (p->numHashBytes == 4) */
-  {
-    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
-  }
-  /*
-  else
-  {
-    vTable->GetMatches = (Mf_GetMatches_Func)Bt5_MatchFinder_GetMatches;
-    vTable->Skip = (Mf_Skip_Func)Bt5_MatchFinder_Skip;
-  }
-  */
-}
diff --git a/src/calibre_lzma/LzFind.h b/src/calibre_lzma/LzFind.h
deleted file mode 100644
index 2ff6673771..0000000000
--- a/src/calibre_lzma/LzFind.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* LzFind.h -- Match finder for LZ algorithms
-2015-10-15 : Igor Pavlov : Public domain */
-
-#ifndef __LZ_FIND_H
-#define __LZ_FIND_H
-
-#include "7zTypes.h"
-
-EXTERN_C_BEGIN
-
-typedef UInt32 CLzRef;
-
-typedef struct _CMatchFinder
-{
-  Byte *buffer;
-  UInt32 pos;
-  UInt32 posLimit;
-  UInt32 streamPos;
-  UInt32 lenLimit;
-
-  UInt32 cyclicBufferPos;
-  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */
-
-  Byte streamEndWasReached;
-  Byte btMode;
-  Byte bigHash;
-  Byte directInput;
-
-  UInt32 matchMaxLen;
-  CLzRef *hash;
-  CLzRef *son;
-  UInt32 hashMask;
-  UInt32 cutValue;
-
-  Byte *bufferBase;
-  ISeqInStream *stream;
-  
-  UInt32 blockSize;
-  UInt32 keepSizeBefore;
-  UInt32 keepSizeAfter;
-
-  UInt32 numHashBytes;
-  size_t directInputRem;
-  UInt32 historySize;
-  UInt32 fixedHashSize;
-  UInt32 hashSizeSum;
-  SRes result;
-  UInt32 crc[256];
-  size_t numRefs;
-} CMatchFinder;
-
-#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
-
-#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
-
-#define Inline_MatchFinder_IsFinishedOK(p) \
-    ((p)->streamEndWasReached \
-        && (p)->streamPos == (p)->pos \
-        && (!(p)->directInput || (p)->directInputRem == 0))
-      
-int MatchFinder_NeedMove(CMatchFinder *p);
-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
-void MatchFinder_MoveBlock(CMatchFinder *p);
-void MatchFinder_ReadIfRequired(CMatchFinder *p);
-
-void MatchFinder_Construct(CMatchFinder *p);
-
-/* Conditions:
-     historySize <= 3 GB
-     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
-*/
-int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
-    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
-    ISzAlloc *alloc);
-void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, size_t numItems);
-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
-
-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
-    UInt32 *distances, UInt32 maxLen);
-
-/*
-Conditions:
-  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
-  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
-*/
-
-typedef void (*Mf_Init_Func)(void *object);
-typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
-typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
-typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
-typedef void (*Mf_Skip_Func)(void *object, UInt32);
-
-typedef struct _IMatchFinder
-{
-  Mf_Init_Func Init;
-  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
-  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
-  Mf_GetMatches_Func GetMatches;
-  Mf_Skip_Func Skip;
-} IMatchFinder;
-
-void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
-
-void MatchFinder_Init_2(CMatchFinder *p, int readData);
-void MatchFinder_Init(CMatchFinder *p);
-
-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
-
-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/LzHash.h b/src/calibre_lzma/LzHash.h
deleted file mode 100644
index 2191444072..0000000000
--- a/src/calibre_lzma/LzHash.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* LzHash.h -- HASH functions for LZ algorithms
-2015-04-12 : Igor Pavlov : Public domain */
-
-#ifndef __LZ_HASH_H
-#define __LZ_HASH_H
-
-#define kHash2Size (1 << 10)
-#define kHash3Size (1 << 16)
-#define kHash4Size (1 << 20)
-
-#define kFix3HashSize (kHash2Size)
-#define kFix4HashSize (kHash2Size + kHash3Size)
-#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)
-
-#define HASH2_CALC hv = cur[0] | ((UInt32)cur[1] << 8);
-
-#define HASH3_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  h2 = temp & (kHash2Size - 1); \
-  hv = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }
-
-#define HASH4_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  h2 = temp & (kHash2Size - 1); \
-  temp ^= ((UInt32)cur[2] << 8); \
-  h3 = temp & (kHash3Size - 1); \
-  hv = (temp ^ (p->crc[cur[3]] << 5)) & p->hashMask; }
-
-#define HASH5_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  h2 = temp & (kHash2Size - 1); \
-  temp ^= ((UInt32)cur[2] << 8); \
-  h3 = temp & (kHash3Size - 1); \
-  temp ^= (p->crc[cur[3]] << 5); \
-  h4 = temp & (kHash4Size - 1); \
-  hv = (temp ^ (p->crc[cur[4]] << 3)) & p->hashMask; }
-
-/* #define HASH_ZIP_CALC hv = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
-#define HASH_ZIP_CALC hv = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;
-
-
-#define MT_HASH2_CALC \
-  h2 = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);
-
-#define MT_HASH3_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  h2 = temp & (kHash2Size - 1); \
-  h3 = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }
-
-#define MT_HASH4_CALC { \
-  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
-  h2 = temp & (kHash2Size - 1); \
-  temp ^= ((UInt32)cur[2] << 8); \
-  h3 = temp & (kHash3Size - 1); \
-  h4 = (temp ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }
-
-#endif
diff --git a/src/calibre_lzma/Lzma2Dec.c b/src/calibre_lzma/Lzma2Dec.c
deleted file mode 100644
index d44d25e432..0000000000
--- a/src/calibre_lzma/Lzma2Dec.c
+++ /dev/null
@@ -1,378 +0,0 @@
-/* Lzma2Dec.c -- LZMA2 Decoder
-2015-11-09 : Igor Pavlov : Public domain */
-
-/* #define SHOW_DEBUG_INFO */
-
-#include "Precomp.h"
-
-#ifdef SHOW_DEBUG_INFO
-#include <stdio.h>
-#endif
-
-#include <string.h>
-
-#include "Lzma2Dec.h"
-
-/*
-00000000  -  EOS
-00000001 U U  -  Uncompressed Reset Dic
-00000010 U U  -  Uncompressed No Reset
-100uuuuu U U P P  -  LZMA no reset
-101uuuuu U U P P  -  LZMA reset state
-110uuuuu U U P P S  -  LZMA reset state + new prop
-111uuuuu U U P P S  -  LZMA reset state + new prop + reset dic
-
-  u, U - Unpack Size
-  P - Pack Size
-  S - Props
-*/
-
-#define LZMA2_CONTROL_LZMA (1 << 7)
-#define LZMA2_CONTROL_COPY_NO_RESET 2
-#define LZMA2_CONTROL_COPY_RESET_DIC 1
-#define LZMA2_CONTROL_EOF 0
-
-#define LZMA2_IS_UNCOMPRESSED_STATE(p) (((p)->control & LZMA2_CONTROL_LZMA) == 0)
-
-#define LZMA2_GET_LZMA_MODE(p) (((p)->control >> 5) & 3)
-#define LZMA2_IS_THERE_PROP(mode) ((mode) >= 2)
-
-#define LZMA2_LCLP_MAX 4
-#define LZMA2_DIC_SIZE_FROM_PROP(p) (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11))
-
-#ifdef SHOW_DEBUG_INFO
-#define PRF(x) x
-#else
-#define PRF(x)
-#endif
-
-typedef enum
-{
-  LZMA2_STATE_CONTROL,
-  LZMA2_STATE_UNPACK0,
-  LZMA2_STATE_UNPACK1,
-  LZMA2_STATE_PACK0,
-  LZMA2_STATE_PACK1,
-  LZMA2_STATE_PROP,
-  LZMA2_STATE_DATA,
-  LZMA2_STATE_DATA_CONT,
-  LZMA2_STATE_FINISHED,
-  LZMA2_STATE_ERROR
-} ELzma2State;
-
-static SRes Lzma2Dec_GetOldProps(Byte prop, Byte *props)
-{
-  UInt32 dicSize;
-  if (prop > 40)
-    return SZ_ERROR_UNSUPPORTED;
-  dicSize = (prop == 40) ? 0xFFFFFFFF : LZMA2_DIC_SIZE_FROM_PROP(prop);
-  props[0] = (Byte)LZMA2_LCLP_MAX;
-  props[1] = (Byte)(dicSize);
-  props[2] = (Byte)(dicSize >> 8);
-  props[3] = (Byte)(dicSize >> 16);
-  props[4] = (Byte)(dicSize >> 24);
-  return SZ_OK;
-}
-
-SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
-{
-  Byte props[LZMA_PROPS_SIZE];
-  RINOK(Lzma2Dec_GetOldProps(prop, props));
-  return LzmaDec_AllocateProbs(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
-}
-
-SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc)
-{
-  Byte props[LZMA_PROPS_SIZE];
-  RINOK(Lzma2Dec_GetOldProps(prop, props));
-  return LzmaDec_Allocate(&p->decoder, props, LZMA_PROPS_SIZE, alloc);
-}
-
-void Lzma2Dec_Init(CLzma2Dec *p)
-{
-  p->state = LZMA2_STATE_CONTROL;
-  p->needInitDic = True;
-  p->needInitState = True;
-  p->needInitProp = True;
-  LzmaDec_Init(&p->decoder);
-}
-
-static ELzma2State Lzma2Dec_UpdateState(CLzma2Dec *p, Byte b)
-{
-  switch (p->state)
-  {
-    case LZMA2_STATE_CONTROL:
-      p->control = b;
-      PRF(printf("\n %4X ", (unsigned)p->decoder.dicPos));
-      PRF(printf(" %2X", (unsigned)b));
-      if (p->control == 0)
-        return LZMA2_STATE_FINISHED;
-      if (LZMA2_IS_UNCOMPRESSED_STATE(p))
-      {
-        if ((p->control & 0x7F) > 2)
-          return LZMA2_STATE_ERROR;
-        p->unpackSize = 0;
-      }
-      else
-        p->unpackSize = (UInt32)(p->control & 0x1F) << 16;
-      return LZMA2_STATE_UNPACK0;
-
-    case LZMA2_STATE_UNPACK0:
-      p->unpackSize |= (UInt32)b << 8;
-      return LZMA2_STATE_UNPACK1;
-
-    case LZMA2_STATE_UNPACK1:
-      p->unpackSize |= (UInt32)b;
-      p->unpackSize++;
-      PRF(printf(" %8u", (unsigned)p->unpackSize));
-      return (LZMA2_IS_UNCOMPRESSED_STATE(p)) ? LZMA2_STATE_DATA : LZMA2_STATE_PACK0;
-
-    case LZMA2_STATE_PACK0:
-      p->packSize = (UInt32)b << 8;
-      return LZMA2_STATE_PACK1;
-
-    case LZMA2_STATE_PACK1:
-      p->packSize |= (UInt32)b;
-      p->packSize++;
-      PRF(printf(" %8u", (unsigned)p->packSize));
-      return LZMA2_IS_THERE_PROP(LZMA2_GET_LZMA_MODE(p)) ? LZMA2_STATE_PROP:
-        (p->needInitProp ? LZMA2_STATE_ERROR : LZMA2_STATE_DATA);
-
-    case LZMA2_STATE_PROP:
-    {
-      unsigned lc, lp;
-      if (b >= (9 * 5 * 5))
-        return LZMA2_STATE_ERROR;
-      lc = b % 9;
-      b /= 9;
-      p->decoder.prop.pb = b / 5;
-      lp = b % 5;
-      if (lc + lp > LZMA2_LCLP_MAX)
-        return LZMA2_STATE_ERROR;
-      p->decoder.prop.lc = lc;
-      p->decoder.prop.lp = lp;
-      p->needInitProp = False;
-      return LZMA2_STATE_DATA;
-    }
-  }
-  return LZMA2_STATE_ERROR;
-}
-
-static void LzmaDec_UpdateWithUncompressed(CLzmaDec *p, const Byte *src, SizeT size)
-{
-  memcpy(p->dic + p->dicPos, src, size);
-  p->dicPos += size;
-  if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= size)
-    p->checkDicSize = p->prop.dicSize;
-  p->processedPos += (UInt32)size;
-}
-
-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState);
-
-SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT inSize = *srcLen;
-  *srcLen = 0;
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-
-  while (p->state != LZMA2_STATE_FINISHED)
-  {
-    SizeT dicPos = p->decoder.dicPos;
-
-    if (p->state == LZMA2_STATE_ERROR)
-      return SZ_ERROR_DATA;
-
-    if (dicPos == dicLimit && finishMode == LZMA_FINISH_ANY)
-    {
-      *status = LZMA_STATUS_NOT_FINISHED;
-      return SZ_OK;
-    }
-
-    if (p->state != LZMA2_STATE_DATA && p->state != LZMA2_STATE_DATA_CONT)
-    {
-      if (*srcLen == inSize)
-      {
-        *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-        return SZ_OK;
-      }
-      (*srcLen)++;
-      p->state = Lzma2Dec_UpdateState(p, *src++);
-
-      if (dicPos == dicLimit && p->state != LZMA2_STATE_FINISHED)
-      {
-        p->state = LZMA2_STATE_ERROR;
-        return SZ_ERROR_DATA;
-      }
-      continue;
-    }
-
-    {
-      SizeT destSizeCur = dicLimit - dicPos;
-      SizeT srcSizeCur = inSize - *srcLen;
-      ELzmaFinishMode curFinishMode = LZMA_FINISH_ANY;
-
-      if (p->unpackSize <= destSizeCur)
-      {
-        destSizeCur = (SizeT)p->unpackSize;
-        curFinishMode = LZMA_FINISH_END;
-      }
-
-      if (LZMA2_IS_UNCOMPRESSED_STATE(p))
-      {
-        if (*srcLen == inSize)
-        {
-          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-          return SZ_OK;
-        }
-
-        if (p->state == LZMA2_STATE_DATA)
-        {
-          Bool initDic = (p->control == LZMA2_CONTROL_COPY_RESET_DIC);
-          if (initDic)
-            p->needInitProp = p->needInitState = True;
-          else if (p->needInitDic)
-          {
-            p->state = LZMA2_STATE_ERROR;
-            return SZ_ERROR_DATA;
-          }
-          p->needInitDic = False;
-          LzmaDec_InitDicAndState(&p->decoder, initDic, False);
-        }
-
-        if (srcSizeCur > destSizeCur)
-          srcSizeCur = destSizeCur;
-
-        if (srcSizeCur == 0)
-        {
-          p->state = LZMA2_STATE_ERROR;
-          return SZ_ERROR_DATA;
-        }
-
-        LzmaDec_UpdateWithUncompressed(&p->decoder, src, srcSizeCur);
-
-        src += srcSizeCur;
-        *srcLen += srcSizeCur;
-        p->unpackSize -= (UInt32)srcSizeCur;
-        p->state = (p->unpackSize == 0) ? LZMA2_STATE_CONTROL : LZMA2_STATE_DATA_CONT;
-      }
-      else
-      {
-        SizeT outSizeProcessed;
-        SRes res;
-
-        if (p->state == LZMA2_STATE_DATA)
-        {
-          unsigned mode = LZMA2_GET_LZMA_MODE(p);
-          Bool initDic = (mode == 3);
-          Bool initState = (mode != 0);
-          if ((!initDic && p->needInitDic) || (!initState && p->needInitState))
-          {
-            p->state = LZMA2_STATE_ERROR;
-            return SZ_ERROR_DATA;
-          }
-
-          LzmaDec_InitDicAndState(&p->decoder, initDic, initState);
-          p->needInitDic = False;
-          p->needInitState = False;
-          p->state = LZMA2_STATE_DATA_CONT;
-        }
-
-        if (srcSizeCur > p->packSize)
-          srcSizeCur = (SizeT)p->packSize;
-
-        res = LzmaDec_DecodeToDic(&p->decoder, dicPos + destSizeCur, src, &srcSizeCur, curFinishMode, status);
-
-        src += srcSizeCur;
-        *srcLen += srcSizeCur;
-        p->packSize -= (UInt32)srcSizeCur;
-
-        outSizeProcessed = p->decoder.dicPos - dicPos;
-        p->unpackSize -= (UInt32)outSizeProcessed;
-
-        RINOK(res);
-        if (*status == LZMA_STATUS_NEEDS_MORE_INPUT)
-          return res;
-
-        if (srcSizeCur == 0 && outSizeProcessed == 0)
-        {
-          if (*status != LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-              || p->unpackSize != 0
-              || p->packSize != 0)
-          {
-            p->state = LZMA2_STATE_ERROR;
-            return SZ_ERROR_DATA;
-          }
-          p->state = LZMA2_STATE_CONTROL;
-        }
-
-        if (*status == LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)
-          *status = LZMA_STATUS_NOT_FINISHED;
-      }
-    }
-  }
-
-  *status = LZMA_STATUS_FINISHED_WITH_MARK;
-  return SZ_OK;
-}
-
-SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT outSize = *destLen, inSize = *srcLen;
-  *srcLen = *destLen = 0;
-  for (;;)
-  {
-    SizeT srcSizeCur = inSize, outSizeCur, dicPos;
-    ELzmaFinishMode curFinishMode;
-    SRes res;
-    if (p->decoder.dicPos == p->decoder.dicBufSize)
-      p->decoder.dicPos = 0;
-    dicPos = p->decoder.dicPos;
-    if (outSize > p->decoder.dicBufSize - dicPos)
-    {
-      outSizeCur = p->decoder.dicBufSize;
-      curFinishMode = LZMA_FINISH_ANY;
-    }
-    else
-    {
-      outSizeCur = dicPos + outSize;
-      curFinishMode = finishMode;
-    }
-
-    res = Lzma2Dec_DecodeToDic(p, outSizeCur, src, &srcSizeCur, curFinishMode, status);
-    src += srcSizeCur;
-    inSize -= srcSizeCur;
-    *srcLen += srcSizeCur;
-    outSizeCur = p->decoder.dicPos - dicPos;
-    memcpy(dest, p->decoder.dic + dicPos, outSizeCur);
-    dest += outSizeCur;
-    outSize -= outSizeCur;
-    *destLen += outSizeCur;
-    if (res != 0)
-      return res;
-    if (outSizeCur == 0 || outSize == 0)
-      return SZ_OK;
-  }
-}
-
-SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc)
-{
-  CLzma2Dec p;
-  SRes res;
-  SizeT outSize = *destLen, inSize = *srcLen;
-  *destLen = *srcLen = 0;
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-  Lzma2Dec_Construct(&p);
-  RINOK(Lzma2Dec_AllocateProbs(&p, prop, alloc));
-  p.decoder.dic = dest;
-  p.decoder.dicBufSize = outSize;
-  Lzma2Dec_Init(&p);
-  *srcLen = inSize;
-  res = Lzma2Dec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-  *destLen = p.decoder.dicPos;
-  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-    res = SZ_ERROR_INPUT_EOF;
-  Lzma2Dec_FreeProbs(&p, alloc);
-  return res;
-}
diff --git a/src/calibre_lzma/Lzma2Dec.h b/src/calibre_lzma/Lzma2Dec.h
deleted file mode 100644
index 026cdefe99..0000000000
--- a/src/calibre_lzma/Lzma2Dec.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/* Lzma2Dec.h -- LZMA2 Decoder
-2015-05-13 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA2_DEC_H
-#define __LZMA2_DEC_H
-
-#include "LzmaDec.h"
-
-EXTERN_C_BEGIN
-
-/* ---------- State Interface ---------- */
-
-typedef struct
-{
-  CLzmaDec decoder;
-  UInt32 packSize;
-  UInt32 unpackSize;
-  unsigned state;
-  Byte control;
-  Bool needInitDic;
-  Bool needInitState;
-  Bool needInitProp;
-} CLzma2Dec;
-
-#define Lzma2Dec_Construct(p) LzmaDec_Construct(&(p)->decoder)
-#define Lzma2Dec_FreeProbs(p, alloc) LzmaDec_FreeProbs(&(p)->decoder, alloc);
-#define Lzma2Dec_Free(p, alloc) LzmaDec_Free(&(p)->decoder, alloc);
-
-SRes Lzma2Dec_AllocateProbs(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
-SRes Lzma2Dec_Allocate(CLzma2Dec *p, Byte prop, ISzAlloc *alloc);
-void Lzma2Dec_Init(CLzma2Dec *p);
-
-
-/*
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen or dicLimit).
-  LZMA_FINISH_ANY - use smallest number of input bytes
-  LZMA_FINISH_END - read EndOfStream marker after decoding
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_NEEDS_MORE_INPUT
-  SZ_ERROR_DATA - Data error
-*/
-
-SRes Lzma2Dec_DecodeToDic(CLzma2Dec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-SRes Lzma2Dec_DecodeToBuf(CLzma2Dec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- One Call Interface ---------- */
-
-/*
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - use smallest number of input bytes
-  LZMA_FINISH_END - read EndOfStream marker after decoding
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-  SZ_ERROR_DATA - Data error
-  SZ_ERROR_MEM  - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-*/
-
-SRes Lzma2Decode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    Byte prop, ELzmaFinishMode finishMode, ELzmaStatus *status, ISzAlloc *alloc);
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/Lzma2Enc.c b/src/calibre_lzma/Lzma2Enc.c
deleted file mode 100644
index a776ab7be7..0000000000
--- a/src/calibre_lzma/Lzma2Enc.c
+++ /dev/null
@@ -1,520 +0,0 @@
-/* Lzma2Enc.c -- LZMA2 Encoder
-2015-10-04 : Igor Pavlov : Public domain */
-
-#include "Precomp.h"
-
-/* #include <stdio.h> */
-#include <string.h>
-
-/* #define _7ZIP_ST */
-
-#include "Lzma2Enc.h"
-
-#ifndef _7ZIP_ST
-#include "MtCoder.h"
-#else
-#define NUM_MT_CODER_THREADS_MAX 1
-#endif
-
-#define LZMA2_CONTROL_LZMA (1 << 7)
-#define LZMA2_CONTROL_COPY_NO_RESET 2
-#define LZMA2_CONTROL_COPY_RESET_DIC 1
-#define LZMA2_CONTROL_EOF 0
-
-#define LZMA2_LCLP_MAX 4
-
-#define LZMA2_DIC_SIZE_FROM_PROP(p) (((UInt32)2 | ((p) & 1)) << ((p) / 2 + 11))
-
-#define LZMA2_PACK_SIZE_MAX (1 << 16)
-#define LZMA2_COPY_CHUNK_SIZE LZMA2_PACK_SIZE_MAX
-#define LZMA2_UNPACK_SIZE_MAX (1 << 21)
-#define LZMA2_KEEP_WINDOW_SIZE LZMA2_UNPACK_SIZE_MAX
-
-#define LZMA2_CHUNK_SIZE_COMPRESSED_MAX ((1 << 16) + 16)
-
-
-#define PRF(x) /* x */
-
-/* ---------- CLzma2EncInt ---------- */
-
-typedef struct
-{
-  CLzmaEncHandle enc;
-  UInt64 srcPos;
-  Byte props;
-  Bool needInitState;
-  Bool needInitProp;
-} CLzma2EncInt;
-
-static SRes Lzma2EncInt_Init(CLzma2EncInt *p, const CLzma2EncProps *props)
-{
-  Byte propsEncoded[LZMA_PROPS_SIZE];
-  SizeT propsSize = LZMA_PROPS_SIZE;
-  RINOK(LzmaEnc_SetProps(p->enc, &props->lzmaProps));
-  RINOK(LzmaEnc_WriteProperties(p->enc, propsEncoded, &propsSize));
-  p->srcPos = 0;
-  p->props = propsEncoded[0];
-  p->needInitState = True;
-  p->needInitProp = True;
-  return SZ_OK;
-}
-
-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp, ISeqInStream *inStream, UInt32 keepWindowSize,
-    ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize);
-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp);
-void LzmaEnc_Finish(CLzmaEncHandle pp);
-void LzmaEnc_SaveState(CLzmaEncHandle pp);
-void LzmaEnc_RestoreState(CLzmaEncHandle pp);
-
-
-static SRes Lzma2EncInt_EncodeSubblock(CLzma2EncInt *p, Byte *outBuf,
-    size_t *packSizeRes, ISeqOutStream *outStream)
-{
-  size_t packSizeLimit = *packSizeRes;
-  size_t packSize = packSizeLimit;
-  UInt32 unpackSize = LZMA2_UNPACK_SIZE_MAX;
-  unsigned lzHeaderSize = 5 + (p->needInitProp ? 1 : 0);
-  Bool useCopyBlock;
-  SRes res;
-
-  *packSizeRes = 0;
-  if (packSize < lzHeaderSize)
-    return SZ_ERROR_OUTPUT_EOF;
-  packSize -= lzHeaderSize;
-
-  LzmaEnc_SaveState(p->enc);
-  res = LzmaEnc_CodeOneMemBlock(p->enc, p->needInitState,
-      outBuf + lzHeaderSize, &packSize, LZMA2_PACK_SIZE_MAX, &unpackSize);
-
-  PRF(printf("\npackSize = %7d unpackSize = %7d  ", packSize, unpackSize));
-
-  if (unpackSize == 0)
-    return res;
-
-  if (res == SZ_OK)
-    useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));
-  else
-  {
-    if (res != SZ_ERROR_OUTPUT_EOF)
-      return res;
-    res = SZ_OK;
-    useCopyBlock = True;
-  }
-
-  if (useCopyBlock)
-  {
-    size_t destPos = 0;
-    PRF(printf("################# COPY           "));
-
-    while (unpackSize > 0)
-    {
-      UInt32 u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;
-      if (packSizeLimit - destPos < u + 3)
-        return SZ_ERROR_OUTPUT_EOF;
-      outBuf[destPos++] = (Byte)(p->srcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);
-      outBuf[destPos++] = (Byte)((u - 1) >> 8);
-      outBuf[destPos++] = (Byte)(u - 1);
-      memcpy(outBuf + destPos, LzmaEnc_GetCurBuf(p->enc) - unpackSize, u);
-      unpackSize -= u;
-      destPos += u;
-      p->srcPos += u;
-
-      if (outStream)
-      {
-        *packSizeRes += destPos;
-        if (outStream->Write(outStream, outBuf, destPos) != destPos)
-          return SZ_ERROR_WRITE;
-        destPos = 0;
-      }
-      else
-        *packSizeRes = destPos;
-      /* needInitState = True; */
-    }
-
-    LzmaEnc_RestoreState(p->enc);
-    return SZ_OK;
-  }
-
-  {
-    size_t destPos = 0;
-    UInt32 u = unpackSize - 1;
-    UInt32 pm = (UInt32)(packSize - 1);
-    unsigned mode = (p->srcPos == 0) ? 3 : (p->needInitState ? (p->needInitProp ? 2 : 1) : 0);
-
-    PRF(printf("               "));
-
-    outBuf[destPos++] = (Byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));
-    outBuf[destPos++] = (Byte)(u >> 8);
-    outBuf[destPos++] = (Byte)u;
-    outBuf[destPos++] = (Byte)(pm >> 8);
-    outBuf[destPos++] = (Byte)pm;
-
-    if (p->needInitProp)
-      outBuf[destPos++] = p->props;
-
-    p->needInitProp = False;
-    p->needInitState = False;
-    destPos += packSize;
-    p->srcPos += unpackSize;
-
-    if (outStream)
-      if (outStream->Write(outStream, outBuf, destPos) != destPos)
-        return SZ_ERROR_WRITE;
-
-    *packSizeRes = destPos;
-    return SZ_OK;
-  }
-}
-
-
-/* ---------- Lzma2 Props ---------- */
-
-void Lzma2EncProps_Init(CLzma2EncProps *p)
-{
-  LzmaEncProps_Init(&p->lzmaProps);
-  p->numTotalThreads = -1;
-  p->numBlockThreads = -1;
-  p->blockSize = 0;
-}
-
-void Lzma2EncProps_Normalize(CLzma2EncProps *p)
-{
-  int t1, t1n, t2, t3;
-  {
-    CLzmaEncProps lzmaProps = p->lzmaProps;
-    LzmaEncProps_Normalize(&lzmaProps);
-    t1n = lzmaProps.numThreads;
-  }
-
-  t1 = p->lzmaProps.numThreads;
-  t2 = p->numBlockThreads;
-  t3 = p->numTotalThreads;
-
-  if (t2 > NUM_MT_CODER_THREADS_MAX)
-    t2 = NUM_MT_CODER_THREADS_MAX;
-
-  if (t3 <= 0)
-  {
-    if (t2 <= 0)
-      t2 = 1;
-    t3 = t1n * t2;
-  }
-  else if (t2 <= 0)
-  {
-    t2 = t3 / t1n;
-    if (t2 == 0)
-    {
-      t1 = 1;
-      t2 = t3;
-    }
-    if (t2 > NUM_MT_CODER_THREADS_MAX)
-      t2 = NUM_MT_CODER_THREADS_MAX;
-  }
-  else if (t1 <= 0)
-  {
-    t1 = t3 / t2;
-    if (t1 == 0)
-      t1 = 1;
-  }
-  else
-    t3 = t1n * t2;
-
-  p->lzmaProps.numThreads = t1;
-
-  LzmaEncProps_Normalize(&p->lzmaProps);
-
-  t1 = p->lzmaProps.numThreads;
-
-  if (p->blockSize == 0)
-  {
-    UInt32 dictSize = p->lzmaProps.dictSize;
-    UInt64 blockSize = (UInt64)dictSize << 2;
-    const UInt32 kMinSize = (UInt32)1 << 20;
-    const UInt32 kMaxSize = (UInt32)1 << 28;
-    if (blockSize < kMinSize) blockSize = kMinSize;
-    if (blockSize > kMaxSize) blockSize = kMaxSize;
-    if (blockSize < dictSize) blockSize = dictSize;
-    p->blockSize = (size_t)blockSize;
-  }
-
-  if (t2 > 1 && p->lzmaProps.reduceSize != (UInt64)(Int64)-1)
-  {
-    UInt64 temp = p->lzmaProps.reduceSize + p->blockSize - 1;
-    if (temp > p->lzmaProps.reduceSize)
-    {
-      UInt64 numBlocks = temp / p->blockSize;
-      if (numBlocks < (unsigned)t2)
-      {
-        t2 = (unsigned)numBlocks;
-        if (t2 == 0)
-          t2 = 1;
-        t3 = t1 * t2;
-      }
-    }
-  }
-
-  p->numBlockThreads = t2;
-  p->numTotalThreads = t3;
-}
-
-
-static SRes Progress(ICompressProgress *p, UInt64 inSize, UInt64 outSize)
-{
-  return (p && p->Progress(p, inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;
-}
-
-
-/* ---------- Lzma2 ---------- */
-
-typedef struct
-{
-  Byte propEncoded;
-  CLzma2EncProps props;
-
-  Byte *outBuf;
-
-  ISzAlloc *alloc;
-  ISzAlloc *allocBig;
-
-  CLzma2EncInt coders[NUM_MT_CODER_THREADS_MAX];
-
-  #ifndef _7ZIP_ST
-  CMtCoder mtCoder;
-  #endif
-
-} CLzma2Enc;
-
-
-/* ---------- Lzma2EncThread ---------- */
-
-static SRes Lzma2Enc_EncodeMt1(CLzma2EncInt *p, CLzma2Enc *mainEncoder,
-  ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress)
-{
-  UInt64 packTotal = 0;
-  SRes res = SZ_OK;
-
-  if (!mainEncoder->outBuf)
-  {
-    mainEncoder->outBuf = (Byte *)IAlloc_Alloc(mainEncoder->alloc, LZMA2_CHUNK_SIZE_COMPRESSED_MAX);
-    if (!mainEncoder->outBuf)
-      return SZ_ERROR_MEM;
-  }
-
-  RINOK(Lzma2EncInt_Init(p, &mainEncoder->props));
-  RINOK(LzmaEnc_PrepareForLzma2(p->enc, inStream, LZMA2_KEEP_WINDOW_SIZE,
-      mainEncoder->alloc, mainEncoder->allocBig));
-
-  for (;;)
-  {
-    size_t packSize = LZMA2_CHUNK_SIZE_COMPRESSED_MAX;
-    res = Lzma2EncInt_EncodeSubblock(p, mainEncoder->outBuf, &packSize, outStream);
-    if (res != SZ_OK)
-      break;
-    packTotal += packSize;
-    res = Progress(progress, p->srcPos, packTotal);
-    if (res != SZ_OK)
-      break;
-    if (packSize == 0)
-      break;
-  }
-
-  LzmaEnc_Finish(p->enc);
-
-  if (res == SZ_OK)
-  {
-    Byte b = 0;
-    if (outStream->Write(outStream, &b, 1) != 1)
-      return SZ_ERROR_WRITE;
-  }
-
-  return res;
-}
-
-
-#ifndef _7ZIP_ST
-
-typedef struct
-{
-  IMtCoderCallback funcTable;
-  CLzma2Enc *lzma2Enc;
-} CMtCallbackImp;
-
-static SRes MtCallbackImp_Code(void *pp, unsigned index, Byte *dest, size_t *destSize,
-      const Byte *src, size_t srcSize, int finished)
-{
-  CMtCallbackImp *imp = (CMtCallbackImp *)pp;
-  CLzma2Enc *mainEncoder = imp->lzma2Enc;
-  CLzma2EncInt *p = &mainEncoder->coders[index];
-
-  SRes res = SZ_OK;
-  {
-    size_t destLim = *destSize;
-    *destSize = 0;
-
-    if (srcSize != 0)
-    {
-      RINOK(Lzma2EncInt_Init(p, &mainEncoder->props));
-
-      RINOK(LzmaEnc_MemPrepare(p->enc, src, srcSize, LZMA2_KEEP_WINDOW_SIZE,
-          mainEncoder->alloc, mainEncoder->allocBig));
-
-      while (p->srcPos < srcSize)
-      {
-        size_t packSize = destLim - *destSize;
-        res = Lzma2EncInt_EncodeSubblock(p, dest + *destSize, &packSize, NULL);
-        if (res != SZ_OK)
-          break;
-        *destSize += packSize;
-
-        if (packSize == 0)
-        {
-          res = SZ_ERROR_FAIL;
-          break;
-        }
-
-        if (MtProgress_Set(&mainEncoder->mtCoder.mtProgress, index, p->srcPos, *destSize) != SZ_OK)
-        {
-          res = SZ_ERROR_PROGRESS;
-          break;
-        }
-      }
-
-      LzmaEnc_Finish(p->enc);
-      if (res != SZ_OK)
-        return res;
-    }
-
-    if (finished)
-    {
-      if (*destSize == destLim)
-        return SZ_ERROR_OUTPUT_EOF;
-      dest[(*destSize)++] = 0;
-    }
-  }
-  return res;
-}
-
-#endif
-
-
-/* ---------- Lzma2Enc ---------- */
-
-CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzma2Enc *p = (CLzma2Enc *)alloc->Alloc(alloc, sizeof(CLzma2Enc));
-  if (!p)
-    return NULL;
-  Lzma2EncProps_Init(&p->props);
-  Lzma2EncProps_Normalize(&p->props);
-  p->outBuf = 0;
-  p->alloc = alloc;
-  p->allocBig = allocBig;
-  {
-    unsigned i;
-    for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
-      p->coders[i].enc = 0;
-  }
-
-  #ifndef _7ZIP_ST
-  MtCoder_Construct(&p->mtCoder);
-  #endif
-
-  return p;
-}
-
-void Lzma2Enc_Destroy(CLzma2EncHandle pp)
-{
-  CLzma2Enc *p = (CLzma2Enc *)pp;
-  unsigned i;
-  for (i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)
-  {
-    CLzma2EncInt *t = &p->coders[i];
-    if (t->enc)
-    {
-      LzmaEnc_Destroy(t->enc, p->alloc, p->allocBig);
-      t->enc = 0;
-    }
-  }
-
-  #ifndef _7ZIP_ST
-  MtCoder_Destruct(&p->mtCoder);
-  #endif
-
-  IAlloc_Free(p->alloc, p->outBuf);
-  IAlloc_Free(p->alloc, pp);
-}
-
-SRes Lzma2Enc_SetProps(CLzma2EncHandle pp, const CLzma2EncProps *props)
-{
-  CLzma2Enc *p = (CLzma2Enc *)pp;
-  CLzmaEncProps lzmaProps = props->lzmaProps;
-  LzmaEncProps_Normalize(&lzmaProps);
-  if (lzmaProps.lc + lzmaProps.lp > LZMA2_LCLP_MAX)
-    return SZ_ERROR_PARAM;
-  p->props = *props;
-  Lzma2EncProps_Normalize(&p->props);
-  return SZ_OK;
-}
-
-Byte Lzma2Enc_WriteProperties(CLzma2EncHandle pp)
-{
-  CLzma2Enc *p = (CLzma2Enc *)pp;
-  unsigned i;
-  UInt32 dicSize = LzmaEncProps_GetDictSize(&p->props.lzmaProps);
-  for (i = 0; i < 40; i++)
-    if (dicSize <= LZMA2_DIC_SIZE_FROM_PROP(i))
-      break;
-  return (Byte)i;
-}
-
-SRes Lzma2Enc_Encode(CLzma2EncHandle pp,
-    ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress)
-{
-  CLzma2Enc *p = (CLzma2Enc *)pp;
-  int i;
-
-  for (i = 0; i < p->props.numBlockThreads; i++)
-  {
-    CLzma2EncInt *t = &p->coders[(unsigned)i];
-    if (!t->enc)
-    {
-      t->enc = LzmaEnc_Create(p->alloc);
-      if (!t->enc)
-        return SZ_ERROR_MEM;
-    }
-  }
-
-  #ifndef _7ZIP_ST
-  if (p->props.numBlockThreads > 1)
-  {
-    CMtCallbackImp mtCallback;
-
-    mtCallback.funcTable.Code = MtCallbackImp_Code;
-    mtCallback.lzma2Enc = p;
-
-    p->mtCoder.progress = progress;
-    p->mtCoder.inStream = inStream;
-    p->mtCoder.outStream = outStream;
-    p->mtCoder.alloc = p->alloc;
-    p->mtCoder.mtCallback = &mtCallback.funcTable;
-
-    p->mtCoder.blockSize = p->props.blockSize;
-    p->mtCoder.destBlockSize = p->props.blockSize + (p->props.blockSize >> 10) + 16;
-    if (p->mtCoder.destBlockSize < p->props.blockSize)
-    {
-      p->mtCoder.destBlockSize = (size_t)0 - 1;
-      if (p->mtCoder.destBlockSize < p->props.blockSize)
-        return SZ_ERROR_FAIL;
-    }
-    p->mtCoder.numThreads = p->props.numBlockThreads;
-
-    return MtCoder_Code(&p->mtCoder);
-  }
-  #endif
-
-  return Lzma2Enc_EncodeMt1(&p->coders[0], p, outStream, inStream, progress);
-}
diff --git a/src/calibre_lzma/Lzma2Enc.h b/src/calibre_lzma/Lzma2Enc.h
deleted file mode 100644
index 061178aafd..0000000000
--- a/src/calibre_lzma/Lzma2Enc.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* Lzma2Enc.h -- LZMA2 Encoder
-2013-01-18 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA2_ENC_H
-#define __LZMA2_ENC_H
-
-#include "LzmaEnc.h"
-
-EXTERN_C_BEGIN
-
-typedef struct
-{
-  CLzmaEncProps lzmaProps;
-  size_t blockSize;
-  int numBlockThreads;
-  int numTotalThreads;
-} CLzma2EncProps;
-
-void Lzma2EncProps_Init(CLzma2EncProps *p);
-void Lzma2EncProps_Normalize(CLzma2EncProps *p);
-
-/* ---------- CLzmaEnc2Handle Interface ---------- */
-
-/* Lzma2Enc_* functions can return the following exit codes:
-Returns:
-  SZ_OK           - OK
-  SZ_ERROR_MEM    - Memory allocation error
-  SZ_ERROR_PARAM  - Incorrect paramater in props
-  SZ_ERROR_WRITE  - Write callback error
-  SZ_ERROR_PROGRESS - some break from progress callback
-  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-*/
-
-typedef void * CLzma2EncHandle;
-
-CLzma2EncHandle Lzma2Enc_Create(ISzAlloc *alloc, ISzAlloc *allocBig);
-void Lzma2Enc_Destroy(CLzma2EncHandle p);
-SRes Lzma2Enc_SetProps(CLzma2EncHandle p, const CLzma2EncProps *props);
-Byte Lzma2Enc_WriteProperties(CLzma2EncHandle p);
-SRes Lzma2Enc_Encode(CLzma2EncHandle p,
-    ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress);
-
-/* ---------- One Call Interface ---------- */
-
-/* Lzma2Encode
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-/*
-SRes Lzma2Encode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-*/
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/LzmaDec.c b/src/calibre_lzma/LzmaDec.c
deleted file mode 100644
index 5b8089256e..0000000000
--- a/src/calibre_lzma/LzmaDec.c
+++ /dev/null
@@ -1,1100 +0,0 @@
-/* LzmaDec.c -- LZMA Decoder
-2016-05-16 : Igor Pavlov : Public domain */
-
-#include "Precomp.h"
-
-#include "LzmaDec.h"
-
-#include <string.h>
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 << kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 << kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_INIT_SIZE 5
-
-#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }
-
-#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
-#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
-#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
-  { UPDATE_0(p); i = (i + i); A0; } else \
-  { UPDATE_1(p); i = (i + i) + 1; A1; }
-#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)
-
-#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
-#define TREE_DECODE(probs, limit, i) \
-  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }
-
-/* #define _LZMA_SIZE_OPT */
-
-#ifdef _LZMA_SIZE_OPT
-#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
-#else
-#define TREE_6_DECODE(probs, i) \
-  { i = 1; \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  TREE_GET_BIT(probs, i); \
-  i -= 0x40; }
-#endif
-
-#define NORMAL_LITER_DEC GET_BIT(prob + symbol, symbol)
-#define MATCHED_LITER_DEC \
-  matchByte <<= 1; \
-  bit = (matchByte & offs); \
-  probLit = prob + offs + bit + symbol; \
-  GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
-
-#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }
-
-#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
-#define UPDATE_0_CHECK range = bound;
-#define UPDATE_1_CHECK range -= bound; code -= bound;
-#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
-  { UPDATE_0_CHECK; i = (i + i); A0; } else \
-  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
-#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
-#define TREE_DECODE_CHECK(probs, limit, i) \
-  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }
-
-
-#define kNumPosBitsMax 4
-#define kNumPosStatesMax (1 << kNumPosBitsMax)
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 << kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 << kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 << kLenNumHighBits)
-
-#define LenChoice 0
-#define LenChoice2 (LenChoice + 1)
-#define LenLow (LenChoice2 + 1)
-#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
-#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
-#define kNumLenProbs (LenHigh + kLenNumHighSymbols)
-
-
-#define kNumStates 12
-#define kNumLitStates 7
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-
-#define kNumPosSlotBits 6
-#define kNumLenToPosStates 4
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 << kNumAlignBits)
-
-#define kMatchMinLen 2
-#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define IsMatch 0
-#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
-#define IsRepG0 (IsRep + kNumStates)
-#define IsRepG1 (IsRepG0 + kNumStates)
-#define IsRepG2 (IsRepG1 + kNumStates)
-#define IsRep0Long (IsRepG2 + kNumStates)
-#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
-#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
-#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-#define LenCoder (Align + kAlignTableSize)
-#define RepLenCoder (LenCoder + kNumLenProbs)
-#define Literal (RepLenCoder + kNumLenProbs)
-
-#define LZMA_BASE_SIZE 1846
-#define LZMA_LIT_SIZE 0x300
-
-#if Literal != LZMA_BASE_SIZE
-StopCompilingDueBUG
-#endif
-
-#define LzmaProps_GetNumProbs(p) (Literal + ((UInt32)LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))
-
-#define LZMA_DIC_MIN (1 << 12)
-
-/* First LZMA-symbol is always decoded.
-And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
-Out:
-  Result:
-    SZ_OK - OK
-    SZ_ERROR_DATA - Error
-  p->remainLen:
-    < kMatchSpecLenStart : normal remain
-    = kMatchSpecLenStart : finished
-    = kMatchSpecLenStart + 1 : Flush marker (unused now)
-    = kMatchSpecLenStart + 2 : State Init Marker (unused now)
-*/
-
-static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  CLzmaProb *probs = p->probs;
-
-  unsigned state = p->state;
-  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
-  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
-  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
-  unsigned lc = p->prop.lc;
-
-  Byte *dic = p->dic;
-  SizeT dicBufSize = p->dicBufSize;
-  SizeT dicPos = p->dicPos;
-
-  UInt32 processedPos = p->processedPos;
-  UInt32 checkDicSize = p->checkDicSize;
-  unsigned len = 0;
-
-  const Byte *buf = p->buf;
-  UInt32 range = p->range;
-  UInt32 code = p->code;
-
-  do
-  {
-    CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = processedPos & pbMask;
-
-    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-    IF_BIT_0(prob)
-    {
-      unsigned symbol;
-      UPDATE_0(prob);
-      prob = probs + Literal;
-      if (processedPos != 0 || checkDicSize != 0)
-        prob += ((UInt32)LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
-            (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));
-      processedPos++;
-
-      if (state < kNumLitStates)
-      {
-        state -= (state < 4) ? state : 3;
-        symbol = 1;
-        #ifdef _LZMA_SIZE_OPT
-        do { NORMAL_LITER_DEC } while (symbol < 0x100);
-        #else
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        NORMAL_LITER_DEC
-        #endif
-      }
-      else
-      {
-        unsigned matchByte = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
-        unsigned offs = 0x100;
-        state -= (state < 10) ? 3 : 6;
-        symbol = 1;
-        #ifdef _LZMA_SIZE_OPT
-        do
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          MATCHED_LITER_DEC
-        }
-        while (symbol < 0x100);
-        #else
-        {
-          unsigned bit;
-          CLzmaProb *probLit;
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-          MATCHED_LITER_DEC
-        }
-        #endif
-      }
-
-      dic[dicPos++] = (Byte)symbol;
-      continue;
-    }
-
-    {
-      UPDATE_1(prob);
-      prob = probs + IsRep + state;
-      IF_BIT_0(prob)
-      {
-        UPDATE_0(prob);
-        state += kNumStates;
-        prob = probs + LenCoder;
-      }
-      else
-      {
-        UPDATE_1(prob);
-        if (checkDicSize == 0 && processedPos == 0)
-          return SZ_ERROR_DATA;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0(prob)
-        {
-          UPDATE_0(prob);
-          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
-            dicPos++;
-            processedPos++;
-            state = state < kNumLitStates ? 9 : 11;
-            continue;
-          }
-          UPDATE_1(prob);
-        }
-        else
-        {
-          UInt32 distance;
-          UPDATE_1(prob);
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0(prob)
-          {
-            UPDATE_0(prob);
-            distance = rep1;
-          }
-          else
-          {
-            UPDATE_1(prob);
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0(prob)
-            {
-              UPDATE_0(prob);
-              distance = rep2;
-            }
-            else
-            {
-              UPDATE_1(prob);
-              distance = rep3;
-              rep3 = rep2;
-            }
-            rep2 = rep1;
-          }
-          rep1 = rep0;
-          rep0 = distance;
-        }
-        state = state < kNumLitStates ? 8 : 11;
-        prob = probs + RepLenCoder;
-      }
-
-      #ifdef _LZMA_SIZE_OPT
-      {
-        unsigned lim, offset;
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0(probLen)
-        {
-          UPDATE_0(probLen);
-          probLen = prob + LenLow + (posState << kLenNumLowBits);
-          offset = 0;
-          lim = (1 << kLenNumLowBits);
-        }
-        else
-        {
-          UPDATE_1(probLen);
-          probLen = prob + LenChoice2;
-          IF_BIT_0(probLen)
-          {
-            UPDATE_0(probLen);
-            probLen = prob + LenMid + (posState << kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            lim = (1 << kLenNumMidBits);
-          }
-          else
-          {
-            UPDATE_1(probLen);
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            lim = (1 << kLenNumHighBits);
-          }
-        }
-        TREE_DECODE(probLen, lim, len);
-        len += offset;
-      }
-      #else
-      {
-        CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0(probLen)
-        {
-          UPDATE_0(probLen);
-          probLen = prob + LenLow + (posState << kLenNumLowBits);
-          len = 1;
-          TREE_GET_BIT(probLen, len);
-          TREE_GET_BIT(probLen, len);
-          TREE_GET_BIT(probLen, len);
-          len -= 8;
-        }
-        else
-        {
-          UPDATE_1(probLen);
-          probLen = prob + LenChoice2;
-          IF_BIT_0(probLen)
-          {
-            UPDATE_0(probLen);
-            probLen = prob + LenMid + (posState << kLenNumMidBits);
-            len = 1;
-            TREE_GET_BIT(probLen, len);
-            TREE_GET_BIT(probLen, len);
-            TREE_GET_BIT(probLen, len);
-          }
-          else
-          {
-            UPDATE_1(probLen);
-            probLen = prob + LenHigh;
-            TREE_DECODE(probLen, (1 << kLenNumHighBits), len);
-            len += kLenNumLowSymbols + kLenNumMidSymbols;
-          }
-        }
-      }
-      #endif
-
-      if (state >= kNumStates)
-      {
-        UInt32 distance;
-        prob = probs + PosSlot +
-            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
-        TREE_6_DECODE(prob, distance);
-        if (distance >= kStartPosModelIndex)
-        {
-          unsigned posSlot = (unsigned)distance;
-          unsigned numDirectBits = (unsigned)(((distance >> 1) - 1));
-          distance = (2 | (distance & 1));
-          if (posSlot < kEndPosModelIndex)
-          {
-            distance <<= numDirectBits;
-            prob = probs + SpecPos + distance - posSlot - 1;
-            {
-              UInt32 mask = 1;
-              unsigned i = 1;
-              do
-              {
-                GET_BIT2(prob + i, i, ; , distance |= mask);
-                mask <<= 1;
-              }
-              while (--numDirectBits != 0);
-            }
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE
-              range >>= 1;
-
-              {
-                UInt32 t;
-                code -= range;
-                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
-                distance = (distance << 1) + (t + 1);
-                code += range & t;
-              }
-              /*
-              distance <<= 1;
-              if (code >= range)
-              {
-                code -= range;
-                distance |= 1;
-              }
-              */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            distance <<= kNumAlignBits;
-            {
-              unsigned i = 1;
-              GET_BIT2(prob + i, i, ; , distance |= 1);
-              GET_BIT2(prob + i, i, ; , distance |= 2);
-              GET_BIT2(prob + i, i, ; , distance |= 4);
-              GET_BIT2(prob + i, i, ; , distance |= 8);
-            }
-            if (distance == (UInt32)0xFFFFFFFF)
-            {
-              len += kMatchSpecLenStart;
-              state -= kNumStates;
-              break;
-            }
-          }
-        }
-
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
-        rep0 = distance + 1;
-        if (checkDicSize == 0)
-        {
-          if (distance >= processedPos)
-          {
-            p->dicPos = dicPos;
-            return SZ_ERROR_DATA;
-          }
-        }
-        else if (distance >= checkDicSize)
-        {
-          p->dicPos = dicPos;
-          return SZ_ERROR_DATA;
-        }
-        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
-      }
-
-      len += kMatchMinLen;
-
-      {
-        SizeT rem;
-        unsigned curLen;
-        SizeT pos;
-
-        if ((rem = limit - dicPos) == 0)
-        {
-          p->dicPos = dicPos;
-          return SZ_ERROR_DATA;
-        }
-
-        curLen = ((rem < len) ? (unsigned)rem : len);
-        pos = dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0);
-
-        processedPos += curLen;
-
-        len -= curLen;
-        if (curLen <= dicBufSize - pos)
-        {
-          Byte *dest = dic + dicPos;
-          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
-          const Byte *lim = dest + curLen;
-          dicPos += curLen;
-          do
-            *(dest) = (Byte)*(dest + src);
-          while (++dest != lim);
-        }
-        else
-        {
-          do
-          {
-            dic[dicPos++] = dic[pos];
-            if (++pos == dicBufSize)
-              pos = 0;
-          }
-          while (--curLen != 0);
-        }
-      }
-    }
-  }
-  while (dicPos < limit && buf < bufLimit);
-
-  NORMALIZE;
-
-  p->buf = buf;
-  p->range = range;
-  p->code = code;
-  p->remainLen = len;
-  p->dicPos = dicPos;
-  p->processedPos = processedPos;
-  p->reps[0] = rep0;
-  p->reps[1] = rep1;
-  p->reps[2] = rep2;
-  p->reps[3] = rep3;
-  p->state = state;
-
-  return SZ_OK;
-}
-
-static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
-{
-  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
-  {
-    Byte *dic = p->dic;
-    SizeT dicPos = p->dicPos;
-    SizeT dicBufSize = p->dicBufSize;
-    unsigned len = p->remainLen;
-    SizeT rep0 = p->reps[0]; /* we use SizeT to avoid the BUG of VC14 for AMD64 */
-    SizeT rem = limit - dicPos;
-    if (rem < len)
-      len = (unsigned)(rem);
-
-    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
-      p->checkDicSize = p->prop.dicSize;
-
-    p->processedPos += len;
-    p->remainLen -= len;
-    while (len != 0)
-    {
-      len--;
-      dic[dicPos] = dic[dicPos - rep0 + (dicPos < rep0 ? dicBufSize : 0)];
-      dicPos++;
-    }
-    p->dicPos = dicPos;
-  }
-}
-
-static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
-{
-  do
-  {
-    SizeT limit2 = limit;
-    if (p->checkDicSize == 0)
-    {
-      UInt32 rem = p->prop.dicSize - p->processedPos;
-      if (limit - p->dicPos > rem)
-        limit2 = p->dicPos + rem;
-    }
-
-    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
-
-    if (p->checkDicSize == 0 && p->processedPos >= p->prop.dicSize)
-      p->checkDicSize = p->prop.dicSize;
-
-    LzmaDec_WriteRem(p, limit);
-  }
-  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);
-
-  if (p->remainLen > kMatchSpecLenStart)
-    p->remainLen = kMatchSpecLenStart;
-
-  return 0;
-}
-
-typedef enum
-{
-  DUMMY_ERROR, /* unexpected end of input stream */
-  DUMMY_LIT,
-  DUMMY_MATCH,
-  DUMMY_REP
-} ELzmaDummy;
-
-static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
-{
-  UInt32 range = p->range;
-  UInt32 code = p->code;
-  const Byte *bufLimit = buf + inSize;
-  const CLzmaProb *probs = p->probs;
-  unsigned state = p->state;
-  ELzmaDummy res;
-
-  {
-    const CLzmaProb *prob;
-    UInt32 bound;
-    unsigned ttt;
-    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);
-
-    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
-    IF_BIT_0_CHECK(prob)
-    {
-      UPDATE_0_CHECK
-
-      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */
-
-      prob = probs + Literal;
-      if (p->checkDicSize != 0 || p->processedPos != 0)
-        prob += ((UInt32)LZMA_LIT_SIZE *
-            ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
-            (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));
-
-      if (state < kNumLitStates)
-      {
-        unsigned symbol = 1;
-        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
-      }
-      else
-      {
-        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
-            (p->dicPos < p->reps[0] ? p->dicBufSize : 0)];
-        unsigned offs = 0x100;
-        unsigned symbol = 1;
-        do
-        {
-          unsigned bit;
-          const CLzmaProb *probLit;
-          matchByte <<= 1;
-          bit = (matchByte & offs);
-          probLit = prob + offs + bit + symbol;
-          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
-        }
-        while (symbol < 0x100);
-      }
-      res = DUMMY_LIT;
-    }
-    else
-    {
-      unsigned len;
-      UPDATE_1_CHECK;
-
-      prob = probs + IsRep + state;
-      IF_BIT_0_CHECK(prob)
-      {
-        UPDATE_0_CHECK;
-        state = 0;
-        prob = probs + LenCoder;
-        res = DUMMY_MATCH;
-      }
-      else
-      {
-        UPDATE_1_CHECK;
-        res = DUMMY_REP;
-        prob = probs + IsRepG0 + state;
-        IF_BIT_0_CHECK(prob)
-        {
-          UPDATE_0_CHECK;
-          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-            NORMALIZE_CHECK;
-            return DUMMY_REP;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-          }
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          prob = probs + IsRepG1 + state;
-          IF_BIT_0_CHECK(prob)
-          {
-            UPDATE_0_CHECK;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            prob = probs + IsRepG2 + state;
-            IF_BIT_0_CHECK(prob)
-            {
-              UPDATE_0_CHECK;
-            }
-            else
-            {
-              UPDATE_1_CHECK;
-            }
-          }
-        }
-        state = kNumStates;
-        prob = probs + RepLenCoder;
-      }
-      {
-        unsigned limit, offset;
-        const CLzmaProb *probLen = prob + LenChoice;
-        IF_BIT_0_CHECK(probLen)
-        {
-          UPDATE_0_CHECK;
-          probLen = prob + LenLow + (posState << kLenNumLowBits);
-          offset = 0;
-          limit = 1 << kLenNumLowBits;
-        }
-        else
-        {
-          UPDATE_1_CHECK;
-          probLen = prob + LenChoice2;
-          IF_BIT_0_CHECK(probLen)
-          {
-            UPDATE_0_CHECK;
-            probLen = prob + LenMid + (posState << kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            limit = 1 << kLenNumMidBits;
-          }
-          else
-          {
-            UPDATE_1_CHECK;
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            limit = 1 << kLenNumHighBits;
-          }
-        }
-        TREE_DECODE_CHECK(probLen, limit, len);
-        len += offset;
-      }
-
-      if (state < 4)
-      {
-        unsigned posSlot;
-        prob = probs + PosSlot +
-            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
-            kNumPosSlotBits);
-        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
-        if (posSlot >= kStartPosModelIndex)
-        {
-          unsigned numDirectBits = ((posSlot >> 1) - 1);
-
-          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */
-
-          if (posSlot < kEndPosModelIndex)
-          {
-            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              NORMALIZE_CHECK
-              range >>= 1;
-              code -= range & (((code - range) >> 31) - 1);
-              /* if (code >= range) code -= range; */
-            }
-            while (--numDirectBits != 0);
-            prob = probs + Align;
-            numDirectBits = kNumAlignBits;
-          }
-          {
-            unsigned i = 1;
-            do
-            {
-              GET_BIT_CHECK(prob + i, i);
-            }
-            while (--numDirectBits != 0);
-          }
-        }
-      }
-    }
-  }
-  NORMALIZE_CHECK;
-  return res;
-}
-
-
-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
-{
-  p->needFlush = 1;
-  p->remainLen = 0;
-  p->tempBufSize = 0;
-
-  if (initDic)
-  {
-    p->processedPos = 0;
-    p->checkDicSize = 0;
-    p->needInitState = 1;
-  }
-  if (initState)
-    p->needInitState = 1;
-}
-
-void LzmaDec_Init(CLzmaDec *p)
-{
-  p->dicPos = 0;
-  LzmaDec_InitDicAndState(p, True, True);
-}
-
-static void LzmaDec_InitStateReal(CLzmaDec *p)
-{
-  SizeT numProbs = LzmaProps_GetNumProbs(&p->prop);
-  SizeT i;
-  CLzmaProb *probs = p->probs;
-  for (i = 0; i < numProbs; i++)
-    probs[i] = kBitModelTotal >> 1;
-  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
-  p->state = 0;
-  p->needInitState = 0;
-}
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
-    ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT inSize = *srcLen;
-  (*srcLen) = 0;
-  LzmaDec_WriteRem(p, dicLimit);
-
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-
-  while (p->remainLen != kMatchSpecLenStart)
-  {
-      int checkEndMarkNow;
-
-      if (p->needFlush)
-      {
-        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
-          p->tempBuf[p->tempBufSize++] = *src++;
-        if (p->tempBufSize < RC_INIT_SIZE)
-        {
-          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-          return SZ_OK;
-        }
-        if (p->tempBuf[0] != 0)
-          return SZ_ERROR_DATA;
-        p->code =
-              ((UInt32)p->tempBuf[1] << 24)
-            | ((UInt32)p->tempBuf[2] << 16)
-            | ((UInt32)p->tempBuf[3] << 8)
-            | ((UInt32)p->tempBuf[4]);
-        p->range = 0xFFFFFFFF;
-        p->needFlush = 0;
-        p->tempBufSize = 0;
-      }
-
-      checkEndMarkNow = 0;
-      if (p->dicPos >= dicLimit)
-      {
-        if (p->remainLen == 0 && p->code == 0)
-        {
-          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
-          return SZ_OK;
-        }
-        if (finishMode == LZMA_FINISH_ANY)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_OK;
-        }
-        if (p->remainLen != 0)
-        {
-          *status = LZMA_STATUS_NOT_FINISHED;
-          return SZ_ERROR_DATA;
-        }
-        checkEndMarkNow = 1;
-      }
-
-      if (p->needInitState)
-        LzmaDec_InitStateReal(p);
-
-      if (p->tempBufSize == 0)
-      {
-        SizeT processed;
-        const Byte *bufLimit;
-        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            memcpy(p->tempBuf, src, inSize);
-            p->tempBufSize = (unsigned)inSize;
-            (*srcLen) += inSize;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-          bufLimit = src;
-        }
-        else
-          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
-        p->buf = src;
-        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
-          return SZ_ERROR_DATA;
-        processed = (SizeT)(p->buf - src);
-        (*srcLen) += processed;
-        src += processed;
-        inSize -= processed;
-      }
-      else
-      {
-        unsigned rem = p->tempBufSize, lookAhead = 0;
-        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
-          p->tempBuf[rem++] = src[lookAhead++];
-        p->tempBufSize = rem;
-        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
-        {
-          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
-          if (dummyRes == DUMMY_ERROR)
-          {
-            (*srcLen) += lookAhead;
-            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
-            return SZ_OK;
-          }
-          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
-          {
-            *status = LZMA_STATUS_NOT_FINISHED;
-            return SZ_ERROR_DATA;
-          }
-        }
-        p->buf = p->tempBuf;
-        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
-          return SZ_ERROR_DATA;
-
-        {
-          unsigned kkk = (unsigned)(p->buf - p->tempBuf);
-          if (rem < kkk)
-            return SZ_ERROR_FAIL; /* some internal error */
-          rem -= kkk;
-          if (lookAhead < rem)
-            return SZ_ERROR_FAIL; /* some internal error */
-          lookAhead -= rem;
-        }
-        (*srcLen) += lookAhead;
-        src += lookAhead;
-        inSize -= lookAhead;
-        p->tempBufSize = 0;
-      }
-  }
-  if (p->code == 0)
-    *status = LZMA_STATUS_FINISHED_WITH_MARK;
-  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
-}
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
-{
-  SizeT outSize = *destLen;
-  SizeT inSize = *srcLen;
-  *srcLen = *destLen = 0;
-  for (;;)
-  {
-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
-    ELzmaFinishMode curFinishMode;
-    SRes res;
-    if (p->dicPos == p->dicBufSize)
-      p->dicPos = 0;
-    dicPos = p->dicPos;
-    if (outSize > p->dicBufSize - dicPos)
-    {
-      outSizeCur = p->dicBufSize;
-      curFinishMode = LZMA_FINISH_ANY;
-    }
-    else
-    {
-      outSizeCur = dicPos + outSize;
-      curFinishMode = finishMode;
-    }
-
-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
-    src += inSizeCur;
-    inSize -= inSizeCur;
-    *srcLen += inSizeCur;
-    outSizeCur = p->dicPos - dicPos;
-    memcpy(dest, p->dic + dicPos, outSizeCur);
-    dest += outSizeCur;
-    outSize -= outSizeCur;
-    *destLen += outSizeCur;
-    if (res != 0)
-      return res;
-    if (outSizeCur == 0 || outSize == 0)
-      return SZ_OK;
-  }
-}
-
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc->Free(alloc, p->probs);
-  p->probs = NULL;
-}
-
-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
-{
-  alloc->Free(alloc, p->dic);
-  p->dic = NULL;
-}
-
-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
-{
-  LzmaDec_FreeProbs(p, alloc);
-  LzmaDec_FreeDict(p, alloc);
-}
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
-{
-  UInt32 dicSize;
-  Byte d;
-
-  if (size < LZMA_PROPS_SIZE)
-    return SZ_ERROR_UNSUPPORTED;
-  else
-    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
-
-  if (dicSize < LZMA_DIC_MIN)
-    dicSize = LZMA_DIC_MIN;
-  p->dicSize = dicSize;
-
-  d = data[0];
-  if (d >= (9 * 5 * 5))
-    return SZ_ERROR_UNSUPPORTED;
-
-  p->lc = d % 9;
-  d /= 9;
-  p->pb = d / 5;
-  p->lp = d % 5;
-
-  return SZ_OK;
-}
-
-static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
-{
-  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
-  if (!p->probs || numProbs != p->numProbs)
-  {
-    LzmaDec_FreeProbs(p, alloc);
-    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
-    p->numProbs = numProbs;
-    if (!p->probs)
-      return SZ_ERROR_MEM;
-  }
-  return SZ_OK;
-}
-
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-  p->prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
-{
-  CLzmaProps propNew;
-  SizeT dicBufSize;
-  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
-  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
-
-  {
-    UInt32 dictSize = propNew.dicSize;
-    SizeT mask = ((UInt32)1 << 12) - 1;
-         if (dictSize >= ((UInt32)1 << 30)) mask = ((UInt32)1 << 22) - 1;
-    else if (dictSize >= ((UInt32)1 << 22)) mask = ((UInt32)1 << 20) - 1;;
-    dicBufSize = ((SizeT)dictSize + mask) & ~mask;
-    if (dicBufSize < dictSize)
-      dicBufSize = dictSize;
-  }
-
-  if (!p->dic || dicBufSize != p->dicBufSize)
-  {
-    LzmaDec_FreeDict(p, alloc);
-    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
-    if (!p->dic)
-    {
-      LzmaDec_FreeProbs(p, alloc);
-      return SZ_ERROR_MEM;
-    }
-  }
-  p->dicBufSize = dicBufSize;
-  p->prop = propNew;
-  return SZ_OK;
-}
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc)
-{
-  CLzmaDec p;
-  SRes res;
-  SizeT outSize = *destLen, inSize = *srcLen;
-  *destLen = *srcLen = 0;
-  *status = LZMA_STATUS_NOT_SPECIFIED;
-  if (inSize < RC_INIT_SIZE)
-    return SZ_ERROR_INPUT_EOF;
-  LzmaDec_Construct(&p);
-  RINOK(LzmaDec_AllocateProbs(&p, propData, propSize, alloc));
-  p.dic = dest;
-  p.dicBufSize = outSize;
-  LzmaDec_Init(&p);
-  *srcLen = inSize;
-  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);
-  *destLen = p.dicPos;
-  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
-    res = SZ_ERROR_INPUT_EOF;
-  LzmaDec_FreeProbs(&p, alloc);
-  return res;
-}
diff --git a/src/calibre_lzma/LzmaDec.h b/src/calibre_lzma/LzmaDec.h
deleted file mode 100644
index 2633abeac9..0000000000
--- a/src/calibre_lzma/LzmaDec.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/* LzmaDec.h -- LZMA Decoder
-2013-01-18 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA_DEC_H
-#define __LZMA_DEC_H
-
-#include "7zTypes.h"
-
-EXTERN_C_BEGIN
-
-/* #define _LZMA_PROB32 */
-/* _LZMA_PROB32 can increase the speed on some CPUs,
-   but memory usage for CLzmaDec::probs will be doubled in that case */
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-
-/* ---------- LZMA Properties ---------- */
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaProps
-{
-  unsigned lc, lp, pb;
-  UInt32 dicSize;
-} CLzmaProps;
-
-/* LzmaProps_Decode - decodes properties
-Returns:
-  SZ_OK
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-
-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
-
-
-/* ---------- LZMA Decoder state ---------- */
-
-/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
-   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */
-
-#define LZMA_REQUIRED_INPUT_MAX 20
-
-typedef struct
-{
-  CLzmaProps prop;
-  CLzmaProb *probs;
-  Byte *dic;
-  const Byte *buf;
-  UInt32 range, code;
-  SizeT dicPos;
-  SizeT dicBufSize;
-  UInt32 processedPos;
-  UInt32 checkDicSize;
-  unsigned state;
-  UInt32 reps[4];
-  unsigned remainLen;
-  int needFlush;
-  int needInitState;
-  UInt32 numProbs;
-  unsigned tempBufSize;
-  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
-} CLzmaDec;
-
-#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
-
-void LzmaDec_Init(CLzmaDec *p);
-
-/* There are two types of LZMA streams:
-     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
-     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
-
-typedef enum
-{
-  LZMA_FINISH_ANY,   /* finish at any point */
-  LZMA_FINISH_END    /* block must be finished at the end */
-} ELzmaFinishMode;
-
-/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!
-
-   You must use LZMA_FINISH_END, when you know that current output buffer
-   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.
-
-   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
-   and output value of destLen will be less than output buffer size limit.
-   You can check status result also.
-
-   You can use multiple checks to test data integrity after full decompression:
-     1) Check Result and "status" variable.
-     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
-     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
-        You must use correct finish mode in that case. */
-
-typedef enum
-{
-  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
-  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
-  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
-  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
-  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
-} ELzmaStatus;
-
-/* ELzmaStatus is used only as output value for function call */
-
-
-/* ---------- Interfaces ---------- */
-
-/* There are 3 levels of interfaces:
-     1) Dictionary Interface
-     2) Buffer Interface
-     3) One Call Interface
-   You can select any of these interfaces, but don't mix functions from different
-   groups for same object. */
-
-
-/* There are two variants to allocate state for Dictionary Interface:
-     1) LzmaDec_Allocate / LzmaDec_Free
-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
-   You can use variant 2, if you set dictionary buffer manually.
-   For Buffer Interface you must always use variant 1.
-
-LzmaDec_Allocate* can return:
-  SZ_OK
-  SZ_ERROR_MEM         - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-*/
-   
-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
-
-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
-
-/* ---------- Dictionary Interface ---------- */
-
-/* You can use it, if you want to eliminate the overhead for data copying from
-   dictionary to some other external buffer.
-   You must work with CLzmaDec variables directly in this interface.
-
-   STEPS:
-     LzmaDec_Constr()
-     LzmaDec_Allocate()
-     for (each new stream)
-     {
-       LzmaDec_Init()
-       while (it needs more decompression)
-       {
-         LzmaDec_DecodeToDic()
-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
-       }
-     }
-     LzmaDec_Free()
-*/
-
-/* LzmaDec_DecodeToDic
-   
-   The decoding to internal dictionary buffer (CLzmaDec::dic).
-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (dicLimit).
-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
-  LZMA_FINISH_END - Stream must be finished after dicLimit.
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_NEEDS_MORE_INPUT
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-*/
-
-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- Buffer Interface ---------- */
-
-/* It's zlib-like interface.
-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
-   to work with CLzmaDec variables manually.
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-*/
-
-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
-
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaDecode
-
-finishMode:
-  It has meaning only if the decoding reaches output limit (*destLen).
-  LZMA_FINISH_ANY - Decode just destLen bytes.
-  LZMA_FINISH_END - Stream must be finished after (*destLen).
-
-Returns:
-  SZ_OK
-    status:
-      LZMA_STATUS_FINISHED_WITH_MARK
-      LZMA_STATUS_NOT_FINISHED
-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
-  SZ_ERROR_DATA - Data error
-  SZ_ERROR_MEM  - Memory allocation error
-  SZ_ERROR_UNSUPPORTED - Unsupported properties
-  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
-*/
-
-SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
-    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
-    ELzmaStatus *status, ISzAlloc *alloc);
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/LzmaEnc.c b/src/calibre_lzma/LzmaEnc.c
deleted file mode 100644
index f4eb6a5e67..0000000000
--- a/src/calibre_lzma/LzmaEnc.c
+++ /dev/null
@@ -1,2351 +0,0 @@
-/* LzmaEnc.c -- LZMA Encoder
-2016-05-16 : Igor Pavlov : Public domain */
-
-#include "Precomp.h"
-
-#include <string.h>
-
-/* #define SHOW_STAT */
-/* #define SHOW_STAT2 */
-
-#if defined(SHOW_STAT) || defined(SHOW_STAT2)
-#include <stdio.h>
-#endif
-
-#include "LzmaEnc.h"
-
-#include "LzFind.h"
-#ifndef _7ZIP_ST
-#include "LzFindMt.h"
-#endif
-
-#ifdef SHOW_STAT
-static unsigned g_STAT_OFFSET = 0;
-#endif
-
-#define kMaxHistorySize ((UInt32)3 << 29)
-/* #define kMaxHistorySize ((UInt32)7 << 29) */
-
-#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)
-
-#define kBlockSize (9 << 10)
-#define kUnpackBlockSize (1 << 18)
-#define kMatchArraySize (1 << 21)
-#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)
-
-#define kNumMaxDirectBits (31)
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 << kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 << kNumBitModelTotalBits)
-#define kNumMoveBits 5
-#define kProbInitValue (kBitModelTotal >> 1)
-
-#define kNumMoveReducingBits 4
-#define kNumBitPriceShiftBits 4
-#define kBitPrice (1 << kNumBitPriceShiftBits)
-
-void LzmaEncProps_Init(CLzmaEncProps *p)
-{
-  p->level = 5;
-  p->dictSize = p->mc = 0;
-  p->reduceSize = (UInt64)(Int64)-1;
-  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
-  p->writeEndMark = 0;
-}
-
-void LzmaEncProps_Normalize(CLzmaEncProps *p)
-{
-  int level = p->level;
-  if (level < 0) level = 5;
-  p->level = level;
-
-  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
-  if (p->dictSize > p->reduceSize)
-  {
-    unsigned i;
-    for (i = 11; i <= 30; i++)
-    {
-      if ((UInt32)p->reduceSize <= ((UInt32)2 << i)) { p->dictSize = ((UInt32)2 << i); break; }
-      if ((UInt32)p->reduceSize <= ((UInt32)3 << i)) { p->dictSize = ((UInt32)3 << i); break; }
-    }
-  }
-
-  if (p->lc < 0) p->lc = 3;
-  if (p->lp < 0) p->lp = 0;
-  if (p->pb < 0) p->pb = 2;
-
-  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
-  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
-  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
-  if (p->numHashBytes < 0) p->numHashBytes = 4;
-  if (p->mc == 0) p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
-
-  if (p->numThreads < 0)
-    p->numThreads =
-      #ifndef _7ZIP_ST
-      ((p->btMode && p->algo) ? 2 : 1);
-      #else
-      1;
-      #endif
-}
-
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
-{
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&props);
-  return props.dictSize;
-}
-
-#if (_MSC_VER >= 1400)
-/* BSR code is fast for some new CPUs */
-/* #define LZMA_LOG_BSR */
-#endif
-
-#ifdef LZMA_LOG_BSR
-
-#define kDicLogSizeMaxCompress 32
-
-#define BSR2_RET(pos, res) { unsigned long zz; _BitScanReverse(&zz, (pos)); res = (zz + zz) + ((pos >> (zz - 1)) & 1); }
-
-static UInt32 GetPosSlot1(UInt32 pos)
-{
-  UInt32 res;
-  BSR2_RET(pos, res);
-  return res;
-}
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }
-
-#else
-
-#define kNumLogBits (9 + sizeof(size_t) / 2)
-/* #define kNumLogBits (11 + sizeof(size_t) / 8 * 3) */
-
-#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
-
-static void LzmaEnc_FastPosInit(Byte *g_FastPos)
-{
-  unsigned slot;
-  g_FastPos[0] = 0;
-  g_FastPos[1] = 1;
-  g_FastPos += 2;
-
-  for (slot = 2; slot < kNumLogBits * 2; slot++)
-  {
-    size_t k = ((size_t)1 << ((slot >> 1) - 1));
-    size_t j;
-    for (j = 0; j < k; j++)
-      g_FastPos[j] = (Byte)slot;
-    g_FastPos += k;
-  }
-}
-
-/* we can use ((limit - pos) >> 31) only if (pos < ((UInt32)1 << 31)) */
-/*
-#define BSR2_RET(pos, res) { UInt32 zz = 6 + ((kNumLogBits - 1) & \
-  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
-  res = p->g_FastPos[pos >> zz] + (zz * 2); }
-*/
-
-/*
-#define BSR2_RET(pos, res) { UInt32 zz = 6 + ((kNumLogBits - 1) & \
-  (0 - (((((UInt32)1 << (kNumLogBits)) - 1) - (pos >> 6)) >> 31))); \
-  res = p->g_FastPos[pos >> zz] + (zz * 2); }
-*/
-
-#define BSR2_RET(pos, res) { UInt32 zz = (pos < (1 << (kNumLogBits + 6))) ? 6 : 6 + kNumLogBits - 1; \
-  res = p->g_FastPos[pos >> zz] + (zz * 2); }
-
-/*
-#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
-  p->g_FastPos[pos >> 6] + 12 : \
-  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
-*/
-
-#define GetPosSlot1(pos) p->g_FastPos[pos]
-#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
-#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }
-
-#endif
-
-
-#define LZMA_NUM_REPS 4
-
-typedef unsigned CState;
-
-typedef struct
-{
-  UInt32 price;
-
-  CState state;
-  int prev1IsChar;
-  int prev2;
-
-  UInt32 posPrev2;
-  UInt32 backPrev2;
-
-  UInt32 posPrev;
-  UInt32 backPrev;
-  UInt32 backs[LZMA_NUM_REPS];
-} COptimal;
-
-#define kNumOpts (1 << 12)
-
-#define kNumLenToPosStates 4
-#define kNumPosSlotBits 6
-#define kDicLogSizeMin 0
-#define kDicLogSizeMax 32
-#define kDistTableSizeMax (kDicLogSizeMax * 2)
-
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 << kNumAlignBits)
-#define kAlignMask (kAlignTableSize - 1)
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)
-
-#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-
-#ifdef _LZMA_PROB32
-#define CLzmaProb UInt32
-#else
-#define CLzmaProb UInt16
-#endif
-
-#define LZMA_PB_MAX 4
-#define LZMA_LC_MAX 8
-#define LZMA_LP_MAX 4
-
-#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)
-
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 << kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 << kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 << kLenNumHighBits)
-
-#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)
-
-#define LZMA_MATCH_LEN_MIN 2
-#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)
-
-#define kNumStates 12
-
-
-typedef struct
-{
-  CLzmaProb choice;
-  CLzmaProb choice2;
-  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
-  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
-  CLzmaProb high[kLenNumHighSymbols];
-} CLenEnc;
-
-
-typedef struct
-{
-  CLenEnc p;
-  UInt32 tableSize;
-  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
-  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
-} CLenPriceEnc;
-
-
-typedef struct
-{
-  UInt32 range;
-  Byte cache;
-  UInt64 low;
-  UInt64 cacheSize;
-  Byte *buf;
-  Byte *bufLim;
-  Byte *bufBase;
-  ISeqOutStream *outStream;
-  UInt64 processed;
-  SRes res;
-} CRangeEnc;
-
-
-typedef struct
-{
-  CLzmaProb *litProbs;
-
-  UInt32 state;
-  UInt32 reps[LZMA_NUM_REPS];
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-} CSaveState;
-
-
-typedef struct
-{
-  void *matchFinderObj;
-  IMatchFinder matchFinder;
-
-  UInt32 optimumEndIndex;
-  UInt32 optimumCurrentIndex;
-
-  UInt32 longestMatchLength;
-  UInt32 numPairs;
-  UInt32 numAvail;
-
-  UInt32 numFastBytes;
-  UInt32 additionalOffset;
-  UInt32 reps[LZMA_NUM_REPS];
-  UInt32 state;
-
-  unsigned lc, lp, pb;
-  unsigned lpMask, pbMask;
-  unsigned lclp;
-
-  CLzmaProb *litProbs;
-
-  Bool fastMode;
-  Bool writeEndMark;
-  Bool finished;
-  Bool multiThread;
-  Bool needInit;
-
-  UInt64 nowPos64;
-
-  UInt32 matchPriceCount;
-  UInt32 alignPriceCount;
-
-  UInt32 distTableSize;
-
-  UInt32 dictSize;
-  SRes result;
-
-  CRangeEnc rc;
-
-  #ifndef _7ZIP_ST
-  Bool mtMode;
-  CMatchFinderMt matchFinderMt;
-  #endif
-
-  CMatchFinder matchFinderBase;
-
-  #ifndef _7ZIP_ST
-  Byte pad[128];
-  #endif
-
-  COptimal opt[kNumOpts];
-
-  #ifndef LZMA_LOG_BSR
-  Byte g_FastPos[1 << kNumLogBits];
-  #endif
-
-  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
-  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
-
-  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
-  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
-  UInt32 alignPrices[kAlignTableSize];
-
-  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
-  CLzmaProb isRep[kNumStates];
-  CLzmaProb isRepG0[kNumStates];
-  CLzmaProb isRepG1[kNumStates];
-  CLzmaProb isRepG2[kNumStates];
-  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];
-
-  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
-  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
-  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
-
-  CLenPriceEnc lenEnc;
-  CLenPriceEnc repLenEnc;
-
-  CSaveState saveState;
-
-  #ifndef _7ZIP_ST
-  Byte pad2[128];
-  #endif
-} CLzmaEnc;
-
-
-void LzmaEnc_SaveState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CSaveState *dest = &p->saveState;
-  int i;
-  dest->lenEnc = p->lenEnc;
-  dest->repLenEnc = p->repLenEnc;
-  dest->state = p->state;
-
-  for (i = 0; i < kNumStates; i++)
-  {
-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-  }
-  for (i = 0; i < kNumLenToPosStates; i++)
-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-  memcpy(dest->reps, p->reps, sizeof(p->reps));
-  memcpy(dest->litProbs, p->litProbs, ((UInt32)0x300 << p->lclp) * sizeof(CLzmaProb));
-}
-
-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
-{
-  CLzmaEnc *dest = (CLzmaEnc *)pp;
-  const CSaveState *p = &dest->saveState;
-  int i;
-  dest->lenEnc = p->lenEnc;
-  dest->repLenEnc = p->repLenEnc;
-  dest->state = p->state;
-
-  for (i = 0; i < kNumStates; i++)
-  {
-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
-  }
-  for (i = 0; i < kNumLenToPosStates; i++)
-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
-  memcpy(dest->reps, p->reps, sizeof(p->reps));
-  memcpy(dest->litProbs, p->litProbs, ((UInt32)0x300 << dest->lclp) * sizeof(CLzmaProb));
-}
-
-SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  CLzmaEncProps props = *props2;
-  LzmaEncProps_Normalize(&props);
-
-  if (props.lc > LZMA_LC_MAX
-      || props.lp > LZMA_LP_MAX
-      || props.pb > LZMA_PB_MAX
-      || props.dictSize > ((UInt64)1 << kDicLogSizeMaxCompress)
-      || props.dictSize > kMaxHistorySize)
-    return SZ_ERROR_PARAM;
-
-  p->dictSize = props.dictSize;
-  {
-    unsigned fb = props.fb;
-    if (fb < 5)
-      fb = 5;
-    if (fb > LZMA_MATCH_LEN_MAX)
-      fb = LZMA_MATCH_LEN_MAX;
-    p->numFastBytes = fb;
-  }
-  p->lc = props.lc;
-  p->lp = props.lp;
-  p->pb = props.pb;
-  p->fastMode = (props.algo == 0);
-  p->matchFinderBase.btMode = (Byte)(props.btMode ? 1 : 0);
-  {
-    UInt32 numHashBytes = 4;
-    if (props.btMode)
-    {
-      if (props.numHashBytes < 2)
-        numHashBytes = 2;
-      else if (props.numHashBytes < 4)
-        numHashBytes = props.numHashBytes;
-    }
-    p->matchFinderBase.numHashBytes = numHashBytes;
-  }
-
-  p->matchFinderBase.cutValue = props.mc;
-
-  p->writeEndMark = props.writeEndMark;
-
-  #ifndef _7ZIP_ST
-  /*
-  if (newMultiThread != _multiThread)
-  {
-    ReleaseMatchFinder();
-    _multiThread = newMultiThread;
-  }
-  */
-  p->multiThread = (props.numThreads > 1);
-  #endif
-
-  return SZ_OK;
-}
-
-static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
-static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
-static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
-static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};
-
-#define IsCharState(s) ((s) < 7)
-
-#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)
-
-#define kInfinityPrice (1 << 30)
-
-static void RangeEnc_Construct(CRangeEnc *p)
-{
-  p->outStream = NULL;
-  p->bufBase = NULL;
-}
-
-#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)
-
-#define RC_BUF_SIZE (1 << 16)
-static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
-{
-  if (!p->bufBase)
-  {
-    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
-    if (!p->bufBase)
-      return 0;
-    p->bufLim = p->bufBase + RC_BUF_SIZE;
-  }
-  return 1;
-}
-
-static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
-{
-  alloc->Free(alloc, p->bufBase);
-  p->bufBase = 0;
-}
-
-static void RangeEnc_Init(CRangeEnc *p)
-{
-  /* Stream.Init(); */
-  p->low = 0;
-  p->range = 0xFFFFFFFF;
-  p->cacheSize = 1;
-  p->cache = 0;
-
-  p->buf = p->bufBase;
-
-  p->processed = 0;
-  p->res = SZ_OK;
-}
-
-static void RangeEnc_FlushStream(CRangeEnc *p)
-{
-  size_t num;
-  if (p->res != SZ_OK)
-    return;
-  num = p->buf - p->bufBase;
-  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
-    p->res = SZ_ERROR_WRITE;
-  p->processed += num;
-  p->buf = p->bufBase;
-}
-
-static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
-{
-  if ((UInt32)p->low < (UInt32)0xFF000000 || (unsigned)(p->low >> 32) != 0)
-  {
-    Byte temp = p->cache;
-    do
-    {
-      Byte *buf = p->buf;
-      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
-      p->buf = buf;
-      if (buf == p->bufLim)
-        RangeEnc_FlushStream(p);
-      temp = 0xFF;
-    }
-    while (--p->cacheSize != 0);
-    p->cache = (Byte)((UInt32)p->low >> 24);
-  }
-  p->cacheSize++;
-  p->low = (UInt32)p->low << 8;
-}
-
-static void RangeEnc_FlushData(CRangeEnc *p)
-{
-  int i;
-  for (i = 0; i < 5; i++)
-    RangeEnc_ShiftLow(p);
-}
-
-static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, unsigned numBits)
-{
-  do
-  {
-    p->range >>= 1;
-    p->low += p->range & (0 - ((value >> --numBits) & 1));
-    if (p->range < kTopValue)
-    {
-      p->range <<= 8;
-      RangeEnc_ShiftLow(p);
-    }
-  }
-  while (numBits != 0);
-}
-
-static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
-{
-  UInt32 ttt = *prob;
-  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
-  if (symbol == 0)
-  {
-    p->range = newBound;
-    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
-  }
-  else
-  {
-    p->low += newBound;
-    p->range -= newBound;
-    ttt -= ttt >> kNumMoveBits;
-  }
-  *prob = (CLzmaProb)ttt;
-  if (p->range < kTopValue)
-  {
-    p->range <<= 8;
-    RangeEnc_ShiftLow(p);
-  }
-}
-
-static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
-{
-  symbol |= 0x100;
-  do
-  {
-    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
-    symbol <<= 1;
-  }
-  while (symbol < 0x10000);
-}
-
-static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
-{
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte <<= 1;
-    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
-    symbol <<= 1;
-    offs &= ~(matchByte ^ symbol);
-  }
-  while (symbol < 0x10000);
-}
-
-static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
-{
-  UInt32 i;
-  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
-  {
-    const int kCyclesBits = kNumBitPriceShiftBits;
-    UInt32 w = i;
-    UInt32 bitCount = 0;
-    int j;
-    for (j = 0; j < kCyclesBits; j++)
-    {
-      w = w * w;
-      bitCount <<= 1;
-      while (w >= ((UInt32)1 << 16))
-      {
-        w >>= 1;
-        bitCount++;
-      }
-    }
-    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
-  }
-}
-
-
-#define GET_PRICE(prob, symbol) \
-  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-
-#define GET_PRICEa(prob, symbol) \
-  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];
-
-#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
-#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-
-#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
-#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]
-
-static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= 0x100;
-  do
-  {
-    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
-    symbol <<= 1;
-  }
-  while (symbol < 0x10000);
-  return price;
-}
-
-static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 offs = 0x100;
-  symbol |= 0x100;
-  do
-  {
-    matchByte <<= 1;
-    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
-    symbol <<= 1;
-    offs &= ~(matchByte ^ symbol);
-  }
-  while (symbol < 0x10000);
-  return price;
-}
-
-
-static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0;)
-  {
-    UInt32 bit;
-    i--;
-    bit = (symbol >> i) & 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m << 1) | bit;
-  }
-}
-
-static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
-{
-  UInt32 m = 1;
-  int i;
-  for (i = 0; i < numBitLevels; i++)
-  {
-    UInt32 bit = symbol & 1;
-    RangeEnc_EncodeBit(rc, probs + m, bit);
-    m = (m << 1) | bit;
-    symbol >>= 1;
-  }
-}
-
-static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  symbol |= (1 << numBitLevels);
-  while (symbol != 1)
-  {
-    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
-    symbol >>= 1;
-  }
-  return price;
-}
-
-static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, const UInt32 *ProbPrices)
-{
-  UInt32 price = 0;
-  UInt32 m = 1;
-  int i;
-  for (i = numBitLevels; i != 0; i--)
-  {
-    UInt32 bit = symbol & 1;
-    symbol >>= 1;
-    price += GET_PRICEa(probs[m], bit);
-    m = (m << 1) | bit;
-  }
-  return price;
-}
-
-
-static void LenEnc_Init(CLenEnc *p)
-{
-  unsigned i;
-  p->choice = p->choice2 = kProbInitValue;
-  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
-    p->low[i] = kProbInitValue;
-  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
-    p->mid[i] = kProbInitValue;
-  for (i = 0; i < kLenNumHighSymbols; i++)
-    p->high[i] = kProbInitValue;
-}
-
-static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
-{
-  if (symbol < kLenNumLowSymbols)
-  {
-    RangeEnc_EncodeBit(rc, &p->choice, 0);
-    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
-  }
-  else
-  {
-    RangeEnc_EncodeBit(rc, &p->choice, 1);
-    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
-    {
-      RangeEnc_EncodeBit(rc, &p->choice2, 0);
-      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
-    }
-    else
-    {
-      RangeEnc_EncodeBit(rc, &p->choice2, 1);
-      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
-    }
-  }
-}
-
-static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, const UInt32 *ProbPrices)
-{
-  UInt32 a0 = GET_PRICE_0a(p->choice);
-  UInt32 a1 = GET_PRICE_1a(p->choice);
-  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
-  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
-  UInt32 i = 0;
-  for (i = 0; i < kLenNumLowSymbols; i++)
-  {
-    if (i >= numSymbols)
-      return;
-    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
-  }
-  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
-  {
-    if (i >= numSymbols)
-      return;
-    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
-  }
-  for (; i < numSymbols; i++)
-    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
-}
-
-static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, const UInt32 *ProbPrices)
-{
-  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
-  p->counters[posState] = p->tableSize;
-}
-
-static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, const UInt32 *ProbPrices)
-{
-  UInt32 posState;
-  for (posState = 0; posState < numPosStates; posState++)
-    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, const UInt32 *ProbPrices)
-{
-  LenEnc_Encode(&p->p, rc, symbol, posState);
-  if (updatePrice)
-    if (--p->counters[posState] == 0)
-      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
-}
-
-
-
-
-static void MovePos(CLzmaEnc *p, UInt32 num)
-{
-  #ifdef SHOW_STAT
-  g_STAT_OFFSET += num;
-  printf("\n MovePos %u", num);
-  #endif
-
-  if (num != 0)
-  {
-    p->additionalOffset += num;
-    p->matchFinder.Skip(p->matchFinderObj, num);
-  }
-}
-
-static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
-{
-  UInt32 lenRes = 0, numPairs;
-  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
-
-  #ifdef SHOW_STAT
-  printf("\n i = %u numPairs = %u    ", g_STAT_OFFSET, numPairs / 2);
-  g_STAT_OFFSET++;
-  {
-    UInt32 i;
-    for (i = 0; i < numPairs; i += 2)
-      printf("%2u %6u   | ", p->matches[i], p->matches[i + 1]);
-  }
-  #endif
-
-  if (numPairs > 0)
-  {
-    lenRes = p->matches[numPairs - 2];
-    if (lenRes == p->numFastBytes)
-    {
-      UInt32 numAvail = p->numAvail;
-      if (numAvail > LZMA_MATCH_LEN_MAX)
-        numAvail = LZMA_MATCH_LEN_MAX;
-      {
-        const Byte *pbyCur = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-        const Byte *pby = pbyCur + lenRes;
-        ptrdiff_t dif = (ptrdiff_t)-1 - p->matches[numPairs - 1];
-        const Byte *pbyLim = pbyCur + numAvail;
-        for (; pby != pbyLim && *pby == pby[dif]; pby++);
-        lenRes = (UInt32)(pby - pbyCur);
-      }
-    }
-  }
-  p->additionalOffset++;
-  *numDistancePairsRes = numPairs;
-  return lenRes;
-}
-
-
-#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
-#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
-#define IsShortRep(p) ((p)->backPrev == 0)
-
-static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
-{
-  return
-    GET_PRICE_0(p->isRepG0[state]) +
-    GET_PRICE_0(p->isRep0Long[state][posState]);
-}
-
-static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
-{
-  UInt32 price;
-  if (repIndex == 0)
-  {
-    price = GET_PRICE_0(p->isRepG0[state]);
-    price += GET_PRICE_1(p->isRep0Long[state][posState]);
-  }
-  else
-  {
-    price = GET_PRICE_1(p->isRepG0[state]);
-    if (repIndex == 1)
-      price += GET_PRICE_0(p->isRepG1[state]);
-    else
-    {
-      price += GET_PRICE_1(p->isRepG1[state]);
-      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
-    }
-  }
-  return price;
-}
-
-static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
-{
-  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
-    GetPureRepPrice(p, repIndex, state, posState);
-}
-
-static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
-{
-  UInt32 posMem = p->opt[cur].posPrev;
-  UInt32 backMem = p->opt[cur].backPrev;
-  p->optimumEndIndex = cur;
-  do
-  {
-    if (p->opt[cur].prev1IsChar)
-    {
-      MakeAsChar(&p->opt[posMem])
-      p->opt[posMem].posPrev = posMem - 1;
-      if (p->opt[cur].prev2)
-      {
-        p->opt[posMem - 1].prev1IsChar = False;
-        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
-        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
-      }
-    }
-    {
-      UInt32 posPrev = posMem;
-      UInt32 backCur = backMem;
-
-      backMem = p->opt[posPrev].backPrev;
-      posMem = p->opt[posPrev].posPrev;
-
-      p->opt[posPrev].backPrev = backCur;
-      p->opt[posPrev].posPrev = cur;
-      cur = posPrev;
-    }
-  }
-  while (cur != 0);
-  *backRes = p->opt[0].backPrev;
-  p->optimumCurrentIndex  = p->opt[0].posPrev;
-  return p->optimumCurrentIndex;
-}
-
-#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * (UInt32)0x300)
-
-static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
-{
-  UInt32 lenEnd, cur;
-  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
-  UInt32 *matches;
-
-  {
-
-  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, len;
-  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
-  const Byte *data;
-  Byte curByte, matchByte;
-
-  if (p->optimumEndIndex != p->optimumCurrentIndex)
-  {
-    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
-    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
-    *backRes = opt->backPrev;
-    p->optimumCurrentIndex = opt->posPrev;
-    return lenRes;
-  }
-  p->optimumCurrentIndex = p->optimumEndIndex = 0;
-
-  if (p->additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &numPairs);
-  else
-  {
-    mainLen = p->longestMatchLength;
-    numPairs = p->numPairs;
-  }
-
-  numAvail = p->numAvail;
-  if (numAvail < 2)
-  {
-    *backRes = (UInt32)(-1);
-    return 1;
-  }
-  if (numAvail > LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-
-  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-  repMaxIndex = 0;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 lenTest;
-    const Byte *data2;
-    reps[i] = p->reps[i];
-    data2 = data - reps[i] - 1;
-    if (data[0] != data2[0] || data[1] != data2[1])
-    {
-      repLens[i] = 0;
-      continue;
-    }
-    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-    repLens[i] = lenTest;
-    if (lenTest > repLens[repMaxIndex])
-      repMaxIndex = i;
-  }
-  if (repLens[repMaxIndex] >= p->numFastBytes)
-  {
-    UInt32 lenRes;
-    *backRes = repMaxIndex;
-    lenRes = repLens[repMaxIndex];
-    MovePos(p, lenRes - 1);
-    return lenRes;
-  }
-
-  matches = p->matches;
-  if (mainLen >= p->numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-  curByte = *data;
-  matchByte = *(data - (reps[0] + 1));
-
-  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
-  {
-    *backRes = (UInt32)-1;
-    return 1;
-  }
-
-  p->opt[0].state = (CState)p->state;
-
-  posState = (position & p->pbMask);
-
-  {
-    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
-        (!IsCharState(p->state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-  }
-
-  MakeAsChar(&p->opt[1]);
-
-  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
-  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);
-
-  if (matchByte == curByte)
-  {
-    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
-    if (shortRepPrice < p->opt[1].price)
-    {
-      p->opt[1].price = shortRepPrice;
-      MakeAsShortRep(&p->opt[1]);
-    }
-  }
-  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);
-
-  if (lenEnd < 2)
-  {
-    *backRes = p->opt[1].backPrev;
-    return 1;
-  }
-
-  p->opt[1].posPrev = 0;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-    p->opt[0].backs[i] = reps[i];
-
-  len = lenEnd;
-  do
-    p->opt[len--].price = kInfinityPrice;
-  while (len >= 2);
-
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 repLen = repLens[i];
-    UInt32 price;
-    if (repLen < 2)
-      continue;
-    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
-    do
-    {
-      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
-      COptimal *opt = &p->opt[repLen];
-      if (curAndLenPrice < opt->price)
-      {
-        opt->price = curAndLenPrice;
-        opt->posPrev = 0;
-        opt->backPrev = i;
-        opt->prev1IsChar = False;
-      }
-    }
-    while (--repLen >= 2);
-  }
-
-  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);
-
-  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
-  if (len <= mainLen)
-  {
-    UInt32 offs = 0;
-    while (len > matches[offs])
-      offs += 2;
-    for (; ; len++)
-    {
-      COptimal *opt;
-      UInt32 distance = matches[offs + 1];
-
-      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
-      UInt32 lenToPosState = GetLenToPosState(len);
-      if (distance < kNumFullDistances)
-        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
-      else
-      {
-        UInt32 slot;
-        GetPosSlot2(distance, slot);
-        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
-      }
-      opt = &p->opt[len];
-      if (curAndLenPrice < opt->price)
-      {
-        opt->price = curAndLenPrice;
-        opt->posPrev = 0;
-        opt->backPrev = distance + LZMA_NUM_REPS;
-        opt->prev1IsChar = False;
-      }
-      if (len == matches[offs])
-      {
-        offs += 2;
-        if (offs == numPairs)
-          break;
-      }
-    }
-  }
-
-  cur = 0;
-
-    #ifdef SHOW_STAT2
-    /* if (position >= 0) */
-    {
-      unsigned i;
-      printf("\n pos = %4X", position);
-      for (i = cur; i <= lenEnd; i++)
-      printf("\nprice[%4X] = %u", position - cur + i, p->opt[i].price);
-    }
-    #endif
-
-  }
-
-  for (;;)
-  {
-    UInt32 numAvail;
-    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
-    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
-    Bool nextIsChar;
-    Byte curByte, matchByte;
-    const Byte *data;
-    COptimal *curOpt;
-    COptimal *nextOpt;
-
-    cur++;
-    if (cur == lenEnd)
-      return Backward(p, backRes, cur);
-
-    newLen = ReadMatchDistances(p, &numPairs);
-    if (newLen >= p->numFastBytes)
-    {
-      p->numPairs = numPairs;
-      p->longestMatchLength = newLen;
-      return Backward(p, backRes, cur);
-    }
-    position++;
-    curOpt = &p->opt[cur];
-    posPrev = curOpt->posPrev;
-    if (curOpt->prev1IsChar)
-    {
-      posPrev--;
-      if (curOpt->prev2)
-      {
-        state = p->opt[curOpt->posPrev2].state;
-        if (curOpt->backPrev2 < LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      else
-        state = p->opt[posPrev].state;
-      state = kLiteralNextStates[state];
-    }
-    else
-      state = p->opt[posPrev].state;
-    if (posPrev == cur - 1)
-    {
-      if (IsShortRep(curOpt))
-        state = kShortRepNextStates[state];
-      else
-        state = kLiteralNextStates[state];
-    }
-    else
-    {
-      UInt32 pos;
-      const COptimal *prevOpt;
-      if (curOpt->prev1IsChar && curOpt->prev2)
-      {
-        posPrev = curOpt->posPrev2;
-        pos = curOpt->backPrev2;
-        state = kRepNextStates[state];
-      }
-      else
-      {
-        pos = curOpt->backPrev;
-        if (pos < LZMA_NUM_REPS)
-          state = kRepNextStates[state];
-        else
-          state = kMatchNextStates[state];
-      }
-      prevOpt = &p->opt[posPrev];
-      if (pos < LZMA_NUM_REPS)
-      {
-        UInt32 i;
-        reps[0] = prevOpt->backs[pos];
-        for (i = 1; i <= pos; i++)
-          reps[i] = prevOpt->backs[i - 1];
-        for (; i < LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt->backs[i];
-      }
-      else
-      {
-        UInt32 i;
-        reps[0] = (pos - LZMA_NUM_REPS);
-        for (i = 1; i < LZMA_NUM_REPS; i++)
-          reps[i] = prevOpt->backs[i - 1];
-      }
-    }
-    curOpt->state = (CState)state;
-
-    curOpt->backs[0] = reps[0];
-    curOpt->backs[1] = reps[1];
-    curOpt->backs[2] = reps[2];
-    curOpt->backs[3] = reps[3];
-
-    curPrice = curOpt->price;
-    nextIsChar = False;
-    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-    curByte = *data;
-    matchByte = *(data - (reps[0] + 1));
-
-    posState = (position & p->pbMask);
-
-    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
-    {
-      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
-      curAnd1Price +=
-        (!IsCharState(state) ?
-          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
-          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
-    }
-
-    nextOpt = &p->opt[cur + 1];
-
-    if (curAnd1Price < nextOpt->price)
-    {
-      nextOpt->price = curAnd1Price;
-      nextOpt->posPrev = cur;
-      MakeAsChar(nextOpt);
-      nextIsChar = True;
-    }
-
-    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
-    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
-
-    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
-    {
-      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
-      if (shortRepPrice <= nextOpt->price)
-      {
-        nextOpt->price = shortRepPrice;
-        nextOpt->posPrev = cur;
-        MakeAsShortRep(nextOpt);
-        nextIsChar = True;
-      }
-    }
-    numAvailFull = p->numAvail;
-    {
-      UInt32 temp = kNumOpts - 1 - cur;
-      if (temp < numAvailFull)
-        numAvailFull = temp;
-    }
-
-    if (numAvailFull < 2)
-      continue;
-    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);
-
-    if (!nextIsChar && matchByte != curByte) /* speed optimization */
-    {
-      /* try Literal + rep0 */
-      UInt32 temp;
-      UInt32 lenTest2;
-      const Byte *data2 = data - reps[0] - 1;
-      UInt32 limit = p->numFastBytes + 1;
-      if (limit > numAvailFull)
-        limit = numAvailFull;
-
-      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
-      lenTest2 = temp - 1;
-      if (lenTest2 >= 2)
-      {
-        UInt32 state2 = kLiteralNextStates[state];
-        UInt32 posStateNext = (position + 1) & p->pbMask;
-        UInt32 nextRepMatchPrice = curAnd1Price +
-            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-            GET_PRICE_1(p->isRep[state2]);
-        /* for (; lenTest2 >= 2; lenTest2--) */
-        {
-          UInt32 curAndLenPrice;
-          COptimal *opt;
-          UInt32 offset = cur + 1 + lenTest2;
-          while (lenEnd < offset)
-            p->opt[++lenEnd].price = kInfinityPrice;
-          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-          opt = &p->opt[offset];
-          if (curAndLenPrice < opt->price)
-          {
-            opt->price = curAndLenPrice;
-            opt->posPrev = cur + 1;
-            opt->backPrev = 0;
-            opt->prev1IsChar = True;
-            opt->prev2 = False;
-          }
-        }
-      }
-    }
-
-    startLen = 2; /* speed optimization */
-    {
-    UInt32 repIndex;
-    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
-    {
-      UInt32 lenTest;
-      UInt32 lenTestTemp;
-      UInt32 price;
-      const Byte *data2 = data - reps[repIndex] - 1;
-      if (data[0] != data2[0] || data[1] != data2[1])
-        continue;
-      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
-      while (lenEnd < cur + lenTest)
-        p->opt[++lenEnd].price = kInfinityPrice;
-      lenTestTemp = lenTest;
-      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
-      do
-      {
-        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
-        COptimal *opt = &p->opt[cur + lenTest];
-        if (curAndLenPrice < opt->price)
-        {
-          opt->price = curAndLenPrice;
-          opt->posPrev = cur;
-          opt->backPrev = repIndex;
-          opt->prev1IsChar = False;
-        }
-      }
-      while (--lenTest >= 2);
-      lenTest = lenTestTemp;
-
-      if (repIndex == 0)
-        startLen = lenTest + 1;
-
-      /* if (_maxMode) */
-        {
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p->numFastBytes;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 >= 2)
-          {
-            UInt32 nextRepMatchPrice;
-            UInt32 state2 = kRepNextStates[state];
-            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-            UInt32 curAndLenCharPrice =
-                price + p->repLenEnc.prices[posState][lenTest - 2] +
-                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p->ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (position + lenTest + 1) & p->pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p->isRep[state2]);
-
-            /* for (; lenTest2 >= 2; lenTest2--) */
-            {
-              UInt32 curAndLenPrice;
-              COptimal *opt;
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              while (lenEnd < offset)
-                p->opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &p->opt[offset];
-              if (curAndLenPrice < opt->price)
-              {
-                opt->price = curAndLenPrice;
-                opt->posPrev = cur + lenTest + 1;
-                opt->backPrev = 0;
-                opt->prev1IsChar = True;
-                opt->prev2 = True;
-                opt->posPrev2 = cur;
-                opt->backPrev2 = repIndex;
-              }
-            }
-          }
-        }
-    }
-    }
-    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
-    if (newLen > numAvail)
-    {
-      newLen = numAvail;
-      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
-      matches[numPairs] = newLen;
-      numPairs += 2;
-    }
-    if (newLen >= startLen)
-    {
-      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
-      UInt32 offs, curBack, posSlot;
-      UInt32 lenTest;
-      while (lenEnd < cur + newLen)
-        p->opt[++lenEnd].price = kInfinityPrice;
-
-      offs = 0;
-      while (startLen > matches[offs])
-        offs += 2;
-      curBack = matches[offs + 1];
-      GetPosSlot2(curBack, posSlot);
-      for (lenTest = /*2*/ startLen; ; lenTest++)
-      {
-        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
-        {
-        UInt32 lenToPosState = GetLenToPosState(lenTest);
-        COptimal *opt;
-        if (curBack < kNumFullDistances)
-          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
-        else
-          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
-
-        opt = &p->opt[cur + lenTest];
-        if (curAndLenPrice < opt->price)
-        {
-          opt->price = curAndLenPrice;
-          opt->posPrev = cur;
-          opt->backPrev = curBack + LZMA_NUM_REPS;
-          opt->prev1IsChar = False;
-        }
-        }
-
-        if (/*_maxMode && */lenTest == matches[offs])
-        {
-          /* Try Match + Literal + Rep0 */
-          const Byte *data2 = data - curBack - 1;
-          UInt32 lenTest2 = lenTest + 1;
-          UInt32 limit = lenTest2 + p->numFastBytes;
-          if (limit > numAvailFull)
-            limit = numAvailFull;
-          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
-          lenTest2 -= lenTest + 1;
-          if (lenTest2 >= 2)
-          {
-            UInt32 nextRepMatchPrice;
-            UInt32 state2 = kMatchNextStates[state];
-            UInt32 posStateNext = (position + lenTest) & p->pbMask;
-            UInt32 curAndLenCharPrice = curAndLenPrice +
-                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
-                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
-                    data[lenTest], data2[lenTest], p->ProbPrices);
-            state2 = kLiteralNextStates[state2];
-            posStateNext = (posStateNext + 1) & p->pbMask;
-            nextRepMatchPrice = curAndLenCharPrice +
-                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
-                GET_PRICE_1(p->isRep[state2]);
-
-            /* for (; lenTest2 >= 2; lenTest2--) */
-            {
-              UInt32 offset = cur + lenTest + 1 + lenTest2;
-              UInt32 curAndLenPrice2;
-              COptimal *opt;
-              while (lenEnd < offset)
-                p->opt[++lenEnd].price = kInfinityPrice;
-              curAndLenPrice2 = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
-              opt = &p->opt[offset];
-              if (curAndLenPrice2 < opt->price)
-              {
-                opt->price = curAndLenPrice2;
-                opt->posPrev = cur + lenTest + 1;
-                opt->backPrev = 0;
-                opt->prev1IsChar = True;
-                opt->prev2 = True;
-                opt->posPrev2 = cur;
-                opt->backPrev2 = curBack + LZMA_NUM_REPS;
-              }
-            }
-          }
-          offs += 2;
-          if (offs == numPairs)
-            break;
-          curBack = matches[offs + 1];
-          if (curBack >= kNumFullDistances)
-            GetPosSlot2(curBack, posSlot);
-        }
-      }
-    }
-  }
-}
-
-#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))
-
-static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
-{
-  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
-  const Byte *data;
-  const UInt32 *matches;
-
-  if (p->additionalOffset == 0)
-    mainLen = ReadMatchDistances(p, &numPairs);
-  else
-  {
-    mainLen = p->longestMatchLength;
-    numPairs = p->numPairs;
-  }
-
-  numAvail = p->numAvail;
-  *backRes = (UInt32)-1;
-  if (numAvail < 2)
-    return 1;
-  if (numAvail > LZMA_MATCH_LEN_MAX)
-    numAvail = LZMA_MATCH_LEN_MAX;
-  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-
-  repLen = repIndex = 0;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 len;
-    const Byte *data2 = data - p->reps[i] - 1;
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
-    if (len >= p->numFastBytes)
-    {
-      *backRes = i;
-      MovePos(p, len - 1);
-      return len;
-    }
-    if (len > repLen)
-    {
-      repIndex = i;
-      repLen = len;
-    }
-  }
-
-  matches = p->matches;
-  if (mainLen >= p->numFastBytes)
-  {
-    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
-    MovePos(p, mainLen - 1);
-    return mainLen;
-  }
-
-  mainDist = 0; /* for GCC */
-  if (mainLen >= 2)
-  {
-    mainDist = matches[numPairs - 1];
-    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
-    {
-      if (!ChangePair(matches[numPairs - 3], mainDist))
-        break;
-      numPairs -= 2;
-      mainLen = matches[numPairs - 2];
-      mainDist = matches[numPairs - 1];
-    }
-    if (mainLen == 2 && mainDist >= 0x80)
-      mainLen = 1;
-  }
-
-  if (repLen >= 2 && (
-        (repLen + 1 >= mainLen) ||
-        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
-        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
-  {
-    *backRes = repIndex;
-    MovePos(p, repLen - 1);
-    return repLen;
-  }
-
-  if (mainLen < 2 || numAvail <= 2)
-    return 1;
-
-  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
-  if (p->longestMatchLength >= 2)
-  {
-    UInt32 newDistance = matches[p->numPairs - 1];
-    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
-        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
-        (p->longestMatchLength > mainLen + 1) ||
-        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
-      return 1;
-  }
-
-  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
-  for (i = 0; i < LZMA_NUM_REPS; i++)
-  {
-    UInt32 len, limit;
-    const Byte *data2 = data - p->reps[i] - 1;
-    if (data[0] != data2[0] || data[1] != data2[1])
-      continue;
-    limit = mainLen - 1;
-    for (len = 2; len < limit && data[len] == data2[len]; len++);
-    if (len >= limit)
-      return 1;
-  }
-  *backRes = mainDist + LZMA_NUM_REPS;
-  MovePos(p, mainLen - 2);
-  return mainLen;
-}
-
-static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
-{
-  UInt32 len;
-  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-  p->state = kMatchNextStates[p->state];
-  len = LZMA_MATCH_LEN_MIN;
-  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
-  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
-  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
-}
-
-static SRes CheckErrors(CLzmaEnc *p)
-{
-  if (p->result != SZ_OK)
-    return p->result;
-  if (p->rc.res != SZ_OK)
-    p->result = SZ_ERROR_WRITE;
-  if (p->matchFinderBase.result != SZ_OK)
-    p->result = SZ_ERROR_READ;
-  if (p->result != SZ_OK)
-    p->finished = True;
-  return p->result;
-}
-
-static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
-{
-  /* ReleaseMFStream(); */
-  p->finished = True;
-  if (p->writeEndMark)
-    WriteEndMarker(p, nowPos & p->pbMask);
-  RangeEnc_FlushData(&p->rc);
-  RangeEnc_FlushStream(&p->rc);
-  return CheckErrors(p);
-}
-
-static void FillAlignPrices(CLzmaEnc *p)
-{
-  UInt32 i;
-  for (i = 0; i < kAlignTableSize; i++)
-    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
-  p->alignPriceCount = 0;
-}
-
-static void FillDistancesPrices(CLzmaEnc *p)
-{
-  UInt32 tempPrices[kNumFullDistances];
-  UInt32 i, lenToPosState;
-  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
-  {
-    UInt32 posSlot = GetPosSlot1(i);
-    UInt32 footerBits = ((posSlot >> 1) - 1);
-    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
-  }
-
-  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
-  {
-    UInt32 posSlot;
-    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
-    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
-    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
-      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
-    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
-      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);
-
-    {
-      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
-      for (i = 0; i < kStartPosModelIndex; i++)
-        distancesPrices[i] = posSlotPrices[i];
-      for (; i < kNumFullDistances; i++)
-        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
-    }
-  }
-  p->matchPriceCount = 0;
-}
-
-void LzmaEnc_Construct(CLzmaEnc *p)
-{
-  RangeEnc_Construct(&p->rc);
-  MatchFinder_Construct(&p->matchFinderBase);
-
-  #ifndef _7ZIP_ST
-  MatchFinderMt_Construct(&p->matchFinderMt);
-  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
-  #endif
-
-  {
-    CLzmaEncProps props;
-    LzmaEncProps_Init(&props);
-    LzmaEnc_SetProps(p, &props);
-  }
-
-  #ifndef LZMA_LOG_BSR
-  LzmaEnc_FastPosInit(p->g_FastPos);
-  #endif
-
-  LzmaEnc_InitPriceTables(p->ProbPrices);
-  p->litProbs = NULL;
-  p->saveState.litProbs = NULL;
-}
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
-{
-  void *p;
-  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
-  if (p)
-    LzmaEnc_Construct((CLzmaEnc *)p);
-  return p;
-}
-
-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
-{
-  alloc->Free(alloc, p->litProbs);
-  alloc->Free(alloc, p->saveState.litProbs);
-  p->litProbs = NULL;
-  p->saveState.litProbs = NULL;
-}
-
-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  #ifndef _7ZIP_ST
-  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
-  #endif
-
-  MatchFinder_Free(&p->matchFinderBase, allocBig);
-  LzmaEnc_FreeLits(p, alloc);
-  RangeEnc_Free(&p->rc, alloc);
-}
-
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
-  alloc->Free(alloc, p);
-}
-
-static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
-{
-  UInt32 nowPos32, startPos32;
-  if (p->needInit)
-  {
-    p->matchFinder.Init(p->matchFinderObj);
-    p->needInit = 0;
-  }
-
-  if (p->finished)
-    return p->result;
-  RINOK(CheckErrors(p));
-
-  nowPos32 = (UInt32)p->nowPos64;
-  startPos32 = nowPos32;
-
-  if (p->nowPos64 == 0)
-  {
-    UInt32 numPairs;
-    Byte curByte;
-    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-      return Flush(p, nowPos32);
-    ReadMatchDistances(p, &numPairs);
-    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
-    p->state = kLiteralNextStates[p->state];
-    curByte = *(p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset);
-    LitEnc_Encode(&p->rc, p->litProbs, curByte);
-    p->additionalOffset--;
-    nowPos32++;
-  }
-
-  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
-  for (;;)
-  {
-    UInt32 pos, len, posState;
-
-    if (p->fastMode)
-      len = GetOptimumFast(p, &pos);
-    else
-      len = GetOptimum(p, nowPos32, &pos);
-
-    #ifdef SHOW_STAT2
-    printf("\n pos = %4X,   len = %u   pos = %u", nowPos32, len, pos);
-    #endif
-
-    posState = nowPos32 & p->pbMask;
-    if (len == 1 && pos == (UInt32)-1)
-    {
-      Byte curByte;
-      CLzmaProb *probs;
-      const Byte *data;
-
-      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
-      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-      curByte = *data;
-      probs = LIT_PROBS(nowPos32, *(data - 1));
-      if (IsCharState(p->state))
-        LitEnc_Encode(&p->rc, probs, curByte);
-      else
-        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
-      p->state = kLiteralNextStates[p->state];
-    }
-    else
-    {
-      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
-      if (pos < LZMA_NUM_REPS)
-      {
-        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
-        if (pos == 0)
-        {
-          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
-          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
-        }
-        else
-        {
-          UInt32 distance = p->reps[pos];
-          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
-          if (pos == 1)
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
-          else
-          {
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
-            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
-            if (pos == 3)
-              p->reps[3] = p->reps[2];
-            p->reps[2] = p->reps[1];
-          }
-          p->reps[1] = p->reps[0];
-          p->reps[0] = distance;
-        }
-        if (len == 1)
-          p->state = kShortRepNextStates[p->state];
-        else
-        {
-          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-          p->state = kRepNextStates[p->state];
-        }
-      }
-      else
-      {
-        UInt32 posSlot;
-        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
-        p->state = kMatchNextStates[p->state];
-        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
-        pos -= LZMA_NUM_REPS;
-        GetPosSlot(pos, posSlot);
-        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
-
-        if (posSlot >= kStartPosModelIndex)
-        {
-          UInt32 footerBits = ((posSlot >> 1) - 1);
-          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
-          UInt32 posReduced = pos - base;
-
-          if (posSlot < kEndPosModelIndex)
-            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
-          else
-          {
-            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
-            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
-            p->alignPriceCount++;
-          }
-        }
-        p->reps[3] = p->reps[2];
-        p->reps[2] = p->reps[1];
-        p->reps[1] = p->reps[0];
-        p->reps[0] = pos;
-        p->matchPriceCount++;
-      }
-    }
-    p->additionalOffset -= len;
-    nowPos32 += len;
-    if (p->additionalOffset == 0)
-    {
-      UInt32 processed;
-      if (!p->fastMode)
-      {
-        if (p->matchPriceCount >= (1 << 7))
-          FillDistancesPrices(p);
-        if (p->alignPriceCount >= kAlignTableSize)
-          FillAlignPrices(p);
-      }
-      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
-        break;
-      processed = nowPos32 - startPos32;
-      if (useLimits)
-      {
-        if (processed + kNumOpts + 300 >= maxUnpackSize ||
-            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
-          break;
-      }
-      else if (processed >= (1 << 17))
-      {
-        p->nowPos64 += nowPos32 - startPos32;
-        return CheckErrors(p);
-      }
-    }
-  }
-  p->nowPos64 += nowPos32 - startPos32;
-  return Flush(p, nowPos32);
-}
-
-#define kBigHashDicLimit ((UInt32)1 << 24)
-
-static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 beforeSize = kNumOpts;
-  if (!RangeEnc_Alloc(&p->rc, alloc))
-    return SZ_ERROR_MEM;
-
-  #ifndef _7ZIP_ST
-  p->mtMode = (p->multiThread && !p->fastMode && (p->matchFinderBase.btMode != 0));
-  #endif
-
-  {
-    unsigned lclp = p->lc + p->lp;
-    if (!p->litProbs || !p->saveState.litProbs || p->lclp != lclp)
-    {
-      LzmaEnc_FreeLits(p, alloc);
-      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, ((UInt32)0x300 << lclp) * sizeof(CLzmaProb));
-      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, ((UInt32)0x300 << lclp) * sizeof(CLzmaProb));
-      if (!p->litProbs || !p->saveState.litProbs)
-      {
-        LzmaEnc_FreeLits(p, alloc);
-        return SZ_ERROR_MEM;
-      }
-      p->lclp = lclp;
-    }
-  }
-
-  p->matchFinderBase.bigHash = (Byte)(p->dictSize > kBigHashDicLimit ? 1 : 0);
-
-  if (beforeSize + p->dictSize < keepWindowSize)
-    beforeSize = keepWindowSize - p->dictSize;
-
-  #ifndef _7ZIP_ST
-  if (p->mtMode)
-  {
-    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
-    p->matchFinderObj = &p->matchFinderMt;
-    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
-  }
-  else
-  #endif
-  {
-    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
-      return SZ_ERROR_MEM;
-    p->matchFinderObj = &p->matchFinderBase;
-    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
-  }
-
-  return SZ_OK;
-}
-
-void LzmaEnc_Init(CLzmaEnc *p)
-{
-  UInt32 i;
-  p->state = 0;
-  for (i = 0 ; i < LZMA_NUM_REPS; i++)
-    p->reps[i] = 0;
-
-  RangeEnc_Init(&p->rc);
-
-
-  for (i = 0; i < kNumStates; i++)
-  {
-    UInt32 j;
-    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
-    {
-      p->isMatch[i][j] = kProbInitValue;
-      p->isRep0Long[i][j] = kProbInitValue;
-    }
-    p->isRep[i] = kProbInitValue;
-    p->isRepG0[i] = kProbInitValue;
-    p->isRepG1[i] = kProbInitValue;
-    p->isRepG2[i] = kProbInitValue;
-  }
-
-  {
-    UInt32 num = (UInt32)0x300 << (p->lp + p->lc);
-    CLzmaProb *probs = p->litProbs;
-    for (i = 0; i < num; i++)
-      probs[i] = kProbInitValue;
-  }
-
-  {
-    for (i = 0; i < kNumLenToPosStates; i++)
-    {
-      CLzmaProb *probs = p->posSlotEncoder[i];
-      UInt32 j;
-      for (j = 0; j < (1 << kNumPosSlotBits); j++)
-        probs[j] = kProbInitValue;
-    }
-  }
-  {
-    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
-      p->posEncoders[i] = kProbInitValue;
-  }
-
-  LenEnc_Init(&p->lenEnc.p);
-  LenEnc_Init(&p->repLenEnc.p);
-
-  for (i = 0; i < (1 << kNumAlignBits); i++)
-    p->posAlignEncoder[i] = kProbInitValue;
-
-  p->optimumEndIndex = 0;
-  p->optimumCurrentIndex = 0;
-  p->additionalOffset = 0;
-
-  p->pbMask = (1 << p->pb) - 1;
-  p->lpMask = (1 << p->lp) - 1;
-}
-
-void LzmaEnc_InitPrices(CLzmaEnc *p)
-{
-  if (!p->fastMode)
-  {
-    FillDistancesPrices(p);
-    FillAlignPrices(p);
-  }
-
-  p->lenEnc.tableSize =
-  p->repLenEnc.tableSize =
-      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
-  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
-  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
-}
-
-static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  UInt32 i;
-  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
-    if (p->dictSize <= ((UInt32)1 << i))
-      break;
-  p->distTableSize = i * 2;
-
-  p->finished = False;
-  p->result = SZ_OK;
-  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
-  LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  p->nowPos64 = 0;
-  return SZ_OK;
-}
-
-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p->matchFinderBase.stream = inStream;
-  p->needInit = 1;
-  p->rc.outStream = outStream;
-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
-}
-
-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
-    ISeqInStream *inStream, UInt32 keepWindowSize,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  p->matchFinderBase.stream = inStream;
-  p->needInit = 1;
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
-{
-  p->matchFinderBase.directInput = 1;
-  p->matchFinderBase.bufferBase = (Byte *)src;
-  p->matchFinderBase.directInputRem = srcLen;
-}
-
-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
-    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  LzmaEnc_SetInputBuf(p, src, srcLen);
-  p->needInit = 1;
-
-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
-}
-
-void LzmaEnc_Finish(CLzmaEncHandle pp)
-{
-  #ifndef _7ZIP_ST
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  if (p->mtMode)
-    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
-  #else
-  UNUSED_VAR(pp);
-  #endif
-}
-
-
-typedef struct
-{
-  ISeqOutStream funcTable;
-  Byte *data;
-  SizeT rem;
-  Bool overflow;
-} CSeqOutStreamBuf;
-
-static size_t MyWrite(void *pp, const void *data, size_t size)
-{
-  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
-  if (p->rem < size)
-  {
-    size = p->rem;
-    p->overflow = True;
-  }
-  memcpy(p->data, data, size);
-  p->rem -= size;
-  p->data += size;
-  return size;
-}
-
-
-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
-}
-
-
-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
-{
-  const CLzmaEnc *p = (CLzmaEnc *)pp;
-  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
-}
-
-
-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  UInt64 nowPos64;
-  SRes res;
-  CSeqOutStreamBuf outStream;
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p->writeEndMark = False;
-  p->finished = False;
-  p->result = SZ_OK;
-
-  if (reInit)
-    LzmaEnc_Init(p);
-  LzmaEnc_InitPrices(p);
-  nowPos64 = p->nowPos64;
-  RangeEnc_Init(&p->rc);
-  p->rc.outStream = &outStream.funcTable;
-
-  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
-
-  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-
-  return res;
-}
-
-
-static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
-{
-  SRes res = SZ_OK;
-
-  #ifndef _7ZIP_ST
-  Byte allocaDummy[0x300];
-  allocaDummy[0] = 0;
-  allocaDummy[1] = allocaDummy[0];
-  #endif
-
-  for (;;)
-  {
-    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
-    if (res != SZ_OK || p->finished)
-      break;
-    if (progress)
-    {
-      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
-      if (res != SZ_OK)
-      {
-        res = SZ_ERROR_PROGRESS;
-        break;
-      }
-    }
-  }
-
-  LzmaEnc_Finish(p);
-
-  /*
-  if (res == S_OK && !Inline_MatchFinder_IsFinishedOK(&p->matchFinderBase))
-    res = SZ_ERROR_FAIL;
-  }
-  */
-
-  return res;
-}
-
-
-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
-    ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
-  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
-}
-
-
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
-{
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-  unsigned i;
-  UInt32 dictSize = p->dictSize;
-  if (*size < LZMA_PROPS_SIZE)
-    return SZ_ERROR_PARAM;
-  *size = LZMA_PROPS_SIZE;
-  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);
-
-  if (dictSize >= ((UInt32)1 << 22))
-  {
-    UInt32 kDictMask = ((UInt32)1 << 20) - 1;
-    if (dictSize < (UInt32)0xFFFFFFFF - kDictMask)
-      dictSize = (dictSize + kDictMask) & ~kDictMask;
-  }
-  else for (i = 11; i <= 30; i++)
-  {
-    if (dictSize <= ((UInt32)2 << i)) { dictSize = (2 << i); break; }
-    if (dictSize <= ((UInt32)3 << i)) { dictSize = (3 << i); break; }
-  }
-
-  for (i = 0; i < 4; i++)
-    props[1 + i] = (Byte)(dictSize >> (8 * i));
-  return SZ_OK;
-}
-
-
-SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  SRes res;
-  CLzmaEnc *p = (CLzmaEnc *)pp;
-
-  CSeqOutStreamBuf outStream;
-
-  outStream.funcTable.Write = MyWrite;
-  outStream.data = dest;
-  outStream.rem = *destLen;
-  outStream.overflow = False;
-
-  p->writeEndMark = writeEndMark;
-  p->rc.outStream = &outStream.funcTable;
-
-  res = LzmaEnc_MemPrepare(pp, src, srcLen, 0, alloc, allocBig);
-
-  if (res == SZ_OK)
-  {
-    res = LzmaEnc_Encode2(p, progress);
-    if (res == SZ_OK && p->nowPos64 != srcLen)
-      res = SZ_ERROR_FAIL;
-  }
-
-  *destLen -= outStream.rem;
-  if (outStream.overflow)
-    return SZ_ERROR_OUTPUT_EOF;
-  return res;
-}
-
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
-{
-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
-  SRes res;
-  if (!p)
-    return SZ_ERROR_MEM;
-
-  res = LzmaEnc_SetProps(p, props);
-  if (res == SZ_OK)
-  {
-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
-    if (res == SZ_OK)
-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
-          writeEndMark, progress, alloc, allocBig);
-  }
-
-  LzmaEnc_Destroy(p, alloc, allocBig);
-  return res;
-}
diff --git a/src/calibre_lzma/LzmaEnc.h b/src/calibre_lzma/LzmaEnc.h
deleted file mode 100644
index c2806b45f4..0000000000
--- a/src/calibre_lzma/LzmaEnc.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*  LzmaEnc.h -- LZMA Encoder
-2013-01-18 : Igor Pavlov : Public domain */
-
-#ifndef __LZMA_ENC_H
-#define __LZMA_ENC_H
-
-#include "7zTypes.h"
-
-EXTERN_C_BEGIN
-
-#define LZMA_PROPS_SIZE 5
-
-typedef struct _CLzmaEncProps
-{
-  int level;       /*  0 <= level <= 9 */
-  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
-                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
-                       default = (1 << 24) */
-  UInt64 reduceSize; /* estimated size of data that will be compressed. default = 0xFFFFFFFF.
-                        Encoder uses this value to reduce dictionary size */
-  int lc;          /* 0 <= lc <= 8, default = 3 */
-  int lp;          /* 0 <= lp <= 4, default = 0 */
-  int pb;          /* 0 <= pb <= 4, default = 2 */
-  int algo;        /* 0 - fast, 1 - normal, default = 1 */
-  int fb;          /* 5 <= fb <= 273, default = 32 */
-  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
-  int numHashBytes; /* 2, 3 or 4, default = 4 */
-  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
-  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
-  int numThreads;  /* 1 or 2, default = 2 */
-} CLzmaEncProps;
-
-void LzmaEncProps_Init(CLzmaEncProps *p);
-void LzmaEncProps_Normalize(CLzmaEncProps *p);
-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
-
-
-/* ---------- CLzmaEncHandle Interface ---------- */
-
-/* LzmaEnc_* functions can return the following exit codes:
-Returns:
-  SZ_OK           - OK
-  SZ_ERROR_MEM    - Memory allocation error
-  SZ_ERROR_PARAM  - Incorrect paramater in props
-  SZ_ERROR_WRITE  - Write callback error.
-  SZ_ERROR_PROGRESS - some break from progress callback
-  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
-*/
-
-typedef void * CLzmaEncHandle;
-
-CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
-void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
-SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-/* ---------- One Call Interface ---------- */
-
-/* LzmaEncode
-Return code:
-  SZ_OK               - OK
-  SZ_ERROR_MEM        - Memory allocation error
-  SZ_ERROR_PARAM      - Incorrect paramater
-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
-*/
-
-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
-
-EXTERN_C_END
-
-#endif
diff --git a/src/calibre_lzma/Precomp.h b/src/calibre_lzma/Precomp.h
deleted file mode 100644
index edb5814439..0000000000
--- a/src/calibre_lzma/Precomp.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* Precomp.h -- StdAfx
-2013-11-12 : Igor Pavlov : Public domain */
-
-#ifndef __7Z_PRECOMP_H
-#define __7Z_PRECOMP_H
-
-#include "Compiler.h"
-/* #include "7zTypes.h" */
-
-#endif
diff --git a/src/calibre_lzma/__init__.py b/src/calibre_lzma/__init__.py
deleted file mode 100644
index 437c828c1d..0000000000
--- a/src/calibre_lzma/__init__.py
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/usr/bin/env python
-# vim:fileencoding=utf-8
-
-
-__license__ = 'GPL v3'
-__copyright__ = '2015, Kovid Goyal <kovid at kovidgoyal.net>'
-
-
-
diff --git a/src/calibre_lzma/errors.py b/src/calibre_lzma/errors.py
deleted file mode 100644
index d81cfff05f..0000000000
--- a/src/calibre_lzma/errors.py
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/usr/bin/env python
-# vim:fileencoding=utf-8
-
-
-__license__ = 'GPL v3'
-__copyright__ = '2015, Kovid Goyal <kovid at kovidgoyal.net>'
-
-from calibre.constants import plugins
-
-lzma = plugins['lzma_binding'][0]
-if not lzma:
-    raise RuntimeError('Failed to load lzma_binding module with error: %s' % plugins['lzma_binding'][1])
-
-LzmaError = lzma.error
-
-class NotXZ(LzmaError):
-    pass
-
-class InvalidXZ(LzmaError):
-    pass
-
-class NotLzma(LzmaError):
-    pass
-
diff --git a/src/calibre_lzma/lzma1.py b/src/calibre_lzma/lzma1.py
deleted file mode 100644
index 8648211f28..0000000000
--- a/src/calibre_lzma/lzma1.py
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/usr/bin/env python
-# vim:fileencoding=utf-8
-
-
-__license__ = 'GPL v3'
-__copyright__ = '2015, Kovid Goyal <kovid at kovidgoyal.net>'
-
-from io import BytesIO
-from struct import unpack
-
-from calibre.ptempfile import SpooledTemporaryFile
-from .errors import NotLzma, lzma
-
-
-def read_header(f):
-    raw = f.read(13)
-    try:
-        props, dict_size, uncompressed_size = unpack(b'<BIQ', raw)
-    except Exception:
-        raise NotLzma('Not a LZMA file')
-    if props > (4 * 5 + 4) * 9 + 8:
-        raise NotLzma('Not a LZMA file')
-    return uncompressed_size, raw
-
-
-def decompress(raw, outfile=None, bufsize=10 * 1024 * 1024):
-    if isinstance(raw, bytes):
-        raw = BytesIO(raw)
-    uncompressed_size, header = read_header(raw)
-    outfile = outfile or SpooledTemporaryFile(50 * 1024 * 1024, '_lzma_decompress')
-    lzma.decompress(
-        raw.read, raw.seek, outfile.write, uncompressed_size, header, bufsize
-    )
-    if uncompressed_size < outfile.tell():
-        outfile.seek(uncompressed_size)
-        outfile.truncate()
-    return outfile
-
-
-if __name__ == '__main__':
-    import sys
-    decompress(open(sys.argv[-1], 'rb'))
diff --git a/src/calibre_lzma/lzma_binding.c b/src/calibre_lzma/lzma_binding.c
deleted file mode 100644
index 69b3612c43..0000000000
--- a/src/calibre_lzma/lzma_binding.c
+++ /dev/null
@@ -1,472 +0,0 @@
-/*
- * lzma_binding.c
- * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>
- *
- * Distributed under terms of the GPL3 license.
- */
-
-#define PY_SSIZE_T_CLEAN
-#define UNICODE
-#include "Python.h"
-#include "Lzma2Dec.h"
-#include "Lzma2Enc.h"
-#define UNUSED_VAR(x) (void)x;
-
-static void *Alloc(void *p, size_t size) { UNUSED_VAR(p); return PyMem_Malloc(size); }
-static void Free(void *p, void *address) { UNUSED_VAR(p); PyMem_Free(address); }
-static ISzAlloc allocator = { Alloc, Free };
-static const char* error_codes[18] = {
-    "OK",
-    "SZ_ERROR_DATA",
-    "SZ_ERROR_MEM",
-    "SZ_ERROR_CRC",
-    "SZ_ERROR_UNSUPPORTED",
-    "SZ_ERROR_PARAM",
-    "SZ_ERROR_INPUT_EOF",
-    "SZ_ERROR_OUTPUT_EOF",
-    "SZ_ERROR_READ",
-    "SZ_ERROR_WRITE",
-    "SZ_ERROR_PROGRESS",
-    "SZ_ERROR_FAIL",
-    "SZ_ERROR_THREAD",
-    "UNKNOWN", "UNKNOWN", "UNKNOWN",
-    "SZ_ERROR_ARCHIVE",
-    "SZ_ERROR_NO_ARCHIVE",
-};
-#define SET_ERROR(x) PyErr_SetString(LZMAError, ((x) > 0 && (x) < 17) ? error_codes[(x)] : "UNKNOWN")
-
-typedef struct {
-    ISeqInStream stream;
-    PyObject *read;
-    PyThreadState **thread_state;
-} InStream;
-
-typedef struct {
-    ISeqOutStream stream;
-    PyObject *write;
-    PyThreadState **thread_state;
-} OutStream;
-
-typedef struct {
-    ICompressProgress progress;
-    PyObject *callback;
-    PyThreadState **thread_state;
-} Progress;
-
-static PyObject *LZMAError = NULL;
-
-// Utils {{{
-static UInt64 crc64_table[256];
-
-#if PY_MAJOR_VERSION >= 3
-    #define BYTES_FMT "y#"
-#else
-    #define BYTES_FMT "s#"
-#endif
-
-static void init_crc_table() {
-    static const UInt64 poly64 = (UInt64)(0xC96C5795D7870F42);
-    size_t i, j;
-    for (i = 0; i < 256; ++i) {
-        UInt64 crc64 = i;
-        for (j = 0; j < 8; ++j) {
-            if (crc64 & 1)
-                crc64 = (crc64 >> 1) ^ poly64;
-            else
-                crc64 >>= 1;
-        }
-        crc64_table[i] = crc64;
-    }
-}
-
-static PyObject *
-crc64(PyObject *self, PyObject *args) {
-    unsigned char *data = NULL;
-    Py_ssize_t size = 0;
-    UInt64 crc = 0;
-    size_t i;
-    if (!PyArg_ParseTuple(args, BYTES_FMT "|K", &data, &size, &crc)) return NULL;
-    crc = ~crc;
-    for (i = 0; i < (size_t)size; ++i)
-        crc = crc64_table[data[i] ^ (crc & 0xFF)] ^ (crc >> 8);
-
-    return Py_BuildValue("K", ~crc);
-}
-
-static PyObject*
-delta_decode(PyObject *self, PyObject *args) {
-    PyObject *array = NULL, *histarray = NULL;
-    unsigned char *data = NULL, pos = 0, *history = NULL;
-    unsigned int distance = 0;
-    Py_ssize_t datalen = 0, i;
-    if (!PyArg_ParseTuple(args, "O!O!BB", &PyByteArray_Type, &array, &PyByteArray_Type, &histarray, &pos, &distance)) return NULL;
-    if (PyByteArray_GET_SIZE(histarray) != 256) {
-        PyErr_SetString(PyExc_TypeError, "histarray must be 256 bytes long");
-        return NULL;
-    }
-    data = (unsigned char*)PyByteArray_AS_STRING(array); history = (unsigned char*)PyByteArray_AS_STRING(histarray);
-    datalen = PyBytes_GET_SIZE(array);
-
-    for (i = 0; i < datalen; i++) {
-        data[i] += history[(unsigned char)(pos + distance)];
-        history[pos--] = data[i];
-    }
-    return Py_BuildValue("B", pos);
-}
-// }}}
-
-// LZMA2 decompress {{{
-static PyObject *
-decompress2(PyObject *self, PyObject *args) {
-    PyObject *read = NULL, *seek = NULL, *write = NULL, *rres = NULL;
-    SizeT bufsize = 0, bytes_written = 0, bytes_read = 0, inbuf_pos = 0, inbuf_len = 0;
-    Py_ssize_t leftover = 0;
-    unsigned char props = 0;
-    char *inbuf = NULL, *outbuf = NULL;
-    CLzma2Dec state;
-    SRes res = SZ_OK;
-    ELzmaStatus status = LZMA_STATUS_NOT_FINISHED;
-
-    if (!PyArg_ParseTuple(args, "OOOBk", &read, &seek, &write, &props, &bufsize)) return NULL;
-
-    Lzma2Dec_Construct(&state);
-    res = Lzma2Dec_Allocate(&state, (Byte)props, &allocator);
-    if (res == SZ_ERROR_MEM) { PyErr_NoMemory(); return NULL; }
-    if (res != SZ_OK) { PyErr_SetString(PyExc_TypeError, "Incorrect stream properties"); goto exit; }
-    inbuf = (char*)PyMem_Malloc(bufsize);
-    outbuf = (char*)PyMem_Malloc(bufsize);
-    if (!inbuf || !outbuf) {PyErr_NoMemory(); goto exit;}
-
-    Lzma2Dec_Init(&state);
-
-    while (status != LZMA_STATUS_FINISHED_WITH_MARK) {
-        bytes_written = bufsize; bytes_read = inbuf_len - inbuf_pos;
-        if (bytes_read) {
-            Py_BEGIN_ALLOW_THREADS;
-            res = Lzma2Dec_DecodeToBuf(&state, (Byte*)outbuf, &bytes_written, (Byte*)(inbuf) + inbuf_pos, &bytes_read, LZMA_FINISH_ANY, &status);
-            Py_END_ALLOW_THREADS;
-        } else { res = SZ_OK; bytes_written = 0; status = LZMA_STATUS_NEEDS_MORE_INPUT; }
-        if (res != SZ_OK) { SET_ERROR(res); goto exit; }
-        if (bytes_written > 0) {
-            if(!PyObject_CallFunction(write, BYTES_FMT, outbuf, bytes_written)) goto exit;
-        }
-        if (inbuf_len > inbuf_pos && !bytes_read && !bytes_written && status != LZMA_STATUS_NEEDS_MORE_INPUT && status != LZMA_STATUS_FINISHED_WITH_MARK) {
-            SET_ERROR(SZ_ERROR_DATA); goto exit;
-        }
-        if (bytes_read > 0) inbuf_pos += bytes_read;
-        if (status == LZMA_STATUS_NEEDS_MORE_INPUT) {
-            leftover = inbuf_len - inbuf_pos;
-            inbuf_pos = 0;
-            if (!PyObject_CallFunction(seek, "ii", -leftover, SEEK_CUR)) goto exit;
-            rres = PyObject_CallFunction(read, "n", bufsize);
-            if (rres == NULL) goto exit;
-            inbuf_len = PyBytes_GET_SIZE(rres);
-            if (inbuf_len == 0) { PyErr_SetString(LZMAError, "LZMA2 block was truncated"); goto exit; }
-            memcpy(inbuf, PyBytes_AS_STRING(rres), inbuf_len);
-            Py_DECREF(rres); rres = NULL;
-        }
-    }
-    leftover = inbuf_len - inbuf_pos;
-    if (leftover > 0) {
-        if (!PyObject_CallFunction(seek, "ii", -leftover, SEEK_CUR)) goto exit;
-    }
-
-
-exit:
-    Lzma2Dec_Free(&state, &allocator);
-    PyMem_Free(inbuf); PyMem_Free(outbuf);
-    if (PyErr_Occurred()) return NULL;
-    Py_RETURN_NONE;
-}
-// }}}
-
-// LZMA1 decompress {{{
-static PyObject*
-decompress(PyObject *self, PyObject *args) {
-    PyObject *read = NULL, *seek = NULL, *write = NULL, *rres = NULL;
-    UInt64 decompressed_size = 0;
-    int size_known = 0;
-    Py_ssize_t header_size = 0, leftover = 0;
-    unsigned char *header = NULL, *inbuf = NULL, *outbuf = NULL;
-    CLzmaDec state;
-    SRes res = 0;
-    SizeT bufsize = 0, bytes_written = 0, bytes_read = 0, inbuf_pos = 0, inbuf_len = 0, total_written = 0;
-    ELzmaStatus status = LZMA_STATUS_NOT_FINISHED;
-    ELzmaFinishMode finish_mode = LZMA_FINISH_ANY;
-
-    if(!PyArg_ParseTuple(args, "OOOK" BYTES_FMT "k", &read, &seek, &write, &decompressed_size, &header, &header_size, &bufsize)) return NULL;
-    size_known = (decompressed_size != (UInt64)(Int64)-1);
-    if (header_size != 13) { PyErr_SetString(LZMAError, "Header must be exactly 13 bytes long"); return NULL; }
-    if (!decompressed_size) { PyErr_SetString(LZMAError, "Cannot decompress empty file"); return NULL; }
-
-    LzmaDec_Construct(&state);
-    res = LzmaDec_Allocate(&state, header, LZMA_PROPS_SIZE, &allocator);
-    if (res == SZ_ERROR_MEM) { PyErr_NoMemory(); return NULL; }
-    if (res != SZ_OK) { PyErr_SetString(PyExc_TypeError, "Incorrect stream properties"); goto exit; }
-    inbuf = (unsigned char*)PyMem_Malloc(bufsize);
-    outbuf = (unsigned char*)PyMem_Malloc(bufsize);
-    if (!inbuf || !outbuf) {PyErr_NoMemory(); goto exit;}
-
-    LzmaDec_Init(&state);
-
-    while (status != LZMA_STATUS_FINISHED_WITH_MARK) {
-        bytes_written = bufsize; bytes_read = inbuf_len - inbuf_pos;
-        if (bytes_read) {
-            Py_BEGIN_ALLOW_THREADS;
-            finish_mode = LZMA_FINISH_ANY;
-            if (size_known && total_written + bufsize > decompressed_size) finish_mode = LZMA_FINISH_END;
-            res = LzmaDec_DecodeToBuf(&state, (Byte*)outbuf, &bytes_written, (Byte*)(inbuf) + inbuf_pos, &bytes_read, finish_mode, &status);
-            Py_END_ALLOW_THREADS;
-        } else { res = SZ_OK; bytes_written = 0; status = LZMA_STATUS_NEEDS_MORE_INPUT; }
-        if (res != SZ_OK) { SET_ERROR(res); goto exit; }
-        if (bytes_written > 0) {
-            if(!PyObject_CallFunction(write, BYTES_FMT, outbuf, bytes_written)) goto exit;
-            total_written += bytes_written;
-        }
-        if (inbuf_len > inbuf_pos && !bytes_read && !bytes_written && status != LZMA_STATUS_NEEDS_MORE_INPUT && status != LZMA_STATUS_FINISHED_WITH_MARK) {
-            SET_ERROR(SZ_ERROR_DATA); goto exit;
-        }
-        if (bytes_read > 0) inbuf_pos += bytes_read;
-        if (size_known && total_written >= decompressed_size) break;
-        if (status == LZMA_STATUS_NEEDS_MORE_INPUT) {
-            leftover = inbuf_len - inbuf_pos;
-            inbuf_pos = 0;
-            if (!PyObject_CallFunction(seek, "ii", -leftover, SEEK_CUR)) goto exit;
-            rres = PyObject_CallFunction(read, "n", bufsize);
-            if (rres == NULL) goto exit;
-            inbuf_len = PyBytes_GET_SIZE(rres);
-            if (inbuf_len == 0) { PyErr_SetString(LZMAError, "LZMA block was truncated"); goto exit; }
-            memcpy(inbuf, PyBytes_AS_STRING(rres), inbuf_len);
-            Py_DECREF(rres); rres = NULL;
-        }
-    }
-    leftover = inbuf_len - inbuf_pos;
-    if (leftover > 0) {
-        if (!PyObject_CallFunction(seek, "ii", -leftover, SEEK_CUR)) goto exit;
-    }
-
-exit:
-    LzmaDec_Free(&state, &allocator);
-    PyMem_Free(inbuf); PyMem_Free(outbuf);
-    if (PyErr_Occurred()) return NULL;
-    Py_RETURN_NONE;
-}
-
-// }}}
-
-// LZMA2 Compress {{{
-static void
-init_props(CLzma2EncProps *props, int preset) {
-    int level = (preset < 0) ? 0 : ((preset > 9) ? 9 : preset);
-    props->blockSize = 0;
-    props->numBlockThreads = 1;
-    props->numTotalThreads = 1;
-    props->lzmaProps.numThreads = 1;
-    props->lzmaProps.writeEndMark = 1;
-
-    props->lzmaProps.level = level;
-    props->lzmaProps.dictSize = 0;
-    props->lzmaProps.reduceSize = 0xFFFFFFFF;
-    props->lzmaProps.lc = -1;
-    props->lzmaProps.lp = -1;
-    props->lzmaProps.pb = -1;
-    props->lzmaProps.algo = -1;
-    props->lzmaProps.fb = -1;
-    props->lzmaProps.btMode = -1;
-    props->lzmaProps.numHashBytes = -1;
-    props->lzmaProps.mc = 0;
-}
-
-#define ACQUIRE_GIL PyEval_RestoreThread(*(self->thread_state)); *(self->thread_state) = NULL;
-#define RELEASE_GIL *(self->thread_state) = PyEval_SaveThread();
-
-static SRes iread(void *p, void *buf, size_t *size) {
-    InStream *self = (InStream*)p;
-    PyObject *res = NULL;
-    char *str = NULL;
-    if (*size == 0) return SZ_OK;
-    ACQUIRE_GIL
-    res = PyObject_CallFunction(self->read, "n", size);
-    if (res == NULL) return SZ_ERROR_READ;
-    str = PyBytes_AsString(res);
-    if (str == NULL) { Py_DECREF(res); return SZ_ERROR_READ; }
-    *size = PyBytes_Size(res);
-    if(*size) memcpy(buf, str, *size);
-    Py_DECREF(res);
-    RELEASE_GIL
-    return SZ_OK;
-}
-
-static size_t owrite(void *p, const void *buf, size_t size) {
-    OutStream *self = (OutStream*)p;
-    PyObject *res = NULL;
-    if (!size) return 0;
-    ACQUIRE_GIL
-    res = PyObject_CallFunction(self->write, BYTES_FMT, (char*)buf, size);
-    if (res == NULL) return 0;
-    Py_DECREF(res);
-    RELEASE_GIL
-    return size;
-}
-
-static SRes report_progress(void *p, UInt64 in_size, UInt64 out_size) {
-    Progress *self = (Progress*)p;
-    PyObject *res = NULL;
-    if (!self->callback) return SZ_OK;
-    ACQUIRE_GIL
-    res = PyObject_CallFunction(self->callback, "KK", in_size, out_size);
-    if (!res || !PyObject_IsTrue(res)) { Py_DECREF(res); return SZ_ERROR_PROGRESS; }
-    Py_DECREF(res);
-    RELEASE_GIL
-    return SZ_OK;
-}
-
-static PyObject*
-get_lzma2_properties(int preset) {
-    CLzma2EncHandle lzma2 = NULL;
-    CLzma2EncProps props;
-    Byte props_out = 0;
-    SRes res = SZ_OK;
-    lzma2 = Lzma2Enc_Create(&allocator, &allocator);
-    if (lzma2 == NULL) { PyErr_NoMemory(); goto exit; }
-
-    // Initialize parameters based on the preset
-    init_props(&props, preset);
-    res = Lzma2Enc_SetProps(lzma2, &props);
-    if (res != SZ_OK) { SET_ERROR(res); goto exit; }
-    props_out = Lzma2Enc_WriteProperties(lzma2);
-exit:
-    if (lzma2) Lzma2Enc_Destroy(lzma2);
-    if (PyErr_Occurred()) return NULL;
-    return Py_BuildValue(BYTES_FMT, &props_out, 1);
-}
-
-
-static PyObject*
-compress(PyObject *self, PyObject *args) {
-    PyObject *read = NULL, *write = NULL, *progress_callback = NULL;
-    CLzma2EncHandle lzma2 = NULL;
-    CLzma2EncProps props;
-    int preset = 5;
-    InStream in_stream;
-    OutStream out_stream;
-    Progress progress;
-    SRes res = SZ_OK;
-    Byte props_out = 0;
-    PyThreadState *ts = NULL;
-
-    if (!PyArg_ParseTuple(args, "OO|Oi", &read, &write, &progress_callback, &preset)) return NULL;
-    if (progress_callback && !PyCallable_Check(progress_callback)) progress_callback = NULL;
-
-    lzma2 = Lzma2Enc_Create(&allocator, &allocator);
-    if (lzma2 == NULL) { PyErr_NoMemory(); goto exit; }
-
-    // Initialize parameters based on the preset
-    init_props(&props, preset);
-    res = Lzma2Enc_SetProps(lzma2, &props);
-    if (res != SZ_OK) { SET_ERROR(res); goto exit; }
-
-    // Write the dict size to the output stream
-    props_out = Lzma2Enc_WriteProperties(lzma2);
-
-    // Create the streams and progress callback
-    in_stream.stream.Read = iread;
-    in_stream.read = read;
-    out_stream.stream.Write = owrite;
-    out_stream.write = write;
-    progress.progress.Progress = report_progress;
-    progress.callback = progress_callback;
-
-    // Run the compressor
-    ts = PyEval_SaveThread();
-    in_stream.thread_state = &ts;
-    out_stream.thread_state = &ts;
-    progress.thread_state = &ts;
-    res = Lzma2Enc_Encode(lzma2, (ISeqOutStream*)&out_stream, (ISeqInStream*)&in_stream, (ICompressProgress*)&progress);
-    if (res != SZ_OK && !PyErr_Occurred()) SET_ERROR(res);
-    if (ts) PyEval_RestoreThread(ts);
-exit:
-    if (lzma2) Lzma2Enc_Destroy(lzma2);
-    if (PyErr_Occurred()) return NULL;
-    return Py_BuildValue(BYTES_FMT, &props_out, 1);
-}
-
-// }}}
-
-static char lzma_binding_doc[] = "Bindings to the LZMA (de)compression C code";
-
-static PyMethodDef lzma_binding_methods[] = {
-    {"decompress2", decompress2, METH_VARARGS,
-        "Decompress an LZMA2 encoded block, of unknown compressed size (reads till LZMA2 EOS marker)"
-    },
-
-    {"compress", compress, METH_VARARGS,
-        "Compress data into an LZMA2 block, writing it to outfile. Returns the LZMA2 properties as a bytestring."
-    },
-
-    {"decompress", decompress, METH_VARARGS,
-        "Decompress an LZMA encoded block, of (un)known size (reads till LZMA EOS marker when size unknown)"
-    },
-
-    {"crc64", crc64, METH_VARARGS,
-        "crc64(bytes) -> CRC 64 for the provided python bytes object"
-    },
-
-    {"delta_decode", delta_decode, METH_VARARGS,
-        "delta_decode(rawarray, histarray, pos, distance) -> Apply the delta decode filter to the bytearray rawarray"
-    },
-
-    {NULL, NULL, 0, NULL}
-};
-
-#if PY_MAJOR_VERSION >= 3
-#define INITERROR return NULL
-#define INITMODULE PyModule_Create(&lzma_binding_module)
-static struct PyModuleDef lzma_binding_module = {
-    /* m_base     */ PyModuleDef_HEAD_INIT,
-    /* m_name     */ "lzma_binding",
-    /* m_doc      */ lzma_binding_doc,
-    /* m_size     */ -1,
-    /* m_methods  */ lzma_binding_methods,
-    /* m_slots    */ 0,
-    /* m_traverse */ 0,
-    /* m_clear    */ 0,
-    /* m_free     */ 0,
-};
-CALIBRE_MODINIT_FUNC PyInit_lzma_binding(void) {
-#else
-#define INITERROR return
-#define INITMODULE Py_InitModule3("lzma_binding", lzma_binding_methods, lzma_binding_doc)
-CALIBRE_MODINIT_FUNC initlzma_binding(void) {
-#endif
-
-    PyObject *m = NULL, *preset_map = NULL, *temp = NULL;
-    int i = 0;
-    init_crc_table();
-    LZMAError = PyErr_NewException("lzma_binding.error", NULL, NULL);
-    if (!LZMAError) {
-        INITERROR;
-    }
-    m = INITMODULE;
-    if (m == NULL) {
-        INITERROR;
-    }
-    preset_map = PyTuple_New(10);
-    if (preset_map == NULL) {
-        INITERROR;
-    }
-    for (i = 0; i < 10; i++) {
-        temp = get_lzma2_properties(i);
-        if (temp == NULL) {
-            INITERROR;
-        }
-        PyTuple_SET_ITEM(preset_map, i, temp);
-    }
-    PyModule_AddObject(m, "preset_map", preset_map);
-    Py_INCREF(LZMAError);
-    PyModule_AddObject(m, "error", LZMAError);
-
-#if PY_MAJOR_VERSION >= 3
-    return m;
-#endif
-}
diff --git a/src/calibre_lzma/xz.py b/src/calibre_lzma/xz.py
deleted file mode 100644
index ab07098400..0000000000
--- a/src/calibre_lzma/xz.py
+++ /dev/null
@@ -1,503 +0,0 @@
-#!/usr/bin/env python
-# vim:fileencoding=utf-8
-
-
-__license__ = 'GPL v3'
-__copyright__ = '2015, Kovid Goyal <kovid at kovidgoyal.net>'
-
-# See http://tukaani.org/xz/xz-file-format.txt for file format details
-
-from collections import namedtuple
-from io import BytesIO
-from hashlib import sha256
-from struct import unpack, error as struct_error, pack
-from binascii import crc32 as _crc32
-
-from calibre.ptempfile import SpooledTemporaryFile
-from .errors import NotXZ, InvalidXZ, lzma
-from polyglot.builtins import error_message
-
-HEADER_MAGIC = b'\xfd7zXZ\0'
-FOOTER_MAGIC = b'YZ'
-DELTA_FILTER_ID = 0x03
-LZMA2_FILTER_ID = 0x21
-
-
-def align(raw):
-    extra = len(raw) % 4
-    if extra:
-        raw += b'\0' * (4 - extra)
-    return raw
-
-
-def as_bytes(*args):
-    return bytes(bytearray(args))
-
-
-def crc32(raw, start=0):
-    return 0xFFFFFFFF & _crc32(raw, start)
-
-
-def decode_var_int(f):
-    ans, i, ch = 0, -1, 0x80
-    while ch >= 0x80:
-        ch = ord(f.read(1))
-        i += 1
-        if ch == 0:
-            return 0
-        ans |= (ch & 0x7f) << (i * 7)
-    return ans
-
-
-def decode_var_int2(raw, pos):
-    ans, ch, opos = 0, 0x80, pos
-    while ch >= 0x80:
-        ch = ord(raw[pos:pos+1])
-        if ch == 0:
-            return 0, pos
-        ans |= (ch & 0x7f) << ((pos - opos) * 7)
-        pos += 1
-    return ans, pos
-
-
-def encode_var_int(num):
-    if num == 0:
-        return b'\0'
-    buf = bytearray()
-    a = buf.append
-    while num != 0:
-        a(0x80 | (num & 0x7F))
-        num >>= 7
-    buf[-1] &= 0x7F
-    return bytes(buf)
-
-
-def read_stream_header(f):
-    try:
-        magic, stream_flags1, stream_flags2, crc = unpack(b'<6s2BI', f.read(12))
-    except struct_error as e:
-        raise NotXZ('Not an XZ file. Invalid stream header: ' % e)
-    if magic != HEADER_MAGIC:
-        raise NotXZ('Not an XZ file. Header Magic is: %r' % magic)
-    if stream_flags1 != 0:
-        raise InvalidXZ('Stream flags first byte is not null')
-    check_type, reserved = 0x0f & stream_flags2, 0xf0 & stream_flags2
-    if reserved != 0:
-        raise InvalidXZ('Stream flags reserved bits not null')
-    if crc32(bytes(bytearray([stream_flags1, stream_flags2]))) != crc:
-        raise InvalidXZ('Stream flags header CRC incorrect')
-    return check_type
-
-
-class CRCChecker(object):
-
-    def __init__(self, check_type):
-        self.code = 0
-        if check_type == 0x1:
-            self.func = crc32
-            self.size = 4
-            self.fmt = b'<I'
-        else:
-            self.func = lzma.crc64
-            self.size = 8
-            self.fmt = b'<Q'
-
-    def __call__(self, raw):
-        self.code = self.func(raw, self.code)
-
-    def finish(self):
-        if self.func is not crc32:
-            self.code = 0xFFFFFFFFFFFFFFFF & self.code
-
-    @property
-    def code_as_bytes(self):
-        return pack(self.fmt, self.code)
-
-    def check(self, raw):
-        return self.code == unpack(self.fmt, raw)[0]
-
-
-class Sha256Checker(object):
-
-    def __init__(self, *args):
-        self.h = sha256()
-        self.func = self.h.update
-        self.code = None
-        self.size = 32
-
-    def __call__(self, raw):
-        self.func(raw)
-
-    def finish(self):
-        self.code = self.code_as_bytes = self.h.digest()
-        self.h = self.func = None
-
-    def check(self, raw):
-        return self.code == raw
-
-
-class DummyChecker(object):
-
-    size = 0
-    code_as_bytes = None
-
-    def __init__(self, *args):
-        pass
-
-    def __call__(self, raw):
-        pass
-
-    def finish(self):
-        pass
-
-
-class LZMA2Filter(object):
-
-    BUFSIZE = 10  # MB
-
-    def __init__(self, props, check_type, bufsize=None):
-        if len(props) != 1:
-            raise InvalidXZ('Invalid properties length for LZMA2 filter')
-        props = ord(props)
-        self.dictionary_size = props & 0x3F
-        if props & 0xC0 != 0:
-            raise InvalidXZ('Invalid high bytes for LZMA2 filter properties')
-        self.props = props
-        if check_type in (0x1, 0x4):
-            self.crc = CRCChecker(check_type)
-        elif check_type == 0x0A:
-            self.crc = Sha256Checker()
-        else:
-            if check_type:
-                raise InvalidXZ('Unsupported CRC check type: %s' % check_type)
-            self.crc = DummyChecker()
-        if bufsize is None:
-            bufsize = self.BUFSIZE
-        self.bufsize = int(bufsize * 1024 * 1024)
-
-    def __call__(self, f, outfile, filters=()):
-        w = outfile.write
-        c = self.crc
-
-        def write(raw):
-            if filters:
-                raw = bytearray(raw)
-                for flt in filters:
-                    raw = flt(raw)
-                raw = bytes(raw)
-            w(raw), c(raw)
-
-        try:
-            lzma.decompress2(f.read, f.seek, write, self.props, self.bufsize)
-        except lzma.error as e:
-            raise InvalidXZ(
-                'Failed to decode LZMA2 block with error code: %s' % error_message(e)
-            )
-        self.crc.finish()
-
-
-class DeltaFilter(object):
-
-    def __init__(self, props, *args):
-        if len(props) != 1:
-            raise InvalidXZ('Invalid properties length for Delta filter')
-        self.distance = ord(props) + 1
-        self.pos = 0
-        self.history = bytearray(256)
-
-    def __call__(self, raw):
-        self.pos = lzma.delta_decode(raw, self.history, self.pos, self.distance)
-        return raw
-
-
-def test_delta_filter():
-    raw = b'\xA1\xB1\x01\x02\x01\x02\x01\x02'
-    draw = b'\xA1\xB1\xA2\xB3\xA3\xB5\xA4\xB7'
-
-    def eq(s, d):
-        if s != d:
-            raise ValueError('%r != %r' % (s, d))
-
-    eq(draw, bytes(DeltaFilter(b'\x01')(bytearray(raw))))
-    f = DeltaFilter(b'\x01')
-    for ch, dch in zip(raw, draw):
-        eq(dch, bytes(f(bytearray(ch))))
-
-
-Block = namedtuple('Block', 'unpadded_size uncompressed_size')
-
-
-def read_block_header(f, block_header_size_, check_type):
-    block_header_size = 4 * (ord(block_header_size_) + 1)
-    if block_header_size < 8:
-        raise InvalidXZ('Invalid block header size: %d' % block_header_size)
-    header, crc = unpack(
-        b'<%dsI' % (block_header_size - 5), f.read(block_header_size - 1)
-    )
-    if crc != crc32(block_header_size_ + header):
-        raise InvalidXZ('Block header CRC mismatch')
-    block_flags = ord(header[0:1])
-    number_of_filters = (0x03 & block_flags) + 1
-    if not (0 < number_of_filters <= 4):
-        raise InvalidXZ('Invalid number of filters: %d' % number_of_filters)
-    if block_flags & 0x3c != 0:
-        raise InvalidXZ('Non-zero reserved bits in block flags')
-    has_compressed_size = block_flags & 0x40
-    has_uncompressed_size = block_flags & 0x80
-    compressed_size = uncompressed_size = None
-    pos = 1
-    if has_compressed_size:
-        compressed_size, pos = decode_var_int2(header, pos)
-    if has_uncompressed_size:
-        uncompressed_size, pos = decode_var_int2(header, pos)
-    filters = []
-    while number_of_filters:
-        number_of_filters -= 1
-        filter_id, pos = decode_var_int2(header, pos)
-        size_of_properties, pos = decode_var_int2(header, pos)
-        if filter_id >= 0x4000000000000000:
-            raise InvalidXZ('Invalid filter id: %d' % filter_id)
-        if filter_id not in (LZMA2_FILTER_ID, DELTA_FILTER_ID):
-            raise InvalidXZ('Unsupported filter ID: 0x%x' % filter_id)
-        props = header[pos:pos + size_of_properties]
-        pos += size_of_properties
-        if len(props) != size_of_properties:
-            raise InvalidXZ('Incomplete filter properties')
-        if filter_id == LZMA2_FILTER_ID and number_of_filters:
-            raise InvalidXZ('LZMA2 filter must be the last filter')
-        elif filter_id == DELTA_FILTER_ID and not number_of_filters:
-            raise InvalidXZ('Delta filter cannot be the last filter')
-        filters.append(
-            (LZMA2Filter
-             if filter_id == LZMA2_FILTER_ID else DeltaFilter)(props, check_type)
-        )
-    padding = header[pos:]
-    if padding.lstrip(b'\0'):
-        raise InvalidXZ('Non-null block header padding: %r' % padding)
-    filters.reverse()
-    return filters, compressed_size, uncompressed_size
-
-
-def read_block(f, block_header_size_, check_type, outfile):
-    start_pos = f.tell() - 1
-    filters, compressed_size, uncompressed_size = read_block_header(
-        f, block_header_size_, check_type
-    )
-    fpos, opos = f.tell(), outfile.tell()
-    filters[0](f, outfile, filters[1:])
-    actual_compressed_size = f.tell() - fpos
-    uncompressed_actual_size = outfile.tell() - opos
-    if uncompressed_size is not None and uncompressed_size != uncompressed_actual_size:
-        raise InvalidXZ('Uncompressed size for block does not match')
-    if compressed_size is not None and compressed_size != actual_compressed_size:
-        raise InvalidXZ('Compressed size for block does not match')
-    padding_count = f.tell() % 4
-    if padding_count:
-        padding_count = 4 - padding_count
-        padding = f.read(padding_count)
-        if len(padding) != padding_count:
-            raise InvalidXZ('Block is not aligned')
-        if padding.lstrip(b'\0'):
-            raise InvalidXZ('Block padding has non null bytes')
-    if check_type:
-        q = f.read(filters[0].crc.size)
-        if not filters[0].crc.check(q):
-            raise InvalidXZ('CRC for data does not match')
-    return Block(f.tell() - padding_count - start_pos, uncompressed_actual_size)
-
-
-def read_index(f):
-    pos = f.tell() - 1
-    number_of_records = decode_var_int(f)
-    while number_of_records:
-        number_of_records -= 1
-        unpadded_size = decode_var_int(f)
-        if unpadded_size < 1:
-            raise InvalidXZ('Invalid unpadded size in index: %d' % unpadded_size)
-        yield Block(unpadded_size, decode_var_int(f))
-    if f.tell() % 4:
-        padding_count = 4 - f.tell() % 4
-        padding = f.read(padding_count)
-        if len(padding) != padding_count or padding.lstrip(b'\0'):
-            raise InvalidXZ('Incorrect Index padding')
-    epos = f.tell()
-    f.seek(pos)
-    raw = f.read(epos - pos)
-    crc, = unpack(b'<I', f.read(4))
-    if crc != crc32(raw):
-        raise InvalidXZ('Index field CRC mismatch')
-
-
-def read_stream_footer(f, check_type, index_size):
-    crc, = unpack(b'<I', f.read(4))
-    raw = f.read(6)
-    backward_size, stream_flags1, stream_flags2 = unpack(b'<I2B', raw)
-    if stream_flags1 != 0 or stream_flags2 & 0xf0 != 0 or stream_flags2 & 0xf != check_type:
-        raise InvalidXZ('Footer stream flags != header stream flags')
-    backward_size = 4 * (1 + backward_size)
-    if backward_size != index_size:
-        raise InvalidXZ('Footer backward size != actual index size')
-    if f.read(2) != FOOTER_MAGIC:
-        raise InvalidXZ('Stream footer has incorrect magic bytes')
-    if crc != crc32(raw):
-        raise InvalidXZ('Stream footer CRC mismatch')
-
-
-def read_stream(f, outfile):
-    check_type = read_stream_header(f)
-    blocks, index = [], None
-    index_size = 0
-    while True:
-        sz = f.read(1)
-        if sz == b'\0':
-            pos = f.tell() - 1
-            index = tuple(read_index(f))
-            index_size = f.tell() - pos
-            break
-        else:
-            blocks.append(read_block(f, sz, check_type, outfile))
-    if index != tuple(blocks):
-        raise InvalidXZ('Index does not match actual blocks in file')
-    read_stream_footer(f, check_type, index_size)
-
-
-def decompress(raw, outfile=None):
-    '''
-    Decompress the specified data.
-
-    :param raw: A bytestring or a file-like object open for reading
-    :outfile: A file like object open for writing.
-              The decompressed data is written into it. If not specified then a SpooledTemporaryFile
-              is created and returned by this function.
-    '''
-    if isinstance(raw, bytes):
-        raw = BytesIO(raw)
-    outfile = outfile or SpooledTemporaryFile(50 * 1024 * 1024, '_xz_decompress')
-    while True:
-        read_stream(raw, outfile)
-        pos = raw.tell()
-        trail = raw.read(1024)
-        if len(trail) < 20:
-            break
-        idx = trail.find(HEADER_MAGIC)
-        if idx == -1:
-            break
-        if idx > -1:
-            # Found another stream
-            raw.seek(pos)
-            if idx:
-                padding = raw.read(idx)
-                if padding.lstrip(b'\0') or len(padding) % 4:
-                    raise InvalidXZ('Found trailing garbage between streams')
-    return outfile
-
-
-def compress(raw, outfile=None, level=5, check_type='crc64'):
-    '''
-    Compress the specified data into a .xz stream (which can be written directly as
-    an .xz file.
-
-    :param raw: A bytestring or a file-like object open for reading
-    :outfile: A file like object open for writing.
-              The .xz stream is written into it. If not specified then a SpooledTemporaryFile
-              is created and returned by this function.
-    :level: An integer between 0 and 9 with 0 being fastest/worst compression and 9 being
-            slowest/best compression
-    :check_type: The type of data integrity check to write into the output .xz stream.
-                 Should be one of: 'crc32', 'crc64', 'sha256', or None
-    '''
-    if isinstance(raw, bytes):
-        raw = BytesIO(raw)
-    outfile = outfile or SpooledTemporaryFile(50 * 1024 * 1024, '_xz_decompress')
-
-    # Write stream header
-    outfile.write(HEADER_MAGIC)
-    check_type = {
-        'crc': 1,
-        'crc32': 1,
-        'sha256': 0xa,
-        None: 0,
-        '': 0,
-        'none': 0,
-        'None': 0
-    }.get(check_type, 4)
-    stream_flags = as_bytes(0, check_type)
-    outfile.write(stream_flags)
-    outfile.write(pack(b'<I', crc32(stream_flags)))
-
-    # Write block header
-    filter_flags = encode_var_int(LZMA2_FILTER_ID
-                                  ) + encode_var_int(1) + lzma.preset_map[level]
-    block_header = align(b'\0\0' + filter_flags)
-    bhs = ((4 + len(block_header)) // 4) - 1
-    block_header = as_bytes(bhs) + block_header[1:]
-    block_header += pack(b'<I', crc32(block_header))
-    start = outfile.tell()
-    outfile.write(block_header)
-
-    # Write compressed data and check
-    checker = {
-        0: DummyChecker,
-        1: CRCChecker,
-        4: CRCChecker,
-        0xa: Sha256Checker
-    }[check_type](check_type)
-    uncompressed_size = [0]
-
-    def read(n):
-        ans = raw.read(n)
-        if ans:
-            uncompressed_size[0] += len(ans)
-            checker(ans)
-        return ans
-
-    lzma.compress(read, outfile.write, None, level)
-    unpadded_size = outfile.tell() - start
-    pos = outfile.tell()
-    if pos % 4:
-        outfile.write(b'\0' * (4 - (pos % 4)))
-    checker.finish()
-    if check_type:
-        cc = checker.code_as_bytes
-        outfile.write(cc)
-        unpadded_size += len(cc)
-
-    # Write index
-    index = b'\0' + encode_var_int(1)
-    index += encode_var_int(unpadded_size) + encode_var_int(uncompressed_size[0])
-    if len(index) % 4:
-        index += b'\0' * (4 - len(index) % 4)
-    outfile.write(index), outfile.write(pack(b'<I', crc32(index)))
-
-    # Write stream footer
-    backwards_size = pack(b'<I', ((len(index) + 4) // 4) - 1)
-    outfile.write(pack(b'<I', crc32(backwards_size + stream_flags)))
-    outfile.write(backwards_size), outfile.write(stream_flags
-                                                 ), outfile.write(FOOTER_MAGIC)
-
-
-def test_lzma2():
-    raw = P('template-functions.json', allow_user_override=False, data=True)
-    ibuf, obuf = BytesIO(raw), BytesIO()
-    props = lzma.compress(ibuf.read, obuf.write, False)
-    cc = obuf.getvalue()
-    ibuf, obuf = BytesIO(cc), BytesIO()
-    LZMA2Filter(props, 0, 1)(ibuf, obuf)
-    if obuf.getvalue() != raw:
-        raise ValueError('Roundtripping via LZMA2 failed')
-
-
-def test_xz():
-    raw = P('template-functions.json', allow_user_override=False, data=True)
-    ibuf, obuf = BytesIO(raw), BytesIO()
-    compress(ibuf, obuf, check_type='sha256')
-    cc = obuf.getvalue()
-    ibuf, obuf = BytesIO(cc), BytesIO()
-    decompress(ibuf, obuf)
-    if obuf.getvalue() != raw:
-        raise ValueError('Roundtripping via XZ failed')
-
-
-if __name__ == '__main__':
-    import sys
-    decompress(open(sys.argv[-1], 'rb'))
-- 
2.28.0.rc0

