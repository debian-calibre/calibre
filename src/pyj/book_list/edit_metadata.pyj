# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2018, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import bound_methods, hash_literals

import traceback
from elementmaker import E
from gettext import gettext as _

from ajax import ajax_send
from book_list.book_details import (
    basic_table_rules, fetch_metadata, field_sorter, no_book, report_load_failure
)
from book_list.library_data import (
    book_metadata, current_library_id, field_names_for, library_data, load_status,
    loaded_book_ids, set_book_metadata
)
from book_list.router import back
from book_list.theme import get_color
from book_list.top_bar import create_top_bar, set_title
from book_list.ui import set_panel_handler, show_panel
from date import format_date
from dom import add_extra_css, build_rule, clear, svgicon
from modals import error_dialog
from session import get_interface_data
from utils import (
    conditional_timeout, fmt_sidx, parse_url_params, safe_set_inner_html
)
from widgets import create_button

CLASS_NAME = 'edit-metadata-panel'
IGNORED_FIELDS = {'formats', 'sort', 'uuid', 'id', 'urls_from_identifiers', 'lang_names', 'last_modified', 'path', 'marked', 'size', 'ondevice', 'cover', 'au_map', 'isbn'}
value_to_json = None
changes = {}
has_changes = False

add_extra_css(def():
    sel = '.' + CLASS_NAME + ' '
    style = basic_table_rules(sel)
    style += build_rule(sel + 'table.metadata', margin_left='1rem')
    style += build_rule(sel + 'table.metadata td', padding_bottom='0.5ex', padding_top='0.5ex', cursor='pointer')
    style += build_rule(sel + 'table.metadata tr:hover', color='red')
    style += build_rule(sel + 'table.metadata tr:active', transform='scale(1.5)')

    style += build_rule(sel + '.completions', display='flex', flex_wrap='wrap', align_items='center')
    style += build_rule(sel + '.completions > div', margin='0.5ex 0.5rem', margin_left='0', padding='0.5ex 0.5rem', border='solid 1px currentColor', border_radius='1ex', cursor='pointer')
    style += build_rule(sel + '.completions > div:active', transform='scale(1.5)')
    style += build_rule(sel + '.completions > div:hover', background=get_color('window-foreground'), color=get_color('window-background'))
    return style
)


def resolved_metadata(mi, field):
    if Object.prototype.hasOwnProperty.call(changes, field):
        return changes[field]
    return mi[field]


def truncated_html(val):
    ans = val.replace(/<[^>]+>/g, '')
    if ans.length > 40:
        ans = ans[:40] + '…'
    return ans



def onsubmit_field(get_value, container_id, book_id, field):
    c = document.getElementById(container_id)
    if not c:
        return
    d = c.querySelector('div[data-ctype="edit"]')
    if not d:
        return
    ok, value = get_value(d)
    if not ok:
        return
    if value is book_metadata(book_id)[field]:
        on_close(container_id)
        return

    def proceed():
        nonlocal has_changes
        clear(d)
        d.appendChild(E.div(style='margin: 1ex 1rem', _('Contacting server, please wait') + '…'))
        jval = value_to_json(value)
        changes[field] = jval
        has_changes = True
        show_book(container_id, book_id)
        on_close(container_id)


    window.setTimeout(proceed, 0)  # needed to avoid console error about form submission failing because form is removed from DOM in onsubmit handler


def create_form(widget, get_value, container_id, book_id, field, *edit_widgets):
    submit_action = onsubmit_field.bind(None, get_value, container_id, book_id, field)
    button = create_button(_('OK'), action=submit_action)
    widget.classList.add('metadata-editor')
    form = E.form(
        action='javascript: void(0)', onsubmit=submit_action, style='margin: 1ex auto',
        E.div(widget, style='margin-bottom: 1ex'),
        E.div(button)
    )
    return form


def line_edit_get_value(container):
    return True, container.querySelector('input[type="text"]').value


def simple_line_edit(container_id, book_id, field, fm, div, mi):
    nonlocal value_to_json
    name = fm.name or field
    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True, style='width: 100%')
    le.value = resolved_metadata(mi, field) or ''
    form = create_form(le, line_edit_get_value, container_id, book_id, field)
    div.appendChild(E.div(style='margin: 0.5ex 1rem', _('Edit the "{}" below').format(name)))
    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))
    le.focus(), le.select()
    value_to_json = def(x):
        return x


def add_completion(container_id, name):
    c = document.getElementById(container_id)
    if not c:
        return
    le = c.querySelector('[data-ctype="edit"] input')
    val = le.value or ''
    val = value_to_json(val)
    if jstype(val) is 'string':
        le.value = name
    elif val:
        if val.length:
            val[-1] = name
        else:
            val.push(name)
        le.value = val.join(update_completions.list_to_ui) + update_completions.list_to_ui
    le.focus()


def show_completions(container_id, div, field, prefix, names):
    clear(div)
    completions = E.div(class_='completions')
    div.appendChild(completions)
    for i, name in enumerate(names):
        completions.appendChild(E.div(name, onclick=add_completion.bind(None, container_id, name)))
        if i >= 50:
            break


def update_completions(container_id, ok, field, names):
    c = document.getElementById(container_id)
    if not c:
        return
    d = c.querySelector('div[data-ctype="edit"]')
    if not d or d.style.display is not 'block':
        return
    div = d.lastChild
    clear(div)
    if not ok:
        err = E.div()
        safe_set_inner_html(err, names)
        div.appendChild(E.div(
            _('Failed to download items for completion, with error:'), err
        ))
        return
    val = d.querySelector('input').value or ''
    val = value_to_json(val)
    if jstype(val) is 'string':
        prefix = val
    else:
        prefix = val[-1] if val.length else ''
    if prefix is update_completions.prefix:
        return
    pl = prefix.toLowerCase().strip()
    if pl:
        if update_completions.prefix and pl.startswith(update_completions.prefix.toLowerCase()):
            matching_names = [x for x in update_completions.names if x.toLowerCase().startswith(pl)]
        else:
            matching_names = [x for x in names if x.toLowerCase().startswith(pl)]
    else:
        matching_names = []
    update_completions.prefix = prefix
    update_completions.names = matching_names
    show_completions(container_id, div, field, prefix, matching_names)


update_completions.ui_to_list = None
update_completions.list_to_ui = None
update_completions.names = v'[]'
update_completions.prefix = ''


def line_edit_updated(container_id, field):
    field_names_for(field, update_completions.bind(None, container_id))


def multiple_line_edit(list_to_ui, ui_to_list, container_id, book_id, field, fm, div, mi):
    nonlocal value_to_json
    update_completions.ui_to_list = ui_to_list
    update_completions.list_to_ui = list_to_ui
    name = fm.name or field
    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True, style='width: 100%', oninput=line_edit_updated.bind(None, container_id, field))
    le.value = (resolved_metadata(mi, field) or v'[]').join(list_to_ui)
    form = create_form(le, line_edit_get_value, container_id, book_id, field)
    div.appendChild(E.div(style='margin: 0.5ex 1rem', _(
        'Edit the "{0}" below. Multiple items can be separated by {1}.').format(name, list_to_ui.strip())))
    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))
    div.appendChild(E.div(E.span(_('Loading all {}...').format(name)), style='margin: 0.5ex 1rem'))
    le.focus(), le.select()
    value_to_json = def(x):
        return [a.strip() for a in x.split(ui_to_list) if a.strip()]
    field_names_for(field, update_completions.bind(None, container_id))


def edit_field(container_id, book_id, field):
    nonlocal value_to_json
    fm = library_data.field_metadata[field]
    c = document.getElementById(container_id)
    mi = book_metadata(book_id)
    if not c or not fm or not mi:
        return
    d = c.querySelector('div[data-ctype="edit"]')
    d.style.display = 'block'
    d.previousSibling.style.display = 'none'
    clear(d)
    update_completions.ui_to_list = None
    update_completions.list_to_ui = None
    update_completions.names = v'[]'
    update_completions.prefix = ''
    if field is 'authors':
        multiple_line_edit(' & ', '&', container_id, book_id, field, fm, d, mi)
    else:
        simple_line_edit(container_id, book_id, field, fm, d, mi)
    if field is 'title':
        value_to_json = def(x):
            return x or _('Untitled')
    elif field is 'authors':
        value_to_json = def(x):
            return [a.strip() for a in x.split('&') if a.strip()] or [_('Unknown')]


def render_metadata(mi, table, container_id, book_id):  # {{{
    field_metadata = library_data.field_metadata
    interface_data = get_interface_data()
    current_edit_action = None

    def allowed_fields(field):
        if field.endswith('_index'):
            fm = field_metadata[field[:-len('_index')]]
            if fm and fm.datatype is 'series':
                return False
        if field.startswith('#'):
            return True
        if field in IGNORED_FIELDS or field.endswith('_sort') or field[0] is '@':
            return False
        return True

    fields = library_data.book_display_fields
    if not fields or not fields.length:
        fields = sorted(filter(allowed_fields, mi), key=field_sorter(field_metadata))
    else:
        fields = filter(allowed_fields, fields)
    fields = list(fields)
    added_fields = {f:True for f in fields}
    if not added_fields.title:
        added_fields.title = True
        fields.insert(0, 'title')
    for other_field in Object.keys(library_data.field_metadata):
        if not added_fields[other_field] and allowed_fields(other_field) and other_field not in IGNORED_FIELDS:
            fields.push(other_field)

    def add_row(name, val, is_html=False, join=None):
        if val is undefined or val is None:
            val = v'[" "]' if join else '\xa0'
        def add_val(v):
            if not v.appendChild:
                v += ''
            if v.appendChild:
                table.lastChild.lastChild.appendChild(v)
            else:
                table.lastChild.lastChild.appendChild(document.createTextNode(v))

        table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))
        if is_html:
            table.lastChild.lastChild.appendChild(document.createTextNode(truncated_html(val + '')))
        else:
            if not join:
                add_val(val)
            else:
                for v in val:
                    add_val(v)
                    if v is not val[-1]:
                        table.lastChild.lastChild.appendChild(document.createTextNode(join))
        return table.lastChild.lastChild

    def process_composite(field, fm, name, val):
        if fm.display and fm.display.contains_html:
            add_row(name, val, is_html=True)
        elif fm.is_multiple and fm.is_multiple.list_to_ui:
            all_vals = filter(None, map(str.strip, val.split(fm.is_multiple.list_to_ui)))
            add_row(name, all_vals, join=fm.is_multiple.list_to_ui)
        else:
            add_row(name, val)

    def process_authors(field, fm, name, val):
        add_row(name, val, join=' & ')

    def process_publisher(field, fm, name, val):
        add_row(name, val)

    def process_rating(field, fm, name, val):
        stars = E.span()
        val = int(val or 0)
        if val > 0:
            for i in range(val // 2):
                stars.appendChild(svgicon('star'))
            if fm.display.allow_half_stars and (val % 2):
                stars.appendChild(svgicon('star-half'))
            add_row(name, stars)
        else:
            add_row(name, None)

    def process_identifiers(field, fm, name, val):
        if val:
            keys = Object.keys(val)
            if keys.length:
                table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))
                td = table.lastChild.lastChild
                for k in keys:
                    if td.childNodes.length:
                        td.appendChild(document.createTextNode(', '))
                    td.appendChild(document.createTextNode(k))
                return
        add_row(name, None)

    def process_languages(field, fm, name, val):
        if val and val.length:
            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))
            td = table.lastChild.lastChild
            for k in val:
                lang = mi.lang_names[k] or k
                td.appendChild(document.createTextNode(lang))
                if k is not val[-1]:
                    td.appendChild(document.createTextNode(', '))
            return
        add_row(name, None)

    def process_datetime(field, fm, name, val):
        if val:
            fmt = interface_data['gui_' + field + '_display_format'] or (fm['display'] or {}).date_format
            add_row(name, format_date(val, fmt))
        else:
            add_row(name, None)

    def process_series(field, fm, name, val):
        if val:
            ifield = field + '_index'
            try:
                ival = float(resolved_metadata(mi, ifield))
            except Exception:
                ival = 1.0
            ival = fmt_sidx(ival, use_roman=interface_data.use_roman_numerals_for_series_number)
            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))
            s = safe_set_inner_html(E.span(), _('{0} of <i>{1}</i>').format(ival, val))
            table.lastChild.lastChild.appendChild(s)
        else:
            add_row(name, None)

    def process_field(field, fm):
        name = fm.name or field
        datatype = fm.datatype
        val = resolved_metadata(mi, field)
        if field is 'comments' or datatype is 'comments':
            add_row(name, truncated_html(val or ''))
            return
        func = None
        if datatype is 'composite':
            func = process_composite
        elif datatype is 'rating':
            func = process_rating
        elif field is 'identifiers':
            func = process_identifiers
        elif field is 'authors':
            func = process_authors
        elif field is 'publisher':
            func = process_publisher
        elif field is 'languages':
            func = process_languages
        elif datatype is 'datetime':
            func = process_datetime
        elif datatype is 'series':
            func = process_series
        if func:
            func(field, fm, name, val)
        else:
            if datatype is 'text' or datatype is 'enumeration':
                if val is not undefined and val is not None:
                    join = fm.is_multiple.list_to_ui if fm.is_multiple else None
                    add_row(name, val, join=join)
                else:
                    add_row(name, None)
            elif datatype is 'bool':
                add_row(name, _('Yes') if val else _('No'))
            elif datatype is 'int' or datatype is 'float':
                if val is not undefined and val is not None:
                    fmt = (fm.display or {}).number_format
                    if fmt:
                        val = fmt.format(val)
                    else:
                        val += ''
                    add_row(name, val)
                else:
                    add_row(name, None)

    for field in fields:
        fm = field_metadata[field]
        if not fm:
            continue
        current_edit_action = edit_field.bind(None, container_id, book_id, field)
        try:
            process_field(field, fm)
        except Exception:
            print('Failed to render metadata field: ' + field)
            traceback.print_exc()

# }}}


def changes_submitted(container_id, book_id, end_type, xhr, ev):
    nonlocal changes, has_changes
    changes = {}
    has_changes = False
    if end_type is 'abort':
        on_close(container_id)
        return
    if end_type is not 'load':
        error_dialog(_('Failed to update metadata on server'), _(
            'Updating metadata for the book: {} failed.').format(book_id), xhr.error_html)
        return
    try:
        dirtied = JSON.parse(xhr.responseText)
    except Exception as err:
        error_dialog(_('Could not update metadata for book'), _('Server returned an invalid response'), err.toString())
        return

    for bid in dirtied:
        set_book_metadata(bid, dirtied[book_id])
    on_close(container_id)


def submit_changes(container_id, book_id):
    c = document.getElementById(container_id)
    d = c.querySelector('div[data-ctype="show"]')
    clear(d)
    d.appendChild(E.div(style='margin: 1ex 1rem', _('Uploading changes to server, please wait...')))
    data = {'changes': changes, 'loaded_book_ids': loaded_book_ids()}
    ajax_send(
        f'cdb/set-fields/{book_id}/{current_library_id()}', data, changes_submitted.bind(None, container_id, book_id))


def show_book(container_id, book_id):
    container = document.getElementById(container_id)
    mi = book_metadata(book_id)
    if not container or not mi:
        return
    div = container.querySelector('div[data-ctype="show"]')
    if not div:
        return
    clear(div)
    if has_changes:
        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))
        div.appendChild(E.div(style='margin: 1ex 1rem', b))
    else:
        div.appendChild(E.div(style='margin: 1ex 1rem', _(
            'Tap any field below to edit it')))
    div.appendChild(E.table(class_='metadata'))
    render_metadata(mi, div.lastChild, container_id, book_id)
    if has_changes:
        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))
        div.appendChild(E.div(style='margin: 1ex 1rem', b))


def on_close(container_id):
    c = document.getElementById(container_id)
    if c:
        d = c.querySelector('div[data-ctype="edit"]')
        if d:
            if d.style.display is 'block':
                d.style.display = 'none'
                d.previousSibling.style.display = 'block'
                clear(d), clear(d.previousSibling)
                q = parse_url_params()
                show_book(container_id, int(q.book_id))
                return
        back()


def proceed_after_succesful_fetch_metadata(container_id, book_id):
    nonlocal changes, has_changes
    changes = {}
    has_changes = False
    container = document.getElementById(container_id)
    mi = book_metadata(book_id)
    if not mi or not container:
        show_panel('book_details', query=parse_url_params(), replace=True)
        return
    set_title(container, _('Edit metadata for {}').format(mi.title))
    clear(container.lastChild)
    container.lastChild.appendChild(E.div(data_ctype='show', style='display:block'))
    container.lastChild.appendChild(E.div(data_ctype='edit', style='display:none'))
    show_book(container_id, book_id)


def create_edit_metadata(container):
    q = parse_url_params()
    current_book_id = q.book_id
    if not current_book_id:
        no_book(container)
        return
    current_book_id = int(current_book_id)
    container_id = container.parentNode.id
    if not book_metadata(current_book_id):
        fetch_metadata(container_id, current_book_id, proceed_after_succesful_fetch_metadata)
    else:
        proceed_after_succesful_fetch_metadata(container_id, current_book_id)


def check_for_books_loaded():
    container = this
    if load_status.loading:
        conditional_timeout(container.id, 5, check_for_books_loaded)
        return
    container = container.lastChild
    clear(container)
    if not load_status.ok:
        report_load_failure(container)
        return
    create_edit_metadata(container)


def init(container_id):
    container = document.getElementById(container_id)
    create_top_bar(container, title=_('Edit metadata'), action=on_close.bind(None, container_id), icon='close')
    container.appendChild(E.div(class_=CLASS_NAME))
    container.lastChild.appendChild(E.div(_('Loading books from the calibre library, please wait...'), style='margin: 1ex 1em'))
    conditional_timeout(container_id, 5, check_for_books_loaded)


set_panel_handler('edit_metadata', init)
