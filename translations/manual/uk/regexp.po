# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Zoriana Zaiats, 2014
# Yuri Chornoivan <yurchor@ukr.net>, 2016-2018
# Zoriana Zaiats, 2014
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-01-05 11:18+0530\n"
"PO-Revision-Date: 2018-01-05 07:08+0000\n"
"Last-Translator: Yuri Chornoivan <yurchor@ukr.net>\n"
"Language-Team: Ukrainian (http://www.transifex.com/calibre/calibre/language/uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#: ../../home/kovid/work/calibre/manual/regexp.rst:4
msgid "All about using regular expressions in calibre"
msgstr "Все про використання формальних виразів в calibre"

#: ../../home/kovid/work/calibre/manual/regexp.rst:6
msgid ""
"Regular expressions are features used in many places in calibre to perform "
"sophisticated manipulation of e-book content and metadata. This tutorial is "
"a gentle introduction to getting you started with using regular expressions "
"in calibre."
msgstr "Формальні вирази використовуються у багатьох частинах calibre для виконання витонченої обробки вмісту та метаданих електронної книги. Ця частина підручника є лише початковими настановами, які допоможуть вам розпочати роботу із використанням формальних виразів у calibre."

#: ../../home/kovid/work/calibre/manual/regexp.rst:14
msgid "First, a word of warning and a word of courage"
msgstr "Спочатку, декілька попереджень і декілька заохочень"

#: ../../home/kovid/work/calibre/manual/regexp.rst:16
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Пояснення, і цього не уникнути, будуть дещо технічними. Щоб там не було, але формальні вирази є технічним інструментом для виконання технічних завдань. Буде використано певний жаргон та поняття, які можуть здатися складними або заплутаними. Ми спробуємо надати якомога прозоріші пояснення, але без цього жаргону і відповідних понять не обійтися. Втім, не лякайтеся жаргону, ми спробуємо пояснити усі нові речі. І хоча самі формальні вирази можуть здатися загадковими закляттями (або, якщо прозаїчніше, рядками з випадкових символів, дивною сумішшю літер із знаків), ми вам обіцяємо — все не так уже і складно. Навіть ті, хто добре знається на формальних виразах, іноді не одразу розуміють призначення складних формальних виразів, але написати формальний вираз не так уже і складно — він конструюється покроково. Отже, почнімо і зробимо перший крок до цієї кролячої нори."

#: ../../home/kovid/work/calibre/manual/regexp.rst:19
msgid "Where in calibre can you use regular expressions?"
msgstr "Де в calibre ви можете використовувати формальні вирази?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:21
msgid ""
"There are a few places calibre uses regular expressions. There's the "
":guilabel:`Search & replace` in conversion options, metadata detection from "
"filenames in the import settings and Search & replace when editing the "
"metadata of books in bulk. The calibre book editor can also use regular "
"expressions in its search and replace feature."
msgstr "Формальні вирази використовуються у calibre у декількох місцях. Це, зокрема, засіб пошуку із заміною у параметрах перетворення книг, засіб визначення метаданих за назвами файлів у параметрах імпортування та засіб пошуку із заміною у інструменті пакетного редагування метаданих книг. У засобі пошуку із заміною редактора книг calibre також можна використовувати формальні вирази."

#: ../../home/kovid/work/calibre/manual/regexp.rst:28
msgid "What on earth *is* a regular expression?"
msgstr "Що ж таке ці «формальні вирази»?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:30
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Формальний вираз — це спосіб описати певний набір рядків. Один формальний вираз може *відповідати* декільком різним рядкам. Це саме те, що робить формальні вирази такими потужними — вони є способом коротко описати велику кількість можливих варіантів рядка."

#: ../../home/kovid/work/calibre/manual/regexp.rst:32
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In calibre, regular expressions are case insensitive in the Search"
" bar, but not in the conversion options. There's a way to make every regular"
" expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Тут термін «рядок» використано у сенсі, у якому його використовують у мовах програмування. Це упорядкована сукупність одного або декількох символів. Символами вважаються літери, цифри, символи пунктуації, а також так звані пробіли (символи розриву рядків, табуляції тощо). Будь ласка, зауважте, що, загалом кажучи, літери верхнього регістру (великі літери) і літери нижнього регістру (малі літери) вважаються різними знаками. Отже «a» — це не та сама літера, що «A». У calibre регістр символів не береться до уваги на панелі пошуку, але враховується у параметрах перетворення книг. Існує спосіб зробити будь-який формальний вираз таким, що обробляється без врахування регістру символів, але цей спосіб ми обговоримо пізніше. Неврахування регістру символів дещо ускладнює ситуацію, оскільки формальні вирази уможливлюють варіації відповідників, отже одному формальному виразу відповідає одразу декілька рядків. Ось чому дехто взагалі не бажає користуватися формальними виразами. Докладніше про це трохи згодом."

#: ../../home/kovid/work/calibre/manual/regexp.rst:35
msgid "Care to explain?"
msgstr "Трохи пояснень"

#: ../../home/kovid/work/calibre/manual/regexp.rst:37
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "Ну, гаразд, для цього ми і почали це обговорення. По-перше, ось найважливіша концепція у формальних виразах: *рядок є формальним виразом, який відповідає самому собі*. Тобто, якщо ви хочете знайти рядок ``«Привіт, світе!»`` за допомогою формального виразу, формальним виразом, яким ви маєте скористатися є рядок ``«Привіт, світе!»``. Так, це справді дуже просто. Втім, варто зауважити, що під час пошуку за цим рядком буде знайдено *лише* рядок ``«Привіт, світе!»``, а не, наприклад, рядки ``«Привіт, сВіте!»`` чи ``«привіт, світе!»``."

#: ../../home/kovid/work/calibre/manual/regexp.rst:40
msgid "That doesn't sound too bad. What's next?"
msgstr "Звучить непогано. Що далі?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:42
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is where it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"e-book you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "Далі, ми розпочнемо знайомитися зі справді корисними речами. Пам’ятаєте, ми згадували про те, що один формальний вираз може відповідати декільком рядкам? Тут ми обговоримо трохи складніші речі. Припустімо для нашого дещо практичнішого прикладу, що у електронній книзі, яку ви хочете перетворити є небажані рядки у нижньому колонтитулі, які вказують на номер сторінки, наприклад «Сторінка 5 з 423». Очевидно, номери сторінок мають зростати від 1 до 423, отже, нам доведеться створити відповідники 423 різних рядків, чи не так? Ні, не так: формальний вираз надасть нам змогу визначити усі можливі набори символів для відповідності. Щоб визначити набір, слід вказати усі його символи у квадратних дужках. Наприклад, набір ``[abc]`` відповідає літері «a», «b» або «c». *Наборам завжди відповідає один із символів набору*. Передбачено можливість вказування діапазонів символів, наприклад, якщо вам потрібно вказати усі латинські літери нижнього регістру, вам слід скористатися набором ``[a-z]``, для латинських літер нижнього і верхнього регістрів — набором ``[a-zA-Z]`` тощо. Вловили ідею? Отже, очевидно, використавши вираз ``Сторінка [0-9] з 423``, ми зможемо встановити відповідність першим дев’ятьом сторінкам, таким чином зменшивши кількість потрібних для встановлення відповідності виразів до трьох: другим виразом буде ``Сторінка [0-9][0-9] з 423`` (він відповідатиме двоцифровим номерам сторінок), а про третій ви можете здогадатися самі. Так, вгадайте його і запишіть."

#: ../../home/kovid/work/calibre/manual/regexp.rst:45
msgid "Hey, neat! This is starting to make sense!"
msgstr "Ого, чудово! Це може бути корисним!"

#: ../../home/kovid/work/calibre/manual/regexp.rst:47
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression.) These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Ми сподівалися, що ви скажете саме це. Але зачекайте, зараз буде ще краще! Щойно ми використали набори для встановлення відповідності одного з декількох символів. Але можна повторити символ або набір і заощадити кількість виразів потрібних для обробки номерів сторінок у наведеному вище прикладі. Так, достатньо усього одного виразу! Вражені? Ну, звичайно ж! Це працює ось так: передбачено так звані спеціальні символи, «+», «?» і «*», для *повторення одинарного елемента, який безпосередньо передує цим символам*. (Елементом може бути окремий символ, набір символів, керівна послідовність символів або група (опис останніх двох наведено нижче) — якщо коротко, елементом може бути будь-який окремий об’єкт у формальному виразі). Ці символи називаються замінниками або кванторами. Якщо бути точнішим, «?» відповідає *0 або 1* попередньому елементу, «*» відповідає *0 або більшій кількості* попереднього елемента, а «+» відповідає *1 або більшій кількості* попереднього елемента. Декілька прикладів: вираз ``a?`` буде відповідати «» (тобто порожньому рядку, що не дуже корисно у нашому прикладі) або «a»; вираз ``a*`` відповідає «», «a», «aa» або будь-якій кількості послідовних літер «a», і, нарешті, вираз ``a+`` відповідає «a», «aa» або будь-якій кількості послідовних літер «a» (Зауваження: останній вираз не відповідає порожньому рядку!). Те саме стосується і наборів: вираз ``[0-9]+`` відповідатиме *будь-якому цілому числу*! Знаємо, про що ви подумали, і ви праві: якщо ми розглядатимемо наведений вище приклад із номерами сторінок, чи не буде це саме той єдиний вираз, який відповідає усім номерам сторінок? Так, вираз ``Сторінка [0-9]+ з 423`` відповідатиме будь-якій сторінці у книзі!"

#: ../../home/kovid/work/calibre/manual/regexp.rst:50
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of.) Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "Зауваження щодо цих кванторів: загалом кажучи, при використанні кванторів програма намагатиметься використати найбільший із можливих відповідників, отже, вам слід бути обережними з використанням кванторів. Така поведінка називається «жадібністю», думаємо, ви зрозуміли чому. Вона може призводити до певних проблем, зокрема під час пошуку теґів. Розгляньмо, наприклад, рядок ``\"<p class=\"calibre2\">Заголовок</p>\"``. Скажімо, вам потрібно знайти у ньому початковий теґ (частину між першою паролю кутових дужок, докладніше про теґи нижче). Можна припустити, що вираз ``<p.*>`` відповідатиме теґові, але насправді він відповідає усьому рядку! (Символ «.» є ще одним спеціальним символом. Він відповідає будь-якому символу *окрім* символів розриву рядка, отже, загалом, вираз ``.*`` відповідає будь-якому окремому рядку.) Замість цього виразу слід скористатися виразом ``<p.*?>``, який робить квантор ``*`` нежадібним. Такий вираз відповідає лише першому початковому теґу, як і планувалося. Насправді, існує інший спосіб досягти потрібного результату: вираз ``<p[^>]*>`` також відповідає початковому теґу. Чому так? Про це ви дізнаєтеся із наступного розділу. Зауважте лише, що зазвичай існує принаймні декілька способів запису логіки одного формального виразу."

#: ../../home/kovid/work/calibre/manual/regexp.rst:54
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "Добре, ці спеціальні символи корисні і усе таке, але що, якщо потрібно знайти крапку або знак питання?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:56
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "Звичайно ж, існує спосіб зробити це: достатньо поставити символ зворотної похилої риски перед спеціальним символом, і він стане звичайним символом без додаткових значень. Пара символів зворотної похилої риски із наступним символом називається керівною послідовністю, а додавання символу зворотної похилої риски перед спеціальним символом називається екрануванням символу. Екранована послідовність символів вважається єдиним елементом формального виразу. Звичайно ж, існують керівні послідовності, які означають більше ніж просте екранування спеціальних символів, наприклад, ``\\t`` означає символ табуляції. Деякі з таких керівних послідовностей ми розглянемо нижче. О, і до речі, щодо спеціальних символів: усі символи, які ми обговорювали у цьому вступі як такі, що мають особливе призначення, потребують екранування, якщо ви хочете скористатися ними як звичайними символами."

#: ../../home/kovid/work/calibre/manual/regexp.rst:59
msgid "So, what are the most useful sets?"
msgstr "Отже, якими є найкорисніші набори?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:61
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand::"
msgstr "Ми знали, що ви про це запитаєте. Серед корисних наборів символів є набір ``[0-9]``, який відповідає будь-якій цифрі, набір ``[a-z]``, який відповідає будь-якій латинській літері нижнього регістру, набір ``[A-Z]``, який відповідає будь-якій латинській літері верхнього регістру, набір ``[a-zA-Z]``, який відповідає будь-якій латинській літері, та набір ``[a-zA-Z0-9]``, який відповідає будь-якій латинській літері або цифрі. Ви також можете використовувати такі екрановані послідовності::"

#: ../../home/kovid/work/calibre/manual/regexp.rst:68
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed and carriage "
"return."
msgstr "«Пробілами» вважаються будь-які символи, які не можна надрукувати. Такими символами є звичайні пробіли, символи табуляції, символи заповнення рядка, заповнення форми та символи повернення каретки."

#: ../../home/kovid/work/calibre/manual/regexp.rst:70
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "На завершення розмови про набори, — ви також можете визначити набір як будь-який символ, *окрім* символів у вказаному наборі. Для цього слід додати символ ``^`` як *найперший символ у наборі*. Таким чином, ``[^a]`` відповідає будь-якому символу, окрім символу «a». Така дія називається доповненням набору. Керівні послідовності, які ми розглядали вище, також можна використовувати для доповнення: ``\\D`` відповідає будь-якому нецифровому символу, отже, є еквівалентом ``[^0-9]``. Інші скорочені форми доповнень, як ви вже могли здогадатися, створюються використанням літери верхнього регістру замість літери нижнього регістру. Отже, повертаючись до прикладу із ``<p[^>]*>`` з попереднього розділу, можемо бачити, що набір символів, який у ньому використано, відповідає будь-якому символу, окрім кінцевої кутової дужки."

#: ../../home/kovid/work/calibre/manual/regexp.rst:73
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Що якщо потрібно знайти якийсь із декількох рядків? Все значно ускладниться?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:75
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in e-books, "
"it's annoying. You can group whole expressions in normal parentheses, and "
"the character ``\"|\"`` will let you match *either* the expression to its "
"right *or* the one to its left. Combine those and you're done. Too fast for "
"you? Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "Не бійтеся, життя є простим і прекрасним. Розгляньмо приклад: на сторінках книги, перетворення якої ви хочете виконати, назву книги написано у верхньому колонтитулі кожної непарної сторінки, а імена авторів — у верхньому колонтитулі парних сторінок. Друкована книга виглядає чудово, але для електронної книги усі ці дані є зайвими. Ви можете згрупувати вирази для колонтитулів у звичайних круглих дужках і скористатися символом ``|`` для встановлення відповідності *будь-якому* з виразів, які розташовано з *обох* боків від цього символу. Поєднайте рядки для парних і непарних сторінок, і справу буде зроблено. Надто швидко для вас, не зрозуміли? Гаразд, спочатку ми згрупуємо вирази для непарних і парних сторінок, отримавши ``(Назва)(Автор)`` для двох відповідних виразів. Далі, спростимо речі, скориставшись символом вертикальної риски (``|`` називається символом вертикальної риски): якщо буде використано вираз ``(Назва|Автор)`` під час пошуку відповідність встановлюватиметься або для рядка «Назва» (на непарних сторінках) або для рядка «Автор» (на парних сторінках). Гаразд, хіба це не просто?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:77
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "Звичайно ж, ви можете скористатися вертикальною рискою без групування за допомогою дужок. Пам’ятаєте, ми згадували, що квантори повторюють елемент, який їм передує? Гаразд, вертикальна риска працює трохи інакше: вираз «Назва|Автор» також відповідає або рядку «Назва», або рядку «Автор», як і у наведеному вище прикладі із групуванням. *За допомогою вертикальної риски можна зробити варіантами для вибору вираз, який передує їй і вираз, який розташовано після вертикальної риски*. Отже, якщо ви хочете знайти рядок «Calibre» і рядок «calibre», де змінюється лише регістр початкової літери «c», варто скористатися виразом ``(c|C)alibre``, де групування забезпечує вибір лише між різними регістрами літери «c». Якщо б ви використали вираз ``c|Calibre``, варіантами б були рядки «c» і «Calibre», тобто не ті рядки, які нам потрібні. Якщо коротко: не бійтеся використовувати групування для того, щоб уникнути двозначності у виразі."

#: ../../home/kovid/work/calibre/manual/regexp.rst:80
msgid "You missed..."
msgstr "Ви пропустили…"

#: ../../home/kovid/work/calibre/manual/regexp.rst:82
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "...зачекайте, ще одна остання дуже цікава річ, пов’язана із групами. Якщо у виразі є група, з якою встановлюється відповідність рядка пошуку, ви можете посилатися на цю групу далі у виразі. Групи нумеруються, починаючи з 1, а посилаються на них додаючи символ екранування до номера групи. Отже, на п’яту групу посилаються за допомогою послідовності ``\\5``. Таким чином, якщо виконуватиметься пошук за виразом ``([^ ]+) \\1`` у рядку «Тест Тест», буде встановлено відповідність формального виразу усьому рядку!"

#: ../../home/kovid/work/calibre/manual/regexp.rst:86
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "На початку була згадка про те, що формальні вирази можна зробити незалежними від регістру символів. Як це зробити?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:88
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell "
"calibre how you want certain things handled by using something called flags."
" You include flags in your expression by using the special construct "
"``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with "
"the specific flags you want. For ignoring case, the flag is ``i``, thus you "
"include ``(?i)`` in your expression. Thus, ``(?i)test`` would match "
"\"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr "Так, ми про це згадували. Дякуємо, що були уважними і нагадали про це. Ви можете повідомити calibre про те, як обробляти певні речі, за допомогою так званих прапорців. Включити прапорці до вашого виразу можна за допомогою спеціальної конструкції ``(?тут вказують прапорці)``, у якій, звичайно ж, вам слід замінити рядок «тут вказують прапорці» на потрібний вам вираз прапорців. Якщо слід ігнорувати регістр символів, маємо вказати прапорець ``i``, тобто включити ``(?i)`` до вашого виразу. Таким чином, за допомогою виразу ``(?i)тест`` можна знайти рядки «Тест», «тЕст», «ТЕст» та усі інші рядки, які утворюються зміною регістру символів з рядка «тест»."

#: ../../home/kovid/work/calibre/manual/regexp.rst:90
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above."
msgstr "Ще один корисний прапорець надає змогу наказати програмі вважати крапку будь-яким символом, *включно* із символом розриву рядка. Це прапорець ``s``. Якщо ви хочете використати у виразі декілька прапорців, просто напишіть їх поряд у одній інструкції: використання ``(?is)`` призведе до ігнорування регістру символів і заміни крапки будь-яким символом. Не має значення, який із прапорців ви вказали першим — вираз ``(?si)`` є рівнозначним до виразу ``(?is)``."

#: ../../home/kovid/work/calibre/manual/regexp.rst:93
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in calibre?"
msgstr "Здається, починаю розуміти для чого усі ці формальні вирази… Але як ними скористатися у calibre?"

#: ../../home/kovid/work/calibre/manual/regexp.rst:96
msgid "Conversions"
msgstr "Перетворення"

#: ../../home/kovid/work/calibre/manual/regexp.rst:98
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
":guilabel:`Search & replace` part, you can input a regexp (short for regular"
" expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what calibre \"sees\" during the conversion process. Scroll"
" down to the string you want to remove, select and copy it, paste it into "
"the regexp field on top of the window. If there are variable parts, like "
"page numbers or so, use sets and quantifiers to cover those, and while "
"you're at it, remember to escape special characters, if there are some. Hit "
"the button labeled :guilabel:`Test` and calibre highlights the parts it "
"would replace were you to use the regexp. Once you're satisfied, hit OK and "
"convert. Be careful if your conversion source has tags like this example::"
msgstr "Почнімо з параметрів перетворення, які є добре продуманими. На панелі пошуку з заміною ви можете ввести формальний вираз, який описує рядок, який буде замінено під час перетворення. Найпродуманішою частиною діалогового вікна є майстер перетворення. Після натискання кнопки майстра ви зможете переглянути, як для calibre «виглядає» процедура перетворення. Погортайте текст до рядка, який ви хочете вилучити, позначте його і скопіюйте. Вставте його до поля формального виразу у верхній частині вікна. Якщо у ньому мають бути змінні частини, наприклад номери сторінок, скористайтеся наборами та кванторами для заміни цих частин. Роблячи це, не забувайте про екранування спеціальних символів, якщо вони є у виразі. Натисніть кнопку з міткою :guilabel:`Тест`, і calibre позначить фрагменти тексту, які було б замінено, якби було використано формальний вираз. Якщо все гаразд, натисніть кнопку :guilabel:`Гаразд` і виконайте перетворення. Будьте обережні, якщо у початковому тексті містяться мітки, як у цьому прикладі::"

#: ../../home/kovid/work/calibre/manual/regexp.rst:108
msgid ""
"(shamelessly ripped out of `this thread "
"<https://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point.) The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what calibre will remove to make sure you don't remove any"
" portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, calibre tries to repair the damaged code after doing the"
" removal."
msgstr "(безсовісно запозичено з `цього обговорення <https://www.mobileread.com/forums/showthread.php?t=75594\">`_). Вам варто також вилучити і ці теґи. У цьому прикладі рекомендуємо почати з теґу ``<b class=\"calibre2\">``. Далі, вам слід розібратися із відповідним кінцевим теґом (початковими теґами є теґи ``<теґ>``, а кінцевими теґами є теґи ``</теґ>``), яким у нашому прикладі є теґи ``</b>``. (Зверніться до підручника з HTML або запитайте на форумі, якщо маєте якісь питання щодо теґів.) Початковий теґ можна описати як ``<b.*?>``, а кінцевий теґ — ``</b>``. Таким чином, ми можемо вилучити усі дані між цими двома теґами за допомогою виразу ``<b.*?>.*?</b>``. Але не варто користуватися цим виразом, оскільки його використання призведе до вилучення усіх даних у теґах <b> (який, до речі, використовується для позначення тексту напівжирною гарнітурою). Можна закладатися, що таким чином ми вилучимо частину тексту книги. Замість цього, варто включити початок рядка у тезі, створивши формальний вираз ``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` Керівну послідовність ``\\s`` із кванторами використано замість явного використання пробілів, щоб знайти усі варіанти рядка, які може бути використано у тексті книги. Не забудьте, перевірити, що саме calibre вилучить, щоб переконатися, що не буде вилучено нічого зайвого, виконавши тестування виразу. Якщо ви перевірите лише один відповідник формального виразу, може так статися, що небажаний ефект все ж трапиться у якомусь іншому місці тексту. Також зауважте, що якщо випадково буде вилучено більше або менше теґів, ніж ви хотіли б вилучити, calibre спробує виправити некоректний код після вилучення."

#: ../../home/kovid/work/calibre/manual/regexp.rst:111
msgid "Adding books"
msgstr "Додавання книг"

#: ../../home/kovid/work/calibre/manual/regexp.rst:113
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that calibre won't extract any meaningful data out"
" of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"calibre provides, you need to add the file extension to your testing "
"filename, otherwise you won't get any matches at all, despite using a "
"working expression."
msgstr "Ще одним випадком використання формальних виразів є видобування метаданих з назв файлів. Доступ до цієї можливості здійснюється за допомогою розділу «Додавання книг» параметрів програми. Тут є особлива можливість: ви можете скористатися назвами полів метаданих, наприклад, ``(?P<title>)`` позначає, що calibre має використати цю частину рядка як назву (заголовок) книги. Доступні назви полів показано у списку разом із ще одним чудовим полем для тестування. Приклад: припустімо, ви хочете імпортувати багато файлів із назвами, які подібні до ``Класика: Божественна комедія написана Данте Аліг’єрі.mobi`` (звичайно ж, ця книга вже є у вашій бібліотеці, оскільки усі ми закохані у італійську поезію) або ``Класика наукової фантастики: Трилогія Фундація написана Айзек Азімов.epub``. Очевидно, така схема найменування не дасть типовій програмі calibre видобути корисні дані — стандартним є такий вираз для видобування метаданих: ``(?P<title>.+) - (?P<author>[^_]+)``. Формальним виразом, який спрацює є такий: ``[а-яґіїєА-ЯҐІЇЄ]+: (?P<title>.+) написана (?P<author>.+)``. Будь ласка, зауважте, що всередині групи для поля метаданих вам слід скористатися виразами для опису відповідного поля. Також зауважте, що при використанні поля тестування calibre вам слід додати суфікс назви файла до тестової назви, інакше відповідників не буде знайдено взагалі, хоча вираз і буде працездатним."

#: ../../home/kovid/work/calibre/manual/regexp.rst:117
msgid "Bulk editing metadata"
msgstr "Пакетне редагування метаданих"

#: ../../home/kovid/work/calibre/manual/regexp.rst:119
msgid ""
"The last part is regular expression search and replace in metadata fields. "
"You can access this by selecting multiple books in the library and using "
"bulk metadata edit. Be very careful when using this last feature, as it can "
"do **Very Bad Things** to your library! Doublecheck that your expressions do"
" what you want them to using the test fields, and only mark the books you "
"really want to change! In the regular expression search mode, you can search"
" in one field, replace the text with something and even write the result "
"into another field. A practical example: Say your library contained the "
"books of Frank Herbert's Dune series, named after the fashion ``Dune 1 - "
"Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get ``Dune`` "
"into the series field. You can do that by searching for ``(.*?) \\d+ - .*`` "
"in the title field and replacing it with ``\\1`` in the series field. See "
"what I did there? That's a reference to the first group you're replacing the"
" series field with. Now that you have the series all set, you only need to "
"do another search for ``.*? -`` in the title field and replace it with "
"``\"\"`` (an empty string), again in the title field, and your metadata is "
"all neat and tidy. Isn't that great? By the way, instead of replacing the "
"entire field, you can also append or prepend to the field, so, if you "
"*wanted* the book title to be prepended with series info, you could do that "
"as well. As you by now have undoubtedly noticed, there's a checkbox labeled "
":guilabel:`Case sensitive`, so you won't have to use flags to select "
"behaviour here."
msgstr "Останнім розглянемо використання формальних виразів для пошуку із заміною у полях метаданих. Отримати доступ до цього інструмента можна позначивши декілька книг у списку бібліотеки і натиснувши кнопку пакетного редагування метаданих. Будьте обережні з використанням пакетного редагування, оскільки помилки у ньому можуть призвести до **дуже поганих наслідків** для вашої бібліотеки! Двічі перевірте, чи правильно працюють ваші вирази, за допомогою полів тестування. Позначайте лише ті книги, які дійсно потребують змін! У режимі пошуку за формальними виразами ви можете виконувати пошук у одному полі, замінювати чимось текст і навіть записувати результат заміни до іншого поля. Приклад з практики: припустімо, у вашій бібліотеці є книги з циклу «Дюна» Френка Герберта, як названо так: ``Дюна 1 - Дюна``, ``Дюна 2 - Месія Дюни`` тощо. Вам потрібно записати у поле циклу рядок ``Дюна``. Зробити це можна, виконавши пошук ``(.*?) \\d+ - .*`` у полі назви книги із заміною вмісту поля циклу на ``\\1``. Зрозуміли, як усе зроблено? Ми замінюємо вміст поля циклу на посилання на першу групу з поля назви. Тепер, коли дані записано до поля циклу, можна виконати ще один пошук ``.*? -`` у полі назви і замінити знайдену назву циклу на ``\"\"`` (порожній рядок). Після цього метадані ваших книг набудуть послідовного та компактного вигляду. Хіба це не чудово? До речі, замість заміни усього поля, ви можете дописати до його поточного вмісту дані на початку або наприкінці. Отже, якщо ви *хочете* дописати перед назвою книги назву циклу, це також можна зробити. Як ви вже, поза всяким сумнівом, знаєте, у вікні є пункт :guilabel:`З урахуванням регістру`, отже для зміни поведінки засобу обробки формальних виразів немає потреби у використанні прапорців."

#: ../../home/kovid/work/calibre/manual/regexp.rst:121
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<https://docs.python.org/2/library/re.html>`_."
msgstr "Гаразд, на цьому можна і завершити дуже короткий вступ щодо формальних виразів. Сподіваємося, ми показали вам достатньо, щоб принаймні створити початкові враження і уможливити ваше подальше самостійне навчання. Продовжити вивчення формальних виразів можна за допомогою `документації з формальних виразів у Python <https://docs.python.org/2/library/re.html>`_."

#: ../../home/kovid/work/calibre/manual/regexp.rst:123
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. calibre provides really great testing possibilities to see if"
" your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...) But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Втім, наостанок маємо вас попередити: формальні вирази є потужним, але дуже примхливим інструментом. У calibre передбачено справді чудові можливості для перегляду результатів роботи ваших виразів. Скористайтеся ними. Намагайтеся не прострелити собі ногу (Боже, як мені подобається цей вираз...) Якщо ж, попри це попередження, трапляться якісь неприємності, лікуйте вашу ногу (або інші частини тіла), намагайтеся вивчити навчитися і з невдач."

#: ../../home/kovid/work/calibre/manual/regexp.rst:127
msgid "Quick reference"
msgstr "Короткий довідник"

#: ../../home/kovid/work/calibre/manual/regexp.rst:135
msgid "Credits"
msgstr "Подяки"

#: ../../home/kovid/work/calibre/manual/regexp.rst:137
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Дякуємо за підказки, виправлення та настанови:"

#: ../../home/kovid/work/calibre/manual/regexp.rst:139
msgid "ldolse"
msgstr "ldolse"

#: ../../home/kovid/work/calibre/manual/regexp.rst:140
msgid "kovidgoyal"
msgstr "kovidgoyal"

#: ../../home/kovid/work/calibre/manual/regexp.rst:141
msgid "chaley"
msgstr "chaley"

#: ../../home/kovid/work/calibre/manual/regexp.rst:142
msgid "dwanthny"
msgstr "dwanthny"

#: ../../home/kovid/work/calibre/manual/regexp.rst:143
msgid "kacir"
msgstr "kacir"

#: ../../home/kovid/work/calibre/manual/regexp.rst:144
msgid "Starson17"
msgstr "Starson17"

#: ../../home/kovid/work/calibre/manual/regexp.rst:145
msgid "Orpheu"
msgstr "Orpheu"

#: ../../home/kovid/work/calibre/manual/regexp.rst:147
msgid ""
"For more about regexps see `The Python User Manual "
"<https://docs.python.org/2/library/re.html>`_."
msgstr "Докладніше про формальні вирази можна дізнатися з `Підручника користувача Python <https://docs.python.org/2/library/re.html>`_."
