# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Jonatan Nyberg, 2016-2017
# Jonatan Nyberg, 2017-2018
# Merarom <merarom@yahoo.es>, 2014-2017
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-06 07:39+0530\n"
"PO-Revision-Date: 2018-04-13 16:11+0000\n"
"Last-Translator: Jonatan Nyberg\n"
"Language-Team: Swedish (http://www.transifex.com/calibre/calibre/language/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../home/kovid/work/calibre/manual/db_api.rst:4
msgid "API documentation for the database interface"
msgstr "API-dokumentation för databasgränssnittet"

#: ../../home/kovid/work/calibre/manual/db_api.rst:9
msgid ""
"This API is thread safe (it uses a multiple reader, single writer locking "
"scheme).  You can access this API like this::"
msgstr "Denna API är trådsäker (använder en flerläsare-, singelskrivar-utelåsningsschema). Du kan komma åt denna API så här::"

#: ../../home/kovid/work/calibre/manual/db_api.rst:14
msgid ""
"If you are in a calibre plugin that is part of the main calibre GUI, you get"
" access to it like this instead::"
msgstr "Om du är i en calibre insticksmodul som är del av calibre huvudanvändargränssnittet, får du tillgång till det så här istället::"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache:1
msgid ""
"An in-memory cache of the metadata.db file from a calibre library. This "
"class also serves as a threadsafe API for accessing the database. The in-"
"memory cache is maintained in normal form for maximum performance."
msgstr "En in-minnescache av metadata.db filen från calibre-biblioteket. Denna klass fungerar också som en trådsäker API för komma åt databasen. Inminnecachen hanteras på normalt sätt för maximal prestanda."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache:5
msgid ""
"SQLITE is simply used as a way to read and write from metadata.db robustly. "
"All table reading/sorting/searching/caching logic is re-implemented. This "
"was necessary for maximum performance and flexibility."
msgstr "SQLITE används helt enkelt som ett stabilt sätt att läsa och skriva från metadata.db."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_books:1
msgid ""
"Add the specified books to the library. Books should be an iterable of "
"2-tuples, each 2-tuple of the form :code:`(mi, format_map)` where mi is a "
"Metadata object and format_map is a dictionary of the form :code:`{fmt: "
"path_or_stream}`, for example: :code:`{'EPUB': '/path/to/file.epub'}`."
msgstr "Lägg till angivna böcker till biblioteket. Böcker bör vara en uppräknelig mängd i multipel av 2, varje 2-mängdsgrupp i form av :code:`(mi, format_map)` var mi är ett metadataobjekt och format_map är en ordlista i formen :code:`{fmt: path_or_stream}`, till exempel :code:`{'EPUB': '/path/to/file.epub'}`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_books:6
msgid ""
"Returns a pair of lists: :code:`ids, duplicates`. ``ids`` contains the book "
"ids for all newly created books in the database. ``duplicates`` contains the"
" :code:`(mi, format_map)` for all books that already exist in the database "
"as per the simple duplicate detection heuristic used by :meth:`has_book`."
msgstr "Återger ett listpar: :code:`ids, duplicates`. ``id`` innehållande bokens identiteter för all nyligen skapade böcker i databasen. \"duplikat\" innehåller :code:`(mi, format_map)` for alla böcker som redan finns i databasen genom enkel heuristisk duplikationsdetektering använd av :meth:`has_book`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_custom_book_data:1
msgid ""
"Add data for name where val_map is a map of book_ids to values. If "
"delete_first is True, all previously stored data for name will be removed."
msgstr "Lägg till data för namn där val_map är en karta över book_ids till värden. Om delete_first är True kommer alla tidigare lagrade data för namn tas bort."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:1
msgid ""
"Add a format to the specified book. Return True if the format was added "
"successfully."
msgstr "Lägg till ett format i den angivna boken. Återge True om formatet har lagts till."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:0
msgid "Parameters"
msgstr "Parametrar"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:3
msgid ""
"If True replace existing format, otherwise if the format already exists, "
"return False."
msgstr "Om True ersätt befintligt format, annars om formatet redan finns, återges False"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:4
msgid ""
"If True, file type plugins are run on the format before and after being "
"added."
msgstr "Om True, körs filtyp insticksmodul på formatet innan och efter det tilläggs."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:5
msgid "Internal use only."
msgstr "Bara för internt bruk."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_book_ids:1
msgid "Frozen set of all known book ids."
msgstr "Frusen uppsättning av alla kända bokidentiteter."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_for:1
msgid "Same as field_for, except that it operates on multiple books at once"
msgstr "Samma som field_for, förutom att den opererar på flera böcker på samma gång"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_ids:1
msgid "Frozen set of ids for all values in the field ``name``."
msgstr "Frusen uppsättning av identiteter för alla värden i fältet \"namn\"."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_names:1
msgid ""
"Frozen set of all fields names (should only be used for many-one and many-"
"many fields)"
msgstr "Frusen uppsättning av alla fältnamn (bör bara användas för många till en och många till många fält)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_data:1
msgid "Return author data as a dictionary with keys: name, sort, link"
msgstr "Återger författardata som ordlista med nycklar: namn, sort, länk"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_data:3
msgid ""
"If no authors with the specified ids are found an empty dictionary is "
"returned. If author_ids is None, data for all authors is returned."
msgstr "Om inga författare med angivna identiteter hittas återges en tom ordlista. Om author_ids är None, återges data för alla författare."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_sort_from_authors:1
msgid ""
"Given a list of authors, return the author_sort string for the authors, "
"preferring the author sort associated with the author over the computed "
"string."
msgstr "Given en lista med författare, återge author_sort sträng för författare,  framför författarsortering associerad med författare över bearbetade strängen."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_for_field:1
msgid ""
"Return all the books associated with the item identified by ``item_id``, "
"where the item belongs to the field ``name``."
msgstr "Återger alla böcker associerade med posten identifierad av ``item_id``, där posten tillhör fältet  ``name``."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_for_field:4
msgid ""
"Returned value is a set of book ids, or the empty set if the item or the "
"field does not exist."
msgstr "Återgett värde är en mängd av bokidentiteter eller den tomma mängden om posten eller fältet inte finns."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_in_virtual_library:1
msgid "Return the set of books in the specified virtual library"
msgstr "Returnera uppsättning av böcker som angavs i virtuellt bibliotek"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.copy_cover_to:1
msgid ""
"Copy the cover to the file like object ``dest``. Returns False if no cover "
"exists or dest is the same file as the current cover. dest can also be a "
"path in which case the cover is copied to it if and only if the path is "
"different from the current path (taking case sensitivity into account)."
msgstr "Kopiera omslag till filen som objektet ``dest``. Återger False om inget omslag finns eller dest är samma fil som det aktuella omslaget. dest kan också vara en sökväg i vilket fall omslaget kopieras till det om och endast om sökvägen är en annan än den aktuella sökvägen (med små bokstäver i beräkningen)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.copy_format_to:1
msgid ""
"Copy the format ``fmt`` to the file like object ``dest``. If the specified "
"format does not exist, raises :class:`NoSuchFormat` error. dest can also be "
"a path, in which case the format is copied to it, iff the path is different "
"from the current path (taking case sensitivity into account)."
msgstr "Kopiera formatet ``fmt`` till filen som posten ``dest``. Om angivet format inte existerar, ger :class:`NoSuchFormat` fel. dest kan också vara en sökväg, i så fall kopieras formatet till den, om (och endast om) sökvägen är skilt i från aktuell sökväg (med beaktning på teckenskiftläge).\n\n\nReturnerar Sann om (och endast om) formatet existerar på disk"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:1
msgid ""
"Return the cover image or None. By default, returns the cover as a "
"bytestring."
msgstr "Återge omslagsbild eller inget. Som standard, återges omslag som en byte sträng."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:4
msgid ""
"WARNING: Using as_path will copy the cover to a temp file and return the "
"path to the temp file. You should delete the temp file when you are done "
"with it."
msgstr "VARNING: Använda as_path kommer att kopiera omslaget till en temporär fil och återge sökvägen till temporära filen. Du bör ta bort temporära filen när du är klar med den."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:8
msgid ""
"If True return the image as an open file object (a SpooledTemporaryFile)"
msgstr "Om True återger bilden som ett öppet filobjekt (en SpooledTemporaryFile)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:9
msgid "If True return the image as a QImage object"
msgstr "Om True återger bilden som ett Q-bildobjekt"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:10
msgid "If True return the image as a path pointing to a temporary file"
msgstr "Om True återger bilden som en sökväg till en temporärfil"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.data_for_find_identical_books:1
msgid ""
"Return data that can be used to implement :meth:`find_identical_books` in a "
"worker process without access to the db. See db.utils for an implementation."
msgstr "Återge uppgifter som kan användas för att implementera :meth:`find_identical_books` i en arbetsprocess utan tillgång till db. Se db.utils för en implementering"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.data_for_has_book:1
msgid ""
"Return data suitable for use in :meth:`has_book`. This can be used for an "
"implementation of :meth:`has_book` in a worker process without access to the"
" db."
msgstr "Återger data som är lämpliga för användning i :meth:'has_book`. Detta kan användas för en implementering av :meth:`has_book` i en arbetsprocess utan tillgång till db."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.delete_custom_book_data:1
msgid ""
"Delete data for name. By default deletes all data, if you only want to "
"delete data for some book ids, pass in a list of book ids."
msgstr "Ta bort uppgifter om namn. Som standard raderas all data, om du bara vill ta bort data för vissa bok identifierare, passera i en lista med bokidentifierare."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.embed_metadata:1
msgid ""
"Update metadata in all formats of the specified book_ids to current metadata"
" in the database."
msgstr "Uppdatera metadata i alla format av de angivna bok_ids till aktuell metadata i databasen."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.fast_field_for:1
msgid ""
"Same as field_for, except that it avoids the extra lookup to get the field "
"object"
msgstr "Samma som field_for, förutom att den undviker extra uppslag för att få fältobjektet"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:1
msgid ""
"Return the value of the field ``name`` for the book identified by "
"``book_id``. If no such book exists or it has no defined value for the field"
" ``name`` or no such field exists, then ``default_value`` is returned."
msgstr "Återge värdet av fältet ``name`` för boken som identifieras av ``book_id``. Om ingen sådan bok existerar eller inte har något definierat värde för fältet ``name`` eller inget sådant fält finns, så återges ``default_value``."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:6
msgid ""
"``default_value`` is not used for title, title_sort, authors, author_sort "
"and series_index. This is because these always have values in the db. "
"``default_value`` is used for all custom columns."
msgstr "``default_value`` används inte för title, title_sort, authors, author_sort och series_index. Detta för dessa alltid har värden i databasen ``default_value`` används för anpassade kolumner."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:10
msgid ""
"The returned value for is_multiple fields are always tuples, even when no "
"values are found (in other words, default_value is ignored). The exception "
"is identifiers for which the returned value is always a dict. The returned "
"tuples are always in link order, that is, the order in which they were "
"created."
msgstr "Det återgivna värdet för is_multiple fält är alltid tupler, även om inga värden finns (med andra ord, default_value ignoreras). Undantaget är identifierare som det återgav värdet alltid är en 'dict'. De återgivna tuplerna är alltid i länkordning, det vill säga i vilken ordning de skapades."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_ids_for:1
msgid ""
"Return the ids (as a tuple) for the values that the field ``name`` has on "
"the book identified by ``book_id``. If there are no values, or no such book,"
" or no such field, an empty tuple is returned."
msgstr "Återge id:ar (som en tupel) för de värden som fältet ``namn`` har på boken som identifieras av ``book_id``. Om det inte finns några värden, eller ingen sådan bok, eller något sådant fält, återges en tom tupel tillbaka."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.find_identical_books:1
msgid ""
"Finds books that have a superset of the authors in mi and the same title "
"(title is fuzzy matched). See also :meth:`data_for_find_identical_books`."
msgstr "Hittar böcker som har en övermängd av författarna i mi och samma titel (titeln är luddig matchas). Se även :meth:'data_for_find_identical_books`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:1
msgid ""
"Return the e-book format as a bytestring or `None` if the format doesn't "
"exist, or we don't have permission to write to the e-book file."
msgstr "Återge e-bokformat som en oktettsträng eller `None` om formatet inte finns, eller att vi inte har behörighet att skriva till e-bokfilen."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:4
msgid ""
"If True the e-book format is returned as a file object. Note that the file "
"object is a SpooledTemporaryFile, so if what you want to do is copy the "
"format to another file, use :meth:`copy_format_to` instead for performance."
msgstr "Om True återges e-bokformat som ett filobjekt. Observera att filobjektet är en SpooledTemporaryFile, så om vad du vill göra är att kopiera formatet till en annan fil, använd: meth: `copy_format_to` stället för utförande."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:8
msgid ""
"Copies the format file to a temp file and returns the path to the temp file"
msgstr "Kopierar formatet filen till en temp fil och återger sökvägen till temp filen"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:10
msgid ""
"If True and returning a path the filename is the same as that used in the "
"library. Note that using this means that repeated calls yield the same temp "
"file (which is re-created each time)"
msgstr "Om True och återges en sökväg, filnamnet är samma som den som används i biblioteket. Observera att detta innebär att upprepade anrop ger samma temp fil (som återskapas varje gång)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:1
msgid ""
"Return absolute path to the e-book file of format `format`. You should "
"almost never use this, as it breaks the threadsafe promise of this API. "
"Instead use, :meth:`copy_format_to`."
msgstr "Återge absolut sökväg till e-bokfilen i formatet `format`. Du bör nästan aldrig använda det, eftersom det bryter trådsäkerhetsgarantin i detta API. Använd istället, :meth:`copy_format_to`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:5
msgid ""
"Currently used only in calibredb list, the viewer, edit book, compare_format"
" to original format, open with, bulk metadata edit and the catalogs (via "
"get_data_as_dict())."
msgstr "Används för närvarande endast i calibredb-listan, visaren, redigera boken, compare_format till originalformat, öppna med, redigera bulkmetadata och katalogerna (via get_data_as_dict ())."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:9
msgid ""
"Apart from the viewer, open with and edit book, I don't believe any of the "
"others do any file write I/O with the results of this call."
msgstr "Bortsett från visaren, öppna med och redigera boken, tror jag inte någon av de andra gör någon filskrivnings-I/O med resultaten av detta anrop."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_hash:1
msgid ""
"Return the hash of the specified format for the specified book. The kind of "
"hash is backend dependent, but is usually SHA-256."
msgstr "Återge hash för det angivna formatet för den angivna boken. Den typ av hash är algoritmberoende, men är oftast SHA-256."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:1
msgid ""
"Return the path, size and mtime for the specified format for the specified "
"book. You should not use path unless you absolutely have to, since accessing"
" it directly breaks the threadsafe guarantees of this API. Instead use the "
":meth:`copy_format_to` method."
msgstr "Återge sökväg, storlek och mtime för det specifika formatet för den specifika boken. Du bör inte använda sökväg  annat om du absolut måste, eftersom direkt tillgång av den förstör trådsäkerhetsgarantin av denna API. Istället använd :meth:`copy_format_to` metoden."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:6
msgid ""
"If ``True`` cached values are used, otherwise a slow filesystem access is "
"done. The cache values could be out of date if access was performed to the "
"filesystem outside of this API."
msgstr "Om True, används cachade värden, annars sker en långsam filsystem tillgång. Cache-värden kan vara utdaterade om tillgång sker till filsystem utanför detta API."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:10
msgid ""
"If ``True`` The max_size field of the database is updated for this book."
msgstr "Om True är max_size-fältet av databasen uppdaterad för denna bok."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.formats:1
msgid ""
"Return tuple of all formats for the specified book. If verify_formats is "
"True, verifies that the files exist on disk."
msgstr "Återge tupel av alla format för den specifika boken. Om verify_formats är True verifieras att filer existerar på disken."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_categories:1
msgid "Used internally to implement the Tag Browser"
msgstr "Används internt för att implementera Etikettbläddraren"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_custom_book_data:1
msgid ""
"Get data for name. By default returns data for all book_ids, pass in a list "
"of book ids if you only want some data. Returns a map of book_id to values. "
"If a particular value could not be decoded, uses default for it."
msgstr "Hämta data för namn. Som standard återges data för alla book_ids, förse med en lista med bokidentifierare om du bara vill  ha några data. Återger en översikt av book_id till värden. Om en speciellt värde inte kan identifieras, används istället standardvärde för den."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_id_map:1
msgid ""
"Return a mapping of id numbers to values for the specified field. The field "
"must be a many-one or many-many field, otherwise a ValueError is raised."
msgstr "Återge en översik av id nummer till värden för specifika fält. Fältet måste vara en många-en eller många-många fält, annars genereras ett ValueError."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_ids_for_custom_book_data:1
msgid "Return the set of book ids for which name has data."
msgstr "Återge en uppsättning bok id för vilket namn har data."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_id:1
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_ids:1
msgid "Return the item id for item_name (case-insensitive)"
msgstr "Återge posten id för item_name (skiftlägesokänslig)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_name:1
msgid ""
"Return the item name for the item specified by item_id in the specified "
"field. See also :meth:`get_id_map`."
msgstr "Återge postnamnet för posten som anges av item_id i specificerat fält. Se också :meth:`get_id_map`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_metadata:1
msgid ""
"Return metadata for the book identified by book_id as a "
":class:`calibre.ebooks.metadata.book.base.Metadata` object. Note that the "
"list of formats is not verified. If get_cover is True, the cover is "
"returned, either a path to temp file as mi.cover or if cover_as_data is True"
" then as mi.cover_data."
msgstr "Återge metadata för boken identifierat av book_id som ett :class:`calibre.ebooks.metadata.book.base.Metadata` objekt. Observera att listan av format inte är verifierad. Om get_cover är True, kommer omslag att återges, antingen som en sökväg till temporärfilen mi.cover eller om cover_as_data är Sant som mi.cover_data."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:1
msgid ""
"Return the next series index for the specified series, taking into account "
"the various preferences that control next series number generation."
msgstr "Återge nästa serieindex för den specifika serien, med beaktning av olika förval som styr generering av nästa serienummer."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:4
msgid "The series-like field (defaults to the builtin series column)"
msgstr "Serielikt fält (som standard för inbyggda seriekolumnen)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:5
msgid ""
"If True, returns a mapping of book_id to current series_index value instead."
msgstr "Om True, återger en översikt av book_id till aktuell serie_index-värde istället."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_proxy_metadata:1
msgid ""
"Like :meth:`get_metadata` except that it returns a ProxyMetadata object that"
" only reads values from the database on demand. This is much faster than "
"get_metadata when only a small number of fields need to be accessed from the"
" returned metadata object."
msgstr "Liksom: meth: `get_metadata` förutom att den återger ett ProxyMetadata-objekt som bara läser värden från databasen på förfrågan. Det är mycket snabbare än get_metadata när endast ett mindre antal fält behöver nås från återgett metadataobjekt."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_usage_count_by_id:1
msgid ""
"Return a mapping of id to usage count for all values of the specified field,"
" which must be a many-one or many-many field."
msgstr "Återge en översikt av id till räkningsanvändning för alla värden på det angivna fältet, som måste vara en många-en eller många-många fält."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_book:1
msgid ""
"Return True iff the database contains an entry with the same title as the "
"passed in Metadata object. The comparison is case-insensitive. See also "
":meth:`data_for_has_book`."
msgstr "Återge True om och endast om databasen innehåller en post med samma titel som den angivna i metadataobjektet. Jämförelsen är skiftlägeskänsliga . Se även :meth:'data_for_has_book`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_format:1
msgid "Return True iff the format exists on disk"
msgstr "Återge True om (och endast om) formatet existerar på disk"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_id:1
msgid "Return True iff the specified book_id exists in the db"
msgstr "Återge True om (och endast om) specificerat bok_id existerar i db"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.init:1
msgid "Initialize this cache with data from the backend."
msgstr "Initialisera denna buffring med data från fjärrsidan."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.multisort:1
msgid ""
"Return a list of sorted book ids. If ids_to_sort is None, all book ids are "
"returned."
msgstr "Återge en lista med sorterade bokidentifierare. Om ids_to_sort är  None, kommer alla bokidentifierare att återges."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.multisort:4
msgid ""
"fields must be a list of 2-tuples of the form (field_name, ascending=True or"
" False). The most significant field is the first 2-tuple."
msgstr "fälten måste vara en lista med 2-tupler av formatet (field_name, ascending=True eller False). Det mest signifikata fältet är den första 2-tupeln."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.pref:1
msgid ""
"Return the value for the specified preference or the value specified as "
"``default`` if the preference is not set."
msgstr "Återge värdet för det specifika förvalet eller värdet angivet som ``standard`` om inget förval är angivet."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.read_backup:1
msgid ""
"Return the OPF metadata backup for the book as a bytestring or None if no "
"such backup exists."
msgstr "Återge OPF metadatalagringen för boken som en oktettsträng eller None om ingen sådan lagrad finns."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_books:1
msgid ""
"Remove the books specified by the book_ids from the database and delete "
"their format files. If ``permanent`` is False, then the format files are "
"placed in the recycle bin."
msgstr "Ta bort böckerna angivna av book_ids från databasen och tar bort deras formatfiler. Om ``permanent`` är False, så kommer formatfiler placeras i papperskorgen."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:1
msgid "Remove the specified formats from the specified books."
msgstr "Ta bort angivna format från angivna böcker."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:3
msgid "A mapping of book_id to a list of formats to be removed from the book."
msgstr "En översikt av book_id till en lista med format som ska tas bort från boken."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:4
msgid ""
"If True, only remove the record for the format from the db, do not delete "
"the actual format file from the filesystem."
msgstr "Om True, tas bara handlingen av format från databasen, tar inte bort de aktuella filformaten från filsystemet."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_items:1
msgid ""
"Delete all items in the specified field with the specified ids. Returns the "
"set of affected book ids. ``restrict_to_book_ids`` is an optional set of "
"books ids. If specified the items will only be removed from those books."
msgstr "Radera alla objekt i det angivna fältet med de angivna id. Återger uppsättningen påverkade bok-id. ``restrict_to_book_ids`` är en valfri uppsättning bok-id. Om specificerat,  kommer endast objekten att tas bort från dessa böcker."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:1
msgid ""
"Rename items from a many-one or many-many field such as tags or series."
msgstr "Byt namn på objekt från många-en eller många-många fält som etiketter eller serier."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:3
msgid ""
"When renaming in a series-like field also change the series_index values."
msgstr "Vid namnändring i en serielikt fält förändras även series_index-värden."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:4
msgid ""
"An optional set of book ids for which the rename is to be performed, "
"defaults to all books."
msgstr "En valfri uppsättning bok-id där namnbyte ska utföras, standard för alla böcker."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.restore_book:1
msgid ""
"Restore the book entry in the database for a book that already exists on the"
" filesystem"
msgstr "Återställer bokuppslaget i databasen för en bok som redan finns i filsystemet."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.restore_original_format:1
msgid ""
"Restore the specified format from the previously saved ORIGINAL_FORMAT, if "
"any. Return True on success. The ORIGINAL_FORMAT is deleted after a "
"successful restore."
msgstr "Återställer det angivna formatet från tidigare sparat ORIGINAL_FORMAT, om något. Återger True vid framgång. The ORIGINAL_FORMAT tas bort efter en lyckad återställning."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.safe_read_lock:1
msgid ""
"A safe read lock is a lock that does nothing if the thread already has a "
"write lock, otherwise it acquires a read lock. This is necessary to prevent "
"DowngradeLockErrors, which can happen when updating the search cache in the "
"presence of composite columns. Updating the search cache holds an exclusive "
"lock, but searching a composite column involves reading field values via "
"ProxyMetadata which tries to get a shared lock. There may be other scenarios"
" that trigger this as well."
msgstr "Ett säker läsningslås är ett lås som gör ingenting om tråden redan har en skrivlås, annars begärs ett läslås. Detta är nödvändigt för att förhindra DowngradeLockErrors, vilket kan ske vid uppdatering av sökningen bufferten i närvaro av kompositkolumner. Uppdatering av sökningen bufferten har ett exklusivt lås, men söker en sammansatt kolumn vilket innebär läsning av fältvärden via ProxyMetadata som försöker att få ett delat lås. Det kan finnas andra scenarier som utlöser detta."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.safe_read_lock:9
msgid ""
"This property returns a new lock object on every access. This lock object is"
" not recursive (for performance) and must only be used in a with statement "
"as ``with cache.safe_read_lock:`` otherwise bad things will happen."
msgstr "Den här egenskapen återger ett nytt låsobjekt på varje åtkomst. Detta låsobjekt är inte rekursivt (för prestanda) och får endast användas i ett med uttalande som ``with cache.safe_read_lock:`` annars kommer dåliga saker att hända."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.save_original_format:1
msgid ""
"Save a copy of the specified format as ORIGINAL_FORMAT, overwriting any "
"existing ORIGINAL_FORMAT."
msgstr "Spara en kopia i angivet format som ORIGINAL_FORMAT, skriver över alla befintliga ORIGINAL_FORMAT."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:1
msgid ""
"Search the database for the specified query, returning a set of matched book"
" ids."
msgstr "Söker i databasen med angiven sökning, återger en uppsättning av matchade bok id:ar."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:3
msgid ""
"A restriction that is ANDed to the specified query. Note that restrictions "
"are cached, therefore the search for a AND b will be slower than a with "
"restriction b."
msgstr "En begränsning som är ANDad med angiven förfrågan. Observera att restriktioner lagras i cache, alltså sökandet efter a AND b kommer att vara långsammare än a med restriktion b."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:6
msgid "Used internally (virtual fields such as on_device to search over)."
msgstr "Använt internt (virtuella fält som on_device för söka efter)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:8
msgid ""
"If not None, a set of book ids for which books will be searched instead of "
"searching all books."
msgstr "Om inte None, en uppsättning bok id:ar där böckerna kommer att sökas istället för att söka alla böcker."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_conversion_options:1
msgid "options must be a map of the form {book_id:conversion_options}"
msgstr "alternativ måste vara en översikt på formen {book_id:conversion_options}"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_cover:1
msgid ""
"Set the cover for this book.  data can be either a QImage, QPixmap, file "
"object or bytestring. It can also be None, in which case any existing cover "
"is removed."
msgstr "Ange omslag för denna bok. data kan antingen vara en QImage, QPixmap, filobjekt eller oktettsträng. Det kan också vara None, i fallet omslag är borttaget."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:1
msgid ""
"Set the values of the field specified by ``name``. Returns the set of all "
"book ids that were affected by the change."
msgstr "Ange värden av fält angivna av  ``name``. Återger uppsättningen av bok id:ar som påverkades av förändringen."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:3
msgid "Mapping of book_ids to values that should be applied."
msgstr "Översikt av book_ids till värden som bör tillämpas."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:4
msgid ""
"If True, the case of many-one or many-many fields will be changed. For "
"example, if a  book has the tag ``tag1`` and you set the tag for another "
"book to ``Tag1`` then the both books will have the tag ``Tag1`` if "
"allow_case_change is True, otherwise they will both have the tag ``tag1``."
msgstr "Om True, i fall det rör sig om många-en eller många-många fälten förändras. Till exempel, om en bok har etiketten ``tag1`` och du anger etiketten för en annan bok till ``Tag1`` då kommer båda böckerna att ha etiketten ``Tag1`` om allow_case_change är True, annars kommer de båda ha etiketten ``tag1``."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:8
msgid "Used internally, you should never change it."
msgstr "Används internt, du bör aldrig ändra den."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_metadata:1
msgid "Set metadata for the book `id` from the `Metadata` object `mi`"
msgstr "Ange metadata för boken `id` från `Metadata`-objektet `mi`"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_metadata:3
msgid ""
"Setting force_changes=True will force set_metadata to update fields even if "
"mi contains empty values. In this case, 'None' is distinguished from "
"'empty'. If mi.XXX is None, the XXX is not replaced, otherwise it is. The "
"tags, identifiers, and cover attributes are special cases. Tags and "
"identifiers cannot be set to None so they will always be replaced if "
"force_changes is true. You must ensure that mi contains the values you want "
"the book to have. Covers are always changed if a new cover is provided, but "
"are never deleted. Also note that force_changes has no effect on setting "
"title or authors."
msgstr "När man sätter force_changes=True tvingas set_metadata att uppdatera fält, även om mi innehåller tomma värden. I det här fallet är \"None\" skiljt från \"empty\". Om mi.XXX är None ersätts XXX inte, annars görs det. Etiketter, identifierare, och omslagsattribut är specialfall. Etiketter och identifierare kan inte ställas in på None för då kommer de alltid ersättas om force_changes är True. Du måste se till att mi innehåller de värden som du vill att boken ska ha. Omlslag förändras alltid om ett nytt omslag finns, men de raderas aldrig . Observera också att force_changes har ingen effekt på inställningen titel eller författare."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_pref:1
msgid ""
"Set the specified preference to the specified value. See also :meth:`pref`."
msgstr "Ange angivna förval till de angivna värdet. Se också :meth:`pref`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:1
msgid ""
"Return the ids of all books having the tag ``tag`` that are older than the "
"specified time. tag comparison is case insensitive."
msgstr "Återge id av alla böcker som har etiketten ``etikett`` som är äldre än den angivna tiden. etikettjämförelse är skiftlägesoberoende."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:4
msgid ""
"A timedelta object or None. If None, then all ids with the tag are returned."
msgstr "En timedelta-objekt eller None. Om None kommer alla id:ar med etiketten återges."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:7
msgid ""
"If not None the list of matches will be restricted to books that have this "
"tag"
msgstr "Om inte None listan av träffar kommer begränsas till böcker som har denna etikett"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:10
msgid ""
"A list of authors. If not None the list of matches will be restricted to "
"books that have these authors (case insensitive)."
msgstr "En lista med författare. Om inte None listan av träffar kommer begränsas till böcker som har dessa författare (skiftlägesokänslig)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.user_categories_for_books:1
msgid ""
"Return the user categories for the specified books. proxy_metadata_map is "
"optional and is useful for a performance boost, in contexts where a "
"ProxyMetadata object for the books already exists. It should be a mapping of"
" book_ids to their corresponding ProxyMetadata objects."
msgstr "Återge användarkategorier för de angivna böckerna. proxy_metadata_map är valfritt och är användbar för en prestandaökning, i sammanhang där ett ProxyMetadata objekt för böckerna redan finns. Det bör vara en korsreferens av book_ids till deras motsvarande ProxyMetadata objekt."
