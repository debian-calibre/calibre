# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Çağla Turhan, 2016
# tarakbumba <tarakbumba@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-06 07:39+0530\n"
"PO-Revision-Date: 2018-04-06 02:09+0000\n"
"Last-Translator: Kovid Goyal <kovid@kovidgoyal.net>\n"
"Language-Team: Turkish (http://www.transifex.com/calibre/calibre/language/tr/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: tr\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../home/kovid/work/calibre/manual/db_api.rst:4
msgid "API documentation for the database interface"
msgstr "Veri tabanı arayüzü için API belgelendirmesi"

#: ../../home/kovid/work/calibre/manual/db_api.rst:9
msgid ""
"This API is thread safe (it uses a multiple reader, single writer locking "
"scheme).  You can access this API like this::"
msgstr "Bu API süreç güvenlidir (çoklu okuma, tekil yazmalı kitleme şeması kullanır).  API'ye şu şekilde erişebilirsiniz::"

#: ../../home/kovid/work/calibre/manual/db_api.rst:14
msgid ""
"If you are in a calibre plugin that is part of the main calibre GUI, you get"
" access to it like this instead::"
msgstr "Eğer ana calibre GUI'sinin bir parçası olan bir calibre eklentisi içindeyseniz, erişimi şu şekilde sağlayabilirsiniz::"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache:1
msgid ""
"An in-memory cache of the metadata.db file from a calibre library. This "
"class also serves as a threadsafe API for accessing the database. The in-"
"memory cache is maintained in normal form for maximum performance."
msgstr "Calibre kitaplığındaki bir metadata.db dosyasının bellekteki zulası. Bu sınıf ayrıca veri tabanına erişmek için süreç güvenli bir API olarak hizmet verir. Bellekteki zula en iyi performans için normal biçiminde devam ettirilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache:5
msgid ""
"SQLITE is simply used as a way to read and write from metadata.db robustly. "
"All table reading/sorting/searching/caching logic is re-implemented. This "
"was necessary for maximum performance and flexibility."
msgstr "SQLITE metadata.db'den kararlı şekilde okuma yazma yapma yöntemi olarak kullanılır. Tüm tablo okuma/sıralama/arama/zulalama mantığı tekrar uygulanmıştır. Bu işlem en iyi performans ve esneklik için gerekliydi."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_books:1
msgid ""
"Add the specified books to the library. Books should be an iterable of "
"2-tuples, each 2-tuple of the form :code:`(mi, format_map)` where mi is a "
"Metadata object and format_map is a dictionary of the form :code:`{fmt: "
"path_or_stream}`, for example: :code:`{'EPUB': '/path/to/file.epub'}`."
msgstr "Belirtilen kitapları kitaplığa ekle. Kitaplar, mi bir Metadata nesnesi ve format_map :code:`{fmt: path_or_stream}` biçiminde bir sözlük nesnesi olmak üzere her biri :code:`(mi, format_map)` biçiminde olan 2-tuple'ın yinelenebiliri olmalıdır, örneğin: :code:`{'EPUB': '/path/to/file.epub'}`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_books:6
msgid ""
"Returns a pair of lists: :code:`ids, duplicates`. ``ids`` contains the book "
"ids for all newly created books in the database. ``duplicates`` contains the"
" :code:`(mi, format_map)` for all books that already exist in the database "
"as per the simple duplicate detection heuristic used by :meth:`has_book`."
msgstr "Bir çift liste döndürür: :code:`ids, duplicates`. ``ids`` ver tabanında yeni oluşturulan tüm kitapların kitap id'lerini içerir. ``duplicates`` veri tabanında zaten mevcut olan ve :meth:`has_book` tarafından kullanılan basit çift algılama sezgiseline göre :code:`(mi, format_map)` içerir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_custom_book_data:1
msgid ""
"Add data for name where val_map is a map of book_ids to values. If "
"delete_first is True, all previously stored data for name will be removed."
msgstr "val_map book_ids'in değerlere haritası olmak üzere isimler için veri ekle. delete_first True ise, isim için daha önce kaydedilen tüm veri silinir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:1
msgid ""
"Add a format to the specified book. Return True if the format was added "
"successfully."
msgstr ""

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:0
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:0
msgid "Parameters"
msgstr "Parametreler"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:3
msgid ""
"If True replace existing format, otherwise if the format already exists, "
"return False."
msgstr "True ise varolan biçimi değiştir, eğer biçim zaten mevcutsa, False döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:4
msgid ""
"If True, file type plugins are run on the format before and after being "
"added."
msgstr "True ise, dosya türü eklentiler eklendikten önce ve sonra biçim üzerinde çalıştırılır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.add_format:5
msgid "Internal use only."
msgstr "Sadece dahili kullanım için."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_book_ids:1
msgid "Frozen set of all known book ids."
msgstr "Bilinen tüm kitap id'lerinin dondurulmuş kümesi."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_for:1
msgid "Same as field_for, except that it operates on multiple books at once"
msgstr "field_for'un aynısı, farkı birden ço kitap üstünde tek seferde çalışması"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_ids:1
msgid "Frozen set of ids for all values in the field ``name``."
msgstr "``name`` alanındaki tüm değerler için id'lerin donmuş kümesi."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.all_field_names:1
msgid ""
"Frozen set of all fields names (should only be used for many-one and many-"
"many fields)"
msgstr "Tüm alan isimlerinin dondurulmuş kümesi (sadece çoktan-bire ve çoktan-çoka alanlarda kullanılmalı)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_data:1
msgid "Return author data as a dictionary with keys: name, sort, link"
msgstr "Yazar verisini isim, sıralama, bağlantı anahtarlarından oluşan sözlük olarak döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_data:3
msgid ""
"If no authors with the specified ids are found an empty dictionary is "
"returned. If author_ids is None, data for all authors is returned."
msgstr "Belirtilen id'ye sahip yazar bulunamazsa boş bör sözlük döndürülür. author_id None ise, tüm authorların verisi döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.author_sort_from_authors:1
msgid ""
"Given a list of authors, return the author_sort string for the authors, "
"preferring the author sort associated with the author over the computed "
"string."
msgstr "Verilen bir yazar listesinden hesaplanan karakter dizisi üstündeki yazarla bağlantılı yazarı tercih ederek yazarlar için author_sort karakter dizisini döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_for_field:1
msgid ""
"Return all the books associated with the item identified by ``item_id``, "
"where the item belongs to the field ``name``."
msgstr "Öğe ``name`` alanına ait olmak üzere, ``item_id`` ile tanımlı öğe ile bağlantılı tüm kitapları döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_for_field:4
msgid ""
"Returned value is a set of book ids, or the empty set if the item or the "
"field does not exist."
msgstr "Döndürülen değer kitap id'leri kümesi, veya öğe veya alan mevcut değilse boş bir kümedir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.books_in_virtual_library:1
msgid "Return the set of books in the specified virtual library"
msgstr "Belirlenen sanal kitaplıktaki kitap setini döndürür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.copy_cover_to:1
msgid ""
"Copy the cover to the file like object ``dest``. Returns False if no cover "
"exists or dest is the same file as the current cover. dest can also be a "
"path in which case the cover is copied to it if and only if the path is "
"different from the current path (taking case sensitivity into account)."
msgstr "Kapağı dosya benzeri nesne ``dest``e kopyala. Kapak mevcut değilse veya dest mevcut kapakla aynı dosya ise False döndürür. dest, yalnızca yol mevcut yoldan farklı ise kapağın içine kopyalandığı bir yol olabilir (büyük küçük harf duyarlılığı da dikkate alınarak)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.copy_format_to:1
msgid ""
"Copy the format ``fmt`` to the file like object ``dest``. If the specified "
"format does not exist, raises :class:`NoSuchFormat` error. dest can also be "
"a path, in which case the format is copied to it, iff the path is different "
"from the current path (taking case sensitivity into account)."
msgstr "``fmt`` biçimini dosya benzeri nesne ``dest``e kopyala. Belirtilen biçim mevcut değilse, :class:`NoSuchFormat` hatası yükseltir. dest ayrıca yol mevcut yoldan farklı olmak şartıyla biçimin kopyalanacağı bir yol da olabilir (büyük küçük harf duyarlılığı dikkate alınarak)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:1
msgid ""
"Return the cover image or None. By default, returns the cover as a "
"bytestring."
msgstr "Kapak resmini veya None döndür. Varsayılan olarak kapağı bytestring olarak döndürür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:4
msgid ""
"WARNING: Using as_path will copy the cover to a temp file and return the "
"path to the temp file. You should delete the temp file when you are done "
"with it."
msgstr "UYARI: as_path kullanmak kapağı geçici bir dosyaya kopyalar ve geçici dosyanın yolunu döndürür. İşiniz bittiğinde geçici dosyayı silmelisiniz."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:8
msgid ""
"If True return the image as an open file object (a SpooledTemporaryFile)"
msgstr "True ise resmi bir açık dosya nesnesi (SpooledTemporaryFile) olarak döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:9
msgid "If True return the image as a QImage object"
msgstr "True ise resmi bir QImage nesnesi oalrak döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.cover:10
msgid "If True return the image as a path pointing to a temporary file"
msgstr "True ise resmi geçici bir dosyaya işaret eden yol olarak döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.data_for_find_identical_books:1
msgid ""
"Return data that can be used to implement :meth:`find_identical_books` in a "
"worker process without access to the db. See db.utils for an implementation."
msgstr "db'ye erişimi olmayan bir işçi süreçte :meth:`find_identical_books` uygulamak için kullanılabilecek veriyi döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.data_for_has_book:1
msgid ""
"Return data suitable for use in :meth:`has_book`. This can be used for an "
"implementation of :meth:`has_book` in a worker process without access to the"
" db."
msgstr ":meth:`has_book` içinde kullanmaya müsait veri döndür. Bu işlem db'ye erişimi olmayan bir işçi süreçte :meth:`has_book` uygulamak için kullanılabilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.delete_custom_book_data:1
msgid ""
"Delete data for name. By default deletes all data, if you only want to "
"delete data for some book ids, pass in a list of book ids."
msgstr "İsim için veriyi sil. Varsayılan olarak tüm veri silinir, yalnızca bazı kitap id'leri için veriyi silmek istiyorsanız, kitap id listesi verin."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.embed_metadata:1
msgid ""
"Update metadata in all formats of the specified book_ids to current metadata"
" in the database."
msgstr "Belirtilen book_id'lerinin tüm biçimleri içindeki metadata'yı mevcut veri tabanına güncelle."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.fast_field_for:1
msgid ""
"Same as field_for, except that it avoids the extra lookup to get the field "
"object"
msgstr "field_for ile aynı, yalnızca alan nesnesini almak için fazladan arama yapmaktan kaçınır"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:1
msgid ""
"Return the value of the field ``name`` for the book identified by "
"``book_id``. If no such book exists or it has no defined value for the field"
" ``name`` or no such field exists, then ``default_value`` is returned."
msgstr "``book_id`` ile belirtilen kitap için ``name`` alanının değerini döndür. Böyle bir kitap mevcut değilse veya ``name`` alanı için belirtilmiş bir değer yoksa veya böyle bir alan yoksa ``default_value`` döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:6
msgid ""
"``default_value`` is not used for title, title_sort, authors, author_sort "
"and series_index. This is because these always have values in the db. "
"``default_value`` is used for all custom columns."
msgstr "``default_value`` title, title_sort, authors, author_sort ve series_index için kullanılmaz. Bunun sebebi bunları hep db'de değerleri olmasıdır. ``default_value``tüm özel sütunlar için kullanılır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_for:10
msgid ""
"The returned value for is_multiple fields are always tuples, even when no "
"values are found (in other words, default_value is ignored). The exception "
"is identifiers for which the returned value is always a dict. The returned "
"tuples are always in link order, that is, the order in which they were "
"created."
msgstr "is_multiple alanları için döndürülen değerler hep tuple biçimindedir, hiçbir değer bulunamasa bile (başka bir deyişle, default_value göz ardı edilir). İstisna döndürülen değerin her zaman dict biçiminde olduğu identifier'ler durumundadır. Döndürülen tuple'ler her zaman bağlantı sırasındadır, yani oluşturulma sırasında."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.field_ids_for:1
msgid ""
"Return the ids (as a tuple) for the values that the field ``name`` has on "
"the book identified by ``book_id``. If there are no values, or no such book,"
" or no such field, an empty tuple is returned."
msgstr "``name`` alanının ``book_id`` ile tanımlanan kitaptaki değerleri için id'leri (demet olarak) döndür. Bir değer yoksa, ya da böyle bir kitap yoksa, veya böyle bir alan yoksa, boş bir demet döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.find_identical_books:1
msgid ""
"Finds books that have a superset of the authors in mi and the same title "
"(title is fuzzy matched). See also :meth:`data_for_find_identical_books`."
msgstr "Mi'deki yazarların üst setine sahip ve aynı başlıklı (başlıklarda bulanık eşleşme kullanılır) kitapları bulur. Ayrıca :meth:`data_for_find_identical_books` göz atın."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:1
msgid ""
"Return the e-book format as a bytestring or `None` if the format doesn't "
"exist, or we don't have permission to write to the e-book file."
msgstr "E-kitap biçimini bytestring olarak ya da biçim mevcut değilse, veya e-kitap dosyasına yazmaya yetkimiz yoksa `None` olarak döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:4
msgid ""
"If True the e-book format is returned as a file object. Note that the file "
"object is a SpooledTemporaryFile, so if what you want to do is copy the "
"format to another file, use :meth:`copy_format_to` instead for performance."
msgstr "True ise e-kitap biçimi dosya nesnesi olarak döndürülür. Dosya nesnesinin SpooledTemporaryFile olduğunu not edin, yani biçimi başka bir dosyaya kopyalamak istiyorsanız performans için bunun yerine :meth:`copy_format_to` kullanın. "

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:8
msgid ""
"Copies the format file to a temp file and returns the path to the temp file"
msgstr "Biçim dosyasını geçici bir dosyaya kopyalar ve geçici dosyanın yolunu döndürür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format:10
msgid ""
"If True and returning a path the filename is the same as that used in the "
"library. Note that using this means that repeated calls yield the same temp "
"file (which is re-created each time)"
msgstr "True ise ve bir yol döndürüyorsa, dosya adı kitaplıkta kullanılanla aynıdır. Bunun kullanımının tekrar kullanımlarda aynı geçici dosyayı döndüreceğini not edin (her seferinde tekrar oluşturulan)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:1
msgid ""
"Return absolute path to the e-book file of format `format`. You should "
"almost never use this, as it breaks the threadsafe promise of this API. "
"Instead use, :meth:`copy_format_to`."
msgstr "`format` biçimindeki e-kitap için mutlak yolu döndür. API'nin iş ipi güvenliğini kırdığından bunu hemen hemen hiç kullanmamalısınız. Bunun yerine :meth:`copy_format_to` kullanın."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:5
msgid ""
"Currently used only in calibredb list, the viewer, edit book, compare_format"
" to original format, open with, bulk metadata edit and the catalogs (via "
"get_data_as_dict())."
msgstr ""

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_abspath:9
msgid ""
"Apart from the viewer, open with and edit book, I don't believe any of the "
"others do any file write I/O with the results of this call."
msgstr "Görüntüleyici, birlikte aç ve kitap düzenleden ayrı olarak, diğerlerinin bu çağrı sonucu herhangi bir dosya yazma G/Ç yaptıklarını sanmıyorum."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_hash:1
msgid ""
"Return the hash of the specified format for the specified book. The kind of "
"hash is backend dependent, but is usually SHA-256."
msgstr "Belirtilen kitap için belirtilen biçimin özetini döndür. Özet türü arka uca bağlıdır, ama genellikle SHA-256'dır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:1
msgid ""
"Return the path, size and mtime for the specified format for the specified "
"book. You should not use path unless you absolutely have to, since accessing"
" it directly breaks the threadsafe guarantees of this API. Instead use the "
":meth:`copy_format_to` method."
msgstr "Belirtilen kitap için belirtilen biçimin yolunu, boyutunu ve değiştirilme zamanını döndürür. İlla kullanmanız gerekmiyorsa yolu kullanmamalısınız, çünkü yola erişmek bu API'nin iş ipi güvenliğini bozar. Bunun yerine :meth:`copy_format_to` metodunu kullanın."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:6
msgid ""
"If ``True`` cached values are used, otherwise a slow filesystem access is "
"done. The cache values could be out of date if access was performed to the "
"filesystem outside of this API."
msgstr "``True`` ise zuladaki değerler kullanılır, aksi halde yavaş bir dosya sistemine erişim gerçekleşir. Zula değerleri bu API dışından dosya sistemine erişildiyse eski olabilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.format_metadata:10
msgid ""
"If ``True`` The max_size field of the database is updated for this book."
msgstr "``True`` ise veri tabanındaki max_size alanı bu kitap için güncellenmiştir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.formats:1
msgid ""
"Return tuple of all formats for the specified book. If verify_formats is "
"True, verifies that the files exist on disk."
msgstr "Belirtilen kitap için tüm biçimlerin demetini getir. verify_formats True ise, dosyanın diskte var olduğunu da doğrular."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_categories:1
msgid "Used internally to implement the Tag Browser"
msgstr "Etiket Tarayıcıyı uygulamak için dahili olarak kullanılır"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_custom_book_data:1
msgid ""
"Get data for name. By default returns data for all book_ids, pass in a list "
"of book ids if you only want some data. Returns a map of book_id to values. "
"If a particular value could not be decoded, uses default for it."
msgstr "İsim için veri alır. Varsayılan olarak tüm book_id'leri için veriyi döndürür, sadece bazı veriler lazımsa kitap id'si listesi verin. book_id'den değere harita döndürür. Belli bir değerin kodu çözülemezse, varsayılan değerini kullanır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_id_map:1
msgid ""
"Return a mapping of id numbers to values for the specified field. The field "
"must be a many-one or many-many field, otherwise a ValueError is raised."
msgstr "Belirtilen alan için id numaralarından değerlere harita döndür. Alan bir çoktan teke veya çoktan çoka alan olmalıdır, aksi durumda ValueError yükseltilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_ids_for_custom_book_data:1
msgid "Return the set of book ids for which name has data."
msgstr "İsmin verisi olan kitap id'lerin kümesini döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_id:1
#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_ids:1
msgid "Return the item id for item_name (case-insensitive)"
msgstr "item_name için öğe id'sini döndür (büyük küçük harf duyarsız)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_item_name:1
msgid ""
"Return the item name for the item specified by item_id in the specified "
"field. See also :meth:`get_id_map`."
msgstr "Belirtilen alanda item_id ile belirtilen öğe için öğe ismini döndür. Ayrıca bknz :meth:`get_id_map`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_metadata:1
msgid ""
"Return metadata for the book identified by book_id as a "
":class:`calibre.ebooks.metadata.book.base.Metadata` object. Note that the "
"list of formats is not verified. If get_cover is True, the cover is "
"returned, either a path to temp file as mi.cover or if cover_as_data is True"
" then as mi.cover_data."
msgstr "kitap_id ile belirtilen üstveriyi :sınıf:`calibre.ekitaplar.üstveri.kitap.temel.Üstveri` nesnesi olarak döndür. Biçim listesinin doğrulanmadığını dikkate alın. Eğer kapak_al Doğru ise, kapak, ya mi.kapak olarak geçici dosyaya yol olarak ya da eğer kapak_veri_olarak Doğru ise o zaman mi.kapak_veri olarak döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:1
msgid ""
"Return the next series index for the specified series, taking into account "
"the various preferences that control next series number generation."
msgstr "Sıradaki seri numara üretecini kontrol eden çeşitli tercihleri hesaba katarak belirtilen seriler için sıradaki seri indisini döndür,."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:4
msgid "The series-like field (defaults to the builtin series column)"
msgstr "Seriler benzeri alan (yerleşik seriler sütunu varsayılır)"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_next_series_num_for:5
msgid ""
"If True, returns a mapping of book_id to current series_index value instead."
msgstr "True ise, book_id'den mevcut series_index değerine harita döndürür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_proxy_metadata:1
msgid ""
"Like :meth:`get_metadata` except that it returns a ProxyMetadata object that"
" only reads values from the database on demand. This is much faster than "
"get_metadata when only a small number of fields need to be accessed from the"
" returned metadata object."
msgstr "Veri tabanından değerleri yalnızca istek üstüne okuyan bir ProxyMetadata nesnesi döndürmesi dışında :meth:`get_metadata` gibidir. get_metadata'dan döndürülen metadata nesnesinden az sayıda alana erişilmesi gerektiğinde oldukça hızlıdır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.get_usage_count_by_id:1
msgid ""
"Return a mapping of id to usage count for all values of the specified field,"
" which must be a many-one or many-many field."
msgstr "Çoktan teke veya çoktan çoka alan olmak üzere belirtilen alanın tüm değerleri için id'den kullanım sayısına harita döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_book:1
msgid ""
"Return True iff the database contains an entry with the same title as the "
"passed in Metadata object. The comparison is case-insensitive. See also "
":meth:`data_for_has_book`."
msgstr "Veritabanı verilen Metadata nesnesiyle aynı başlığa sahip bir girdi içeriyorsa True döndürür. Karşılaştırma büyük küçük harf duyarsızdır. Ayrıca bknz :meth:`data_for_has_book`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_format:1
msgid "Return True iff the format exists on disk"
msgstr "Biçim diskte mevcutsa True döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.has_id:1
msgid "Return True iff the specified book_id exists in the db"
msgstr "Belirtilen book_id veri tabanında mevcutsa True döndür"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.init:1
msgid "Initialize this cache with data from the backend."
msgstr "Bu zulayı arka uçtaki veri ile ilklendir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.multisort:1
msgid ""
"Return a list of sorted book ids. If ids_to_sort is None, all book ids are "
"returned."
msgstr "Sıralanmış kitap id'leri listesi döndür. ids_to_sort None ise, tüm kitap id'leri döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.multisort:4
msgid ""
"fields must be a list of 2-tuples of the form (field_name, ascending=True or"
" False). The most significant field is the first 2-tuple."
msgstr "Alanlar (field_name, ascending=True veya False) biçiminde 2'li demet listesi olmalıdır. En önemli alan ilk ikili demettir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.pref:1
msgid ""
"Return the value for the specified preference or the value specified as "
"``default`` if the preference is not set."
msgstr "Belirtilen özellik için değeri ya da tercih belirtilmemişse ``default`` olarak belirtilen değeri döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.read_backup:1
msgid ""
"Return the OPF metadata backup for the book as a bytestring or None if no "
"such backup exists."
msgstr "Kitap için OPF metadata yedeğini bytestring olarak veya böyle bir backup yoksa None olarak döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_books:1
msgid ""
"Remove the books specified by the book_ids from the database and delete "
"their format files. If ``permanent`` is False, then the format files are "
"placed in the recycle bin."
msgstr "book_ids ile belirtilen kitapları veri tabanından biçim dosyalarıyla birlikte sil. ``permanent`` False ise, biçim dosyaları geri dönüşüm kutusuna yerleştirilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:1
msgid "Remove the specified formats from the specified books."
msgstr "Seçili biçimleri seçili kitaplardan çıkar."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:3
msgid "A mapping of book_id to a list of formats to be removed from the book."
msgstr "Kitaptan çıkarılacak book_id'den biçim listesine harita."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_formats:4
msgid ""
"If True, only remove the record for the format from the db, do not delete "
"the actual format file from the filesystem."
msgstr "True ise, biçim kaydını sadece veri tabanından çıkar, asıl biçimi dosya sisteminden silme."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.remove_items:1
msgid ""
"Delete all items in the specified field with the specified ids. Returns the "
"set of affected book ids. ``restrict_to_book_ids`` is an optional set of "
"books ids. If specified the items will only be removed from those books."
msgstr "Belirtilen alandaki belirtilen kimliğe sahip tüm öğeleri sil. Etkilenen kitap kimlikleri kümesini döndürür. ``restrict_to_book_ids`` isteğe bağlı kitap kimlikleri listesidir. Eğer belirtilirse öğeler yalnızca bu kitaplardan çıkartılır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:1
msgid ""
"Rename items from a many-one or many-many field such as tags or series."
msgstr "Etiketler veya seriler gibi çoktan teke veya çoktan çoka alanlarından öğeleri yeniden adlandır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:3
msgid ""
"When renaming in a series-like field also change the series_index values."
msgstr "Seri benzeri bir alanı yeniden adlandırırken series_index değerlerini de değiştir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.rename_items:4
msgid ""
"An optional set of book ids for which the rename is to be performed, "
"defaults to all books."
msgstr "Yeniden adlandırmanın yapılacağı isteğe bağlı kitap kimlikleri kümesi, varsayılan olarak tüm kitaplar."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.restore_book:1
msgid ""
"Restore the book entry in the database for a book that already exists on the"
" filesystem"
msgstr "Dosya sisteminde mevcut olan bir kitabın veri tabanındaki girdisini geri yükle"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.restore_original_format:1
msgid ""
"Restore the specified format from the previously saved ORIGINAL_FORMAT, if "
"any. Return True on success. The ORIGINAL_FORMAT is deleted after a "
"successful restore."
msgstr "Eğer varsa, belirtilen biçimi önceden kaydedilmiş ORIGINAL_FORMAT ile geri yükle. Başarılı olma durumunda True döndür. ORIGINAL_FORMAT başarılı geri yüklemenin ardından silinir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.safe_read_lock:1
msgid ""
"A safe read lock is a lock that does nothing if the thread already has a "
"write lock, otherwise it acquires a read lock. This is necessary to prevent "
"DowngradeLockErrors, which can happen when updating the search cache in the "
"presence of composite columns. Updating the search cache holds an exclusive "
"lock, but searching a composite column involves reading field values via "
"ProxyMetadata which tries to get a shared lock. There may be other scenarios"
" that trigger this as well."
msgstr "Güvenli okuma kilidi iş parçacığı zaten bir yazma kilidine sahipse hiçbir şey yapmayan, aksi durumda okuma kilidi edinen kilittir. Arama zulasını bileşik sütunlar önünde güncellerken oluşabilecek DowngradeLockErrors hatalarını önlemek için bu gereklidir. Arama zulasını güncellemek ayrıcalıklı bir kilit tutar, ama bileşik sütun araması paylaşılan bir kilit almaya çalışan ProxyMetadata kullanarak alan değerlerinin okunmasını içerir. Bu durumu tetikleyen başka senaryolar da olabilir."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.safe_read_lock:9
msgid ""
"This property returns a new lock object on every access. This lock object is"
" not recursive (for performance) and must only be used in a with statement "
"as ``with cache.safe_read_lock:`` otherwise bad things will happen."
msgstr "Bu özellik her erişimde yeni bir kilit nesnesi döndürür. Bu kilit nesnesi yinelemeli değildir (performans için) ve yalnızca ``with cache.safe_read_lock:`` gibi bir with ifadesiyle kullanılmalıdır, aksi durumda kötü şeyler olacaktır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.save_original_format:1
msgid ""
"Save a copy of the specified format as ORIGINAL_FORMAT, overwriting any "
"existing ORIGINAL_FORMAT."
msgstr "Mevcut herhangi ORIGINAL_FORMAT'ın üstüne yazarak belirtilen biçimin kopyasını ORIGINAL_FORMAT olarak keydet."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:1
msgid ""
"Search the database for the specified query, returning a set of matched book"
" ids."
msgstr "Veri tabanını belirtilen sorgu için ara, eşleşen kitap id'lerini döndür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:3
msgid ""
"A restriction that is ANDed to the specified query. Note that restrictions "
"are cached, therefore the search for a AND b will be slower than a with "
"restriction b."
msgstr "Belirtilen sorguya AND yapılan bir kısıtlama. Kısıtlamaların zulalandığını, yani bir a AND b aramasının bir kıstılı b'li a aramasından yavaş olacağını unutmayın."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:6
msgid "Used internally (virtual fields such as on_device to search over)."
msgstr "Dahili kullanım (aranacak on_device gibi sanal alanlar)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.search:8
msgid ""
"If not None, a set of book ids for which books will be searched instead of "
"searching all books."
msgstr "None değilse, tüm kitaplar yerine verilen kitapların aranacağı bir kitap id kümesi."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_conversion_options:1
msgid "options must be a map of the form {book_id:conversion_options}"
msgstr "seçenekler {book_id:conversion_options} haritası şeklinde olmalıdır"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_cover:1
msgid ""
"Set the cover for this book.  data can be either a QImage, QPixmap, file "
"object or bytestring. It can also be None, in which case any existing cover "
"is removed."
msgstr "Bu kitap için kapak ayarlayın.  veri QImage, QPixmap, dosya nesnesi veya bytestring olabilir. Ayrıca None da olabilir, bu durumda mevcut kapak kaldırılır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:1
msgid ""
"Set the values of the field specified by ``name``. Returns the set of all "
"book ids that were affected by the change."
msgstr "``name`` ile belirtilen alanın değerlerini ayarla. Değişiklikten etkilenen tüm kitap id'lerinin kümesini döndürür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:3
msgid "Mapping of book_ids to values that should be applied."
msgstr "book_id'lerin uygulanacak değerlere haritası."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:4
msgid ""
"If True, the case of many-one or many-many fields will be changed. For "
"example, if a  book has the tag ``tag1`` and you set the tag for another "
"book to ``Tag1`` then the both books will have the tag ``Tag1`` if "
"allow_case_change is True, otherwise they will both have the tag ``tag1``."
msgstr "True ise, çoktan-bire ve çoktan-çoka alanların büyük küçük harfleri değiştirilir. Örneğin bir kitabın ``tag1`` etiketi varsa, ve başka bir kitap için etiketi ``Tag1`` olarak ayarladıysanız allow_case_change True ise her iki kitap da ``Tag1`` etiketine sahip olur, aksi durumda ikisi de ``tag1`` etiketine s ahip olacaktır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_field:8
msgid "Used internally, you should never change it."
msgstr "Dahili kullanım içindir, değiştirmemelisiniz."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_metadata:1
msgid "Set metadata for the book `id` from the `Metadata` object `mi`"
msgstr "`Metadata` nesnesi `mi`den kitap `id`si için metadata ayarla"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_metadata:3
msgid ""
"Setting force_changes=True will force set_metadata to update fields even if "
"mi contains empty values. In this case, 'None' is distinguished from "
"'empty'. If mi.XXX is None, the XXX is not replaced, otherwise it is. The "
"tags, identifiers, and cover attributes are special cases. Tags and "
"identifiers cannot be set to None so they will always be replaced if "
"force_changes is true. You must ensure that mi contains the values you want "
"the book to have. Covers are always changed if a new cover is provided, but "
"are never deleted. Also note that force_changes has no effect on setting "
"title or authors."
msgstr "force_changes=True ayarı mi boş değerler içerse de set_metadata'nın alanları güncellemesine yol açar. Bu durumda 'None' 'boş'dan ayrılmış olur. mi.XXX None ise, XXX yer değiştirilmez, aksi durumda değiştirilir. Etiketler, tanımlayıcılar, ve kapak öznitelikleri özel durumlardır. Etiketler ve tanımlayıcılar None olamayacağından force_changes true ise her zaman yer değiştirilirler. Mi'nin kitapta olmasını istediğiniz değerleri içerdiğinden emin olmalısınız. Kapaklar yeni bir kapak sağlanmışsa hep değiştirilir, ama asla silinmezler. force_changes'in başlık veya yazar ayarlarında etkisi olmadığını da unutmayın."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.set_pref:1
msgid ""
"Set the specified preference to the specified value. See also :meth:`pref`."
msgstr "Belirtilen değere belirtilen seçeneği ayarla. Ayrıca bknz :meth:`pref`."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:1
msgid ""
"Return the ids of all books having the tag ``tag`` that are older than the "
"specified time. tag comparison is case insensitive."
msgstr "Belirtilen zamandan eski ``tag`` etiketine sahip tüm kitapların id'lerini döndür. etiket karşılaştırma büyük küçük harf duyarsızdır."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:4
msgid ""
"A timedelta object or None. If None, then all ids with the tag are returned."
msgstr "Bir timedelta nesnesi veya None. None ise, etiketli tüm id'ler döndürülür."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:7
msgid ""
"If not None the list of matches will be restricted to books that have this "
"tag"
msgstr "None değilse eşleşme listesi bu etikete sahip kitaplarla kısıtlanır"

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.tags_older_than:10
msgid ""
"A list of authors. If not None the list of matches will be restricted to "
"books that have these authors (case insensitive)."
msgstr "Yazarlar listesi. None değilse, eşleşme listesi bu yazarlara sahip kitaplarla kısıtlanacaktır (büyük küçük harf duyarlı)."

#: ../../home/kovid/work/calibre/src/calibre/db/cache.pydocstring of
#: calibre.db.cache.Cache.user_categories_for_books:1
msgid ""
"Return the user categories for the specified books. proxy_metadata_map is "
"optional and is useful for a performance boost, in contexts where a "
"ProxyMetadata object for the books already exists. It should be a mapping of"
" book_ids to their corresponding ProxyMetadata objects."
msgstr "Belirtilen kitaplar için kullanıcı kategorilerini döndür. proxy_metadata_map kitapların bir ProxyMetadata nesnesine sahip olduğu durumlarda performans artırmak amaçlı kullanılabilir ve tercihe bağlıdır. book_id'lerinin ilgili ProxyMetadata nesnesine haritası olmalıdırlar."
