# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Eduard van der Linde, 2018
# M. de Boer <de.boer.melle@gmail.com>, 2018
# Meteor0id, 2019
# peter <petertje@tuta.io>, 2021-2022
# W.P.M.E. Hofland <wpme.hofland@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-20 09:15+0000\n"
"PO-Revision-Date: 2022-01-16 22:44+0000\n"
"Last-Translator: peter <petertje@tuta.io>\n"
"Language-Team: Dutch (http://www.transifex.com/calibre/calibre/language/nl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: nl\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../__w/calibre/calibre/manual/regexp.rst:4
msgid "All about using regular expressions in calibre"
msgstr "Alles over het gebruik van reguliere expressies in calibre"

#: ../../__w/calibre/calibre/manual/regexp.rst:6
msgid ""
"Regular expressions are features used in many places in calibre to perform "
"sophisticated manipulation of e-book content and metadata. This tutorial is "
"a gentle introduction to getting you started with using regular expressions "
"in calibre."
msgstr "Reguliere expressies zijn functies die op veel plaatsen van calibre worden gebruikt om geavanceerde manipulatie van e-book inhoud en metadata uit te voeren. Deze handleiding is een voorzichtige inleiding om u op weg te helpen met het gebruik van reguliere uitdrukkingen in calibre."

#: ../../__w/calibre/calibre/manual/regexp.rst:11
msgid "Contents"
msgstr "Inhoud"

#: ../../__w/calibre/calibre/manual/regexp.rst:14
msgid "First, a word of warning and a word of courage"
msgstr "Allereerst een waarschuwing en bemoediging"

#: ../../__w/calibre/calibre/manual/regexp.rst:16
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Dit gaat onvermijdelijk enigszins technisch worden, - reguliere expressies zijn immers een technisch hulpmiddel voor het doen van technische zaken. Ik zal wat jargon en concepten moeten gebruiken die ingewikkeld of ingewikkeld lijken. Ik ga proberen die concepten zo duidelijk mogelijk uit te leggen, maar kan echt niet zonder ze helemaal te gebruiken. Dat gezegd zijnde, wees niet ontmoedigd door enig jargon, omdat ik heb geprobeerd om alles nieuw uit te leggen. En terwijl reguliere expressies zelf misschien een mysterieuze, zwarte magie lijken (of, om prozaïscher te zijn, een willekeurige reeks mumbo-jumbo letters en tekens), beloof ik dat ze niet zo gecompliceerd zijn. Zelfs degenen die reguliere uitdrukkingen echt goed begrijpen, hebben moeite met het lezen van de meer gecompliceerde uitdrukkingen, maar het schrijven ervan is niet zo moeilijk - je construeert de uitdrukking stap voor stap. Dus, neem een stap en volg me naar het konijnenhol."

#: ../../__w/calibre/calibre/manual/regexp.rst:19
msgid "Where in calibre can you use regular expressions?"
msgstr "Waar in calibre kan je reguliere expressies gebruiken?"

#: ../../__w/calibre/calibre/manual/regexp.rst:21
msgid ""
"There are a few places calibre uses regular expressions. There's the "
":guilabel:`Search & replace` in conversion options, metadata detection from "
"filenames in the import settings and Search & replace when editing the "
"metadata of books in bulk. The calibre book editor can also use regular "
"expressions in its :guilabel:`Search and replace` feature. Finally, you can "
"use regular expressions when searching the calibre book list and when "
"searching inside the calibre E-book viewer."
msgstr "Er zijn een paar plaatsen waar calibre reguliere expressies gebruikt. Daar is de :guilabel :`Zoeken & vervangen` in conversie-opties, detectie van metadata uit bestandsnamen in de importinstellingen en Zoeken & vervangen bij het bewerken van de metadata van boeken in bulk. De calibre boek editor kan ook reguliere expressies gebruiken in zijn :guilabel:`Zoek en vervang` functie. Tenslotte kan u reguliere expressies gebruiken bij doorzoeken van de calibre boekenlijst en bij zoeken in de calibre e-boekviewer."

#: ../../__w/calibre/calibre/manual/regexp.rst:30
msgid "What on earth *is* a regular expression?"
msgstr "Wat is een reguliere expressie eigenlijk?"

#: ../../__w/calibre/calibre/manual/regexp.rst:32
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Een reguliere expressie is een manier om een string set te beschrijven. Een enkele reguliere expressie kan *overeenkomen* met een aantal verschillende strings. Dit maakt reguliere expressie zo krachtig -- het is een beknopte manier om een mogelijk groot aantal variaties te beschrijven."

#: ../../__w/calibre/calibre/manual/regexp.rst:34
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In calibre, regular expressions are case insensitive in the Search"
" bar, but not in the conversion options. There's a way to make every regular"
" expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Ik gebruik string hier op de manier dat het gebruikt wordt in programmeertalen: een reeks van één of meerdere karakters, inbegrepen letters, cijfers, interpunctie en zogenaamde witruimte (regeleindes, tabs, enz.). Merk a.u.b. op dat in het algemeen hoofd- en kleine letters niet als identiek beschouwd worden, \"a\" is dus iets anders als \"A\" en zo verder. In calibre zijn reguliere expressies hoofdletterongevoelig in de Zoekbalk maar niet in de conversie-opties. Er is een manier om elke reguliere expressie hoofdletterongevoelig te maken maar dat bespreken we later. Het wordt gecompliceerd omdat reguliere expressies variaties toelaten in de strings waar ze mee overeen komen, dus een expressie kan met verschillende strings overeen komen, reden dat ze gebruikt worden. Meer daarover later."

#: ../../__w/calibre/calibre/manual/regexp.rst:37
msgid "Care to explain?"
msgstr "Iets meer uitleg graag?"

#: ../../__w/calibre/calibre/manual/regexp.rst:39
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "Wel, daarom zijn we hier. Ten eerste, dit is het belangrijkste concept in reguliere expressies: *Een string is zelf een reguliere expressie die met zichzelf overeenkomt*. Dat wil zeggen, als ik met de string ``\"Hello, World!\"`` wou overeenkomen met een reguliere expressie, de te gebruiken reguliere expressie zou ``Hello, World!`` zijn. Ja, het is echt zo simpel. U zal nochtans opmerken dat dit *enkel* overeenkomt met de exacte string ``\"Hello, World!\"``, niet met bv. ``\"Hello, wOrld!\"`` of ``\"hello, world!\"`` of elke andere variatie."

#: ../../__w/calibre/calibre/manual/regexp.rst:42
msgid "That doesn't sound too bad. What's next?"
msgstr "Dat klinkt niet heel moeilijk. Ga door."

#: ../../__w/calibre/calibre/manual/regexp.rst:44
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is where it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"e-book you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "Nu komt het echt leuke gedeelte. Herinnert u zich dat ik zei dat reguliere expressies met meerdere strings kunnen overeenkomen? Nu wordt het een beetje ingewikkelder. Neem, als een iets meer praktische oefening, dat het e-boek dat u wou converteren een gemene voettekst had om de pagina's te tellen, zoals \"Pagina 5 van 423\". Duidelijk dat het pagina nummer zal stijgen van 1 tot 423, dus u zou met 423 verschillende strings moeten overeenkomen, klopt? Fout, eigenlijk: reguliere expressies laten u karaktersets definiëren die overeenkomen: Om een set te definiëren, zet u alle karakters die u in de set wilt tussen vierkante haken. Dus, bv., de set ``[abc]`` komt overeen met ofwel karakter \"a\", \"b\" of \"c\". *Sets komen altijd maar overeen met een van de karakters in de set*. Ze \"begrijpen\" karakterbereiken, dat wil zeggen, als u met alle kleine letters wil overeenkomen, gebruikt u de set ``[a-z]``, voor hoofd- en kleine letters gebruikt u ``[a-zA-Z]`` en zo voort. Bent u mee? Dus, duidelijk, gebruik makend van de expressie ``Page [0-9] of 423`` komt u overeen met de eerste 9 pagina's, daarbij de vereiste expressies tot drie reducerend: De tweede expressie ``Page [0-9][0-9] of 423``  komt overeen met alle tweecijferige paginanummers en ik ben er zeker van dat u kan raden hoe de derde expressie eruit zou zien. Ja, vooruit, schrijf het op."

#: ../../__w/calibre/calibre/manual/regexp.rst:47
msgid "Hey, neat! This is starting to make sense!"
msgstr "Prachtig! Nu begint het ergens op te lijken!"

#: ../../__w/calibre/calibre/manual/regexp.rst:49
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression). These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Ik hoopte al dat u dat zou zeggen. Maar hou u vast, het wordt nog beter! We zagen net dat met sets we konden zoeken naar één of meerdere karakters ineens. Maar men kan zelfs een karakter of set herhalen en zo het aantal expressies nodig voor het paginanummer voorbeeld boven verminderen tot één. Ja, ÉÉN! Spannend? Absoluut! Zo werkt het: Bepaalde zogenaamde speciale karakters, \"+\", \"?\" en \"*\", *herhalen het voorafgaande element*. (Element betekent ofwel een enkel karakter, ofwel een karakterset, ofwel een escape sequentie ofwel een groep (we leren later meer over die twee laatste)- kortom, elke eenheid in een reguliere expressie). Deze karakters heten wildcards of quantifiers. Nauwkeuriger, \"?\" komt overeen met *0 of 1* van het voorafgaande element, \"*\" komt overeen met *0 of meer* van het voorafgaande element en \"+\" komt overeen met *1 of meer* van het voorafgaande element. Een paar voorbeelden: De expressie ``a?`` komt overeen met ofwel \"\" (de lege string, niet echt bruikbaar in dit geval) ofwel \"a\", de expressie ``a*`` komt overeen met \"\", \"a\", \"aa\" of elk aantal a's op een rij, en, tenslotte, de expressie ``a+`` komt overeen met \"a\", \"aa\" of elk aantal a's op een rij (Merk op: het komt niet overeen met de lege string!). Zelfde geval met sets: De expressie ``[0-9]+`` komt overeen met *elk bestaand geheel getal*! Ik weet wat u denkt en u hebt gelijk: Als u dat in het geval boven met overeenkomende pagina nummers gebruikt, zou dat niet die enkele expressie zijn die met alle paginanummers overeen komt? Ja, de expressie ``Page [0-9]+ of 423`` komt overeen met elk paginanummer in dat boek!"

#: ../../__w/calibre/calibre/manual/regexp.rst:52
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of). Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "Iets over die quantifiers: Ze proberen gewoonlijk met zoveel mogelijk tekst overeen te komen, voorzichtig gebruiken dus. Dit wordt \"gulzig gedrag\" genoemd - Ik ben er zeker van dat u dat snapt. Het wordt problematisch als u, bv. probeert met een tag overeen te komen. Beschouw bv. de string ``\"<p class=\"calibre2\">Title here</p>\"`` en dat u met de openingstag wilt overeenkomen (het deel tussen het eerste paar punthaakjes, meer over tags later). Men zou denken dat de expressie ``<p.*>`` dat doet maar eigenlijk komt dat overeen met de hele string! (Het karakter \".\" is nog een speciaal karakter dat met alles overeenkomt *behalve* een nieuwe ijn, dus de expressie ``.*`` komt overeen met elke regel die u zich kan inbeelden). I.p.d.v. gebruik ``<p.*?>`` wat de quantifier ``\"*\"`` niet-gulzig maakt. Die expressie komt enkel overeen met de openingstag, zoals bedoeld. Er is nog een manier om dit te bereiken: De expressie ``<p[^>]*>`` komt met dezelfde tag overeen - u ziet waarom na het volgende onderdeel. Merk gewoon op dat er dikwijls meerdere manieren zijn om een reguliere expressie te schrijven."

#: ../../__w/calibre/calibre/manual/regexp.rst:56
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "Nou, deze speciale karakters zijn erg netjes en zo maar wat als ik een overeenkomst met een punt of vraagteken wil?"

#: ../../__w/calibre/calibre/manual/regexp.rst:58
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "U kan natuurlijk dit doen: Zet gewoon een backslash voor elk speciaal karakter en het wordt geïnterpreteerd als letterlijk dat karakter, zonder speciale betekenis. Dit paar backslashes gevolgd door een enkel karakter wordt een escape sequentie genoemd en een backslash voor een speciaal karakter zetten heet dat karakter escapen. Een escape sequentie wordt geïnterpreteerd als een enkel element. Er zijn natuurlijk escape sequenties die meer doen dan speciale karakters escapen, ``\"\\t\"`` bv. betekent een tabulator. We zien later enkele escape sequenties. Oh, enne, wat betreft die speciale karakters: Beschouw elk karakter dat we bespreken in deze introductie als hebbende een zekere functie die speciaal kan zijn en dus een nood om te escapen als u het letterlijke karakter wilt hebben."

#: ../../__w/calibre/calibre/manual/regexp.rst:61
msgid "So, what are the most useful sets?"
msgstr "Wat zijn dan de meest nuttige sets?"

#: ../../__w/calibre/calibre/manual/regexp.rst:63
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand:"
msgstr "Ik wist dat u het zou vragen. Enkele nuttige sets zijn ``[0-9]`` komt overeen met een enkel getal, ``[a-z]`` met een enkele kleine letter, ``[A-Z]`` met een enkele hoofdletter, ``[a-zA-Z]`` met een enkele letter en ``[a-zA-Z0-9]`` komt overeen met een enkele letter of cijfer."

#: ../../__w/calibre/calibre/manual/regexp.rst:66
msgid "``\\d``"
msgstr "``\\d``"

#: ../../__w/calibre/calibre/manual/regexp.rst:66
msgid "is equivalent to ``[0-9]``"
msgstr "is gelijkwaardig aan ``[0-9]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:70
msgid "``\\w``"
msgstr "``\\w``"

#: ../../__w/calibre/calibre/manual/regexp.rst:69
msgid "is equivalent to ``[a-zA-Z0-9_]``"
msgstr "is gelijkwaardig aan ``[a-zA-Z0-9_]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:73
msgid "``\\s``"
msgstr "``\\s``"

#: ../../__w/calibre/calibre/manual/regexp.rst:73
msgid "is equivalent to any whitespace"
msgstr "is gelijkwaardig aan elke spatie"

#: ../../__w/calibre/calibre/manual/regexp.rst:76
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed, carriage return, "
"non-breaking spaces, etc."
msgstr "\"Witruimte\" is een term voor alles dat niet afgedrukt wordt. Deze karakters zijn onder andere spatie, tab,  regelinvoerteken (LF), paginainvoerteken (FF), regeleinde (CR), niet-afbrekende spaties, enz."

#: ../../__w/calibre/calibre/manual/regexp.rst:78
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "Al laatste woord over sets, u kan een set ook definiëren als elk karakter *behalve* die in de set. U doet dat door het karakter ``\"^\"`` als *allereerste karakter in de set* te zetten. Dus, ``[^a]`` komt overeen met elk karakter behalve \"a\". Dat heet de set aanvullen. Die verkorte escapereeksen die we eerder zagen kunnen ook aangevuld worden: ``\"\\D\"`` betekent elk niet-numeriek karakter, equivalent dus met ``[^0-9]``. De andere verkortingen kunnen aangevuld worden door, u raadde het, gebruik van de respectieve hoofdletter i.p.v. de kleine letter. Dus, terug naar het voorbeeld ``<p[^>]*>`` van de vorige sectie, u ziet nu dat de gebruikte karakterset probeert overeen te komen met elk karakter behalve een sluitend vierkant haakje."

#: ../../__w/calibre/calibre/manual/regexp.rst:81
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Maar als ik een paar verschillende strings had die ik wilde laten overeenkomen worden dingen ingewikkeld?"

#: ../../__w/calibre/calibre/manual/regexp.rst:83
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in e-books, "
"it's annoying. You can group whole expressions in normal parentheses, and "
"the character ``\"|\"`` will let you match *either* the expression to its "
"right *or* the one to its left. Combine those and you're done. Too fast for "
"you? Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "Vrees niet, 't leven is nog altijd eenvoudig en goed. Overweeg dit voorbeeld: In het boek dat converteert staat \"Titel\" op elke oneven pagina en \"Auteur\" op elke even pagina. Ziet er goed uit in druk, niet? Maar in e-boeken is het vervelend. U kan hele expressies groeperen tussen aanhalingstekens en het karakter ``\"|\"`` laat overeenkomen met *ofwel* de expressie rechts *ofwel* de expressie links. Combineer deze en u bent klaar. Te snel voor u? Oké, om te beginnen groeperen we de expressies voor even en oneven pagina's en krijgen ``(Title)(Author)`` als de twee benodigde expressies. Nu maken we het simpeler met gebruik van het pijp symbool (``\"|\"`` wordt het pijp of sluissymbool genoemd): Als u de expressie ``(Title|Author)`` gebruikt krijgt u ofwel een overeenkomst voor \"Titel\" (op de oneven pagina's) ofwel \"Auteur\" (op de even pagina's). Wel, was dat niet gemakkelijk?"

#: ../../__w/calibre/calibre/manual/regexp.rst:85
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "U kan natuurlijk het pijp symbool ook zonder groeperende haakjes gebruiken. Weet u nog dat ik zei dat quantifiers het element voor zich herhalen? Wel, het pijp symbool werkt enigszins anders: De expressie \"Titel|Auteur\" komt ook overeen met ofwel de string \"Titel\" ofwel de string \"Auteur\", net zoals het voorbeeld boven met groeperen. *Het pijp symbool selecteert tussen de volledige expressie ervoor en erna*. Dus als u met de strings \"Calibre\" en \"calibre\" wou overeenkomen en enkel wou selecteren tussen de hoofd- en kleine letter \"c\", moet u de expressie ``(c|C)alibre`` gebruiken, waar de groepering ervoor zorgt dat enkel de \"c\" wordt geselecteerd. Als u ``c|Calibre`` zou gebruiken, zou u een overeenkomst krijgen op de string \"c\" of op de string \"Calibre\", wat niet is wat we wilden. Samengevat: Bij twijfel, gebruik groeperen met het pijp symbool."

#: ../../__w/calibre/calibre/manual/regexp.rst:88
msgid "You missed..."
msgstr "U miste..."

#: ../../__w/calibre/calibre/manual/regexp.rst:90
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "...wacht nog even, er is nog één, heel tof ding dat u kan doen met groepen. Als u een groep hebt die vroeger overeenkwam, kan u verder in de expressie verwijzingen naar die groep gebruiken: Groepen worden genummerd vanaf 1, en u verwijst ernaar door het getal van de groep waarnaar u wilt verwijzen te escapen, dus naar de vijfde groep wordt verwezen met ``\\5``. Dus, als u zocht naar ``([^ ]+) \\1`` in de string \"Test Test\", komt dat overeen met de hele string!"

#: ../../__w/calibre/calibre/manual/regexp.rst:94
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "In het begin zei u dat er een manier was om een reguliere expressie hoofdletterongevoelig te maken?"

#: ../../__w/calibre/calibre/manual/regexp.rst:96
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell "
"calibre how you want certain things handled by using something called flags."
" You include flags in your expression by using the special construct "
"``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with "
"the specific flags you want. For ignoring case, the flag is ``i``, thus you "
"include ``(?i)`` in your expression. Thus, ``(?i)test`` would match "
"\"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr "Inderdaad, bedankt voor uw aandacht en om me eraan te herinneren. U kan calibre zeggen hoe u bepaalde dingen gedaan wilt hebben met vlaggen. U voegt vlaggen in in uw expressie via de speciale constructie ``(?vlaggen hier)`` waar u, natuurlijk, \"vlaggen hier\" vervangt door de specifieke vlag die u wilt. Om hoofdlettergebruik te negeren is de vlag ``i`` dus u voegt ``(?i)`` in in uw expressie. Dus, ``(?i)test`` komt overeen met \"Test\", \"tEst\", \"TEst\" en elke hoofd/kleine letter variatie ie u kunt bedenken."

#: ../../__w/calibre/calibre/manual/regexp.rst:98
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above."
msgstr "Een andere nuttige vlag laat het punt overeenkomen met eender welk karakter, *inbegrepen* de newline, de vlag  ``s``. Als u meerdere vlaggen wil gebruiken in een expressie, zet ze gewoon in dezelfde verklaring: ``(?is)`` negeert hoofdlettergebruik en laat het punt met alles overeenkomen. Het maakt niet uit welke vlag u eerst zet, ``(?si)`` is gelijk aan het bovenstaande."

#: ../../__w/calibre/calibre/manual/regexp.rst:101
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in calibre?"
msgstr "Ik denk dat ik deze reguliere expressies begin te begrijpen nu ... hoe gebruik ik ze in calibre?"

#: ../../__w/calibre/calibre/manual/regexp.rst:104
msgid "Conversions"
msgstr "Omzettingen"

#: ../../__w/calibre/calibre/manual/regexp.rst:106
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
":guilabel:`Search & replace` part, you can input a regexp (short for regular"
" expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what calibre \"sees\" during the conversion process. Scroll"
" down to the string you want to remove, select and copy it, paste it into "
"the regexp field on top of the window. If there are variable parts, like "
"page numbers or so, use sets and quantifiers to cover those, and while "
"you're at it, remember to escape special characters, if there are some. Hit "
"the button labeled :guilabel:`Test` and calibre highlights the parts it "
"would replace were you to use the regexp. Once you're satisfied, hit OK and "
"convert. Be careful if your conversion source has tags like this example::"
msgstr "Laten we beginnen met de conversie instellingen, wat echt handig is. In het :guilabel:`Zoeken & vervangen` deel kan u een regexp (afkorting voor reguliere expressie) ingeven die de string beschrijft die vervangen wordt tijdens de conversie. Het handige deel is de wizard. Klik op de toverstaf en u krijgt een voorbeeld van wat calibre \"ziet\" tijdens de conversie. Scrol naar de string die u wilt verwijderen, selecteer en kopieer hem, plak helm in het regexp veld boven in het venster. Als er variabele delen zijn, zoals pagina nummers of zo, gebruik daarvoor sets en quantifiers en terwijl u bezig bent, denk eraan speciale karakters te escapen, als er zijn. Klik op de :guilabel:`Test` knop en calibre accentueert de delen die het zou vervangen als u de regexp zou gebruiken. Wanneer u tevreden bent, klik op OK en converteer. Weer voorzichtig als uw conversie bron tags heeft zoals deze::"

#: ../../__w/calibre/calibre/manual/regexp.rst:116
msgid ""
"(shamelessly ripped out of `this thread "
"<https://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point). The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what calibre will remove to make sure you don't remove any"
" portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, calibre tries to repair the damaged code after doing the"
" removal."
msgstr "(schaamteloos geripped uit  `deze thread <https://www.mobileread.com/forums/showthread.php?t=75594\">`_). U moet enkele tags verwijderen ook. In dit voorbeeld raad ik aan te beginnen met de tag ``<b class=\"calibre2\">``, nu moet u eindigen met de overeenkomende sluittag (openingstags zijn ``<tag>``, sluittags zijn ``</tag>``), welke gewoon de volgende ``</b>`` in dit geval. (Gebruik een goede HTML manual of vraag in het forum als u hierover twijfelt). De openingstag kan beschreven worden met ``<b.*?>``, de sluittag met ``</b>``, dus we kunnen alles tussen deze tags verwijderen met ``<b.*?>.*?</b>``. Maar deze expressie gebruiken is een slecht idee want ze verwijdert alles omsloten door <b> tags (die, by the way, de omsloten tekst vet weergeeft), en waarschijnlijk verwijderen we delen va het boek op deze manier. In plaats daarvan, geef ook het begin van de omsloten string mee, de reguliere expressie wordt dan ``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` De ``\\s`` met quantifiers is inbegrepen hier in plaats van expliciet gebruik van de spaties zoals in de string om eventuele variaties van de string op te vangen. Denk eraan te controleren wat calibre gaat verwijderen zodat u zeker bent dat u geen delen verwijdert die u wilt behouden als u een nieuwe expressie test. Als u maar één voorkomen test, kan u ergens anders in de tekst een mismatch over het hoofd zien. Merk ook op dat als per ongeluk meer of minder tags verwijdert dan u eigenlijk wou dat calibre de beschadigde code probeert te herstellen na het verwijderen."

#: ../../__w/calibre/calibre/manual/regexp.rst:119
msgid "Adding books"
msgstr "Boeken toevoegen"

#: ../../__w/calibre/calibre/manual/regexp.rst:121
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that calibre won't extract any meaningful data out"
" of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"calibre provides, you need to add the file extension to your testing "
"filename, otherwise you won't get any matches at all, despite using a "
"working expression."
msgstr "Iets anders waar u reguliere expressies voor kan gebruiken is metadata uit bestandsnamen halen. U vindt deze functie in \"Boeken toevoegen\" in de instellingen. Er is hier een speciale functie: U kan veldnamen gebruiken voor metadata velden, bv. ``(?P<title>)`` geeft aan dat calibre dit deel van de string gebruikt als boektitel. De toegelaten veldnamen zijn opgelijst in de vensters, samen met een ander leuk testveld. Bv. Stel u wilt een hoop bestanden importeren genaamd zoals ``Classical Texts: The Divine Comedy by Dante Alighieri.mobi``. (Dit is natuurlijk al in uw bibliotheek, we houden allemaal van klassieke Italiaanse poëzie) of ``Science Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. Dit is duidelijk een naamgevingsschema waar calibre geen nuttige data kan uithalen - z'n standaard expressie om metadata te extraheren is ``(?P2.+) - (?P3[^_]+)``. Een reguliere expressie die hier werkt zou ``[a-zA-Z]+: (?P4.+) by (?P5.+)`` zijn. Merk a.u.b. op dat, in de groep voor het metadata veld, u expressies moet gebruiken die beschrijven waar het veld met overeenkomt. En merk ook op dat bij gebruik van het door calibre voorziene testveld, u de extensie moet toevoegen aan uw testbestandsnaam of u krijgt helemaal geen overeenkomsten, ook niet met een werkende expressie."

#: ../../__w/calibre/calibre/manual/regexp.rst:125
msgid "Bulk editing metadata"
msgstr "Massabewerking van metadata"

#: ../../__w/calibre/calibre/manual/regexp.rst:127
msgid ""
"The last part is regular expression :guilabel:`Search and replace` in "
"metadata fields. You can access this by selecting multiple books in the "
"library and using bulk metadata edit. Be very careful when using this last "
"feature, as it can do **Very Bad Things** to your library! Doublecheck that "
"your expressions do what you want them to using the test fields, and only "
"mark the books you really want to change! In the regular expression search "
"mode, you can search in one field, replace the text with something and even "
"write the result into another field. A practical example: Say your library "
"contained the books of Frank Herbert's Dune series, named after the fashion "
"``Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get "
"``Dune`` into the series field. You can do that by searching for ``(.*?) "
"\\d+ - .*`` in the title field and replacing it with ``\\1`` in the series "
"field. See what I did there? That's a reference to the first group you're "
"replacing the series field with. Now that you have the series all set, you "
"only need to do another search for ``.*? -`` in the title field and replace "
"it with ``\"\"`` (an empty string), again in the title field, and your "
"metadata is all neat and tidy. Isn't that great? By the way, instead of "
"replacing the entire field, you can also append or prepend to the field, so,"
" if you *wanted* the book title to be prepended with series info, you could "
"do that as well. As you by now have undoubtedly noticed, there's a checkbox "
"labeled :guilabel:`Case sensitive`, so you won't have to use flags to select"
" behaviour here."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:129
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<https://docs.python.org/library/re.html>`_."
msgstr "Wel, tot zover de zeer korte inleiding tot reguliere expressies. Hopelijk heb ik u genoeg laten zien om u tenminste te laten beginnen en het mogelijk te maken om zelfstandig verder te leren - een goed vertrekpunt is de `Python documentatie voor reguliere expressies <https://docs.python.org/library/re.html>`_."

#: ../../__w/calibre/calibre/manual/regexp.rst:131
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. calibre provides really great testing possibilities to see if"
" your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...). But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Toch een laatste verwittiging: Reguliere expressies zijn krachtig maar ook foutgevoelig. calibre voorziet echt super testmogelijkheden om te zien of uw expressies doen wat u verwacht van hen. Gebruik ze. Probeer uzelf niet in de voet te schieten. (Dzjee, wat een prachtige uitdrukking...). Doet u het toch ondanks de waarschuwing (of in een ander lichaamsdeel), probeer ervan te leren."

#: ../../__w/calibre/calibre/manual/regexp.rst:135
msgid "Quick reference"
msgstr "Snelle referentie"

#: ../../__w/calibre/calibre/manual/regexp.rst:143
msgid "Credits"
msgstr "Credits"

#: ../../__w/calibre/calibre/manual/regexp.rst:145
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Dank voor  hulp met tips, correcties en dergelijke:"

#: ../../__w/calibre/calibre/manual/regexp.rst:147
msgid "ldolse"
msgstr "ldolse"

#: ../../__w/calibre/calibre/manual/regexp.rst:148
msgid "kovidgoyal"
msgstr "kovidgoyal"

#: ../../__w/calibre/calibre/manual/regexp.rst:149
msgid "chaley"
msgstr "chaley"

#: ../../__w/calibre/calibre/manual/regexp.rst:150
msgid "dwanthny"
msgstr "dwanthny"

#: ../../__w/calibre/calibre/manual/regexp.rst:151
msgid "kacir"
msgstr "kacir"

#: ../../__w/calibre/calibre/manual/regexp.rst:152
msgid "Starson17"
msgstr "Starson17"

#: ../../__w/calibre/calibre/manual/regexp.rst:153
msgid "Orpheu"
msgstr "Orpheu"

#: ../../__w/calibre/calibre/manual/regexp.rst:155
msgid ""
"For more about regexps see `The Python User Manual "
"<https://docs.python.org/library/re.html>`_. The actual regular expression "
"library used by calibre is: `regex <https://bitbucket.org/mrabarnett/mrab-"
"regex/src/hg/>`_ which supports several useful enhancements over the Python "
"standard library one."
msgstr "Voor meer over reguliere expressies, bekijk `The Python User Manual <https://docs.python.org/library/re.html>`_. De actuele reguliere expressie bibliotheek gebruikt door calibre is: `regex <https://bitbucket.org/mrabarnett/mrab-regex/src/hg/>`_ welke verscheidene nuttige verbeteringen ondersteunt bovenop de Python standaard bibliotheek."
