# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# Michele Galimberti <galimbertimichele@gmail.com>, 2021-2022
# SKAL <sir_kalot@yahoo.it>, 2015
# Stefano Avezzù <Opusprimo@gmail.com>, 2015
# Vincenzo Reale <vinx.reale@gmail.com>, 2014,2022
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-05-03 05:03+0000\n"
"PO-Revision-Date: 2014-06-17 08:35+0000\n"
"Last-Translator: Michele Galimberti <galimbertimichele@gmail.com>, 2021-2022\n"
"Language-Team: Italian (http://www.transifex.com/calibre/calibre/language/it/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: it\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../__w/calibre/calibre/manual/regexp.rst:4
msgid "All about using regular expressions in calibre"
msgstr "Tutto sull'utilizzo delle espressioni regolari in calibre"

#: ../../__w/calibre/calibre/manual/regexp.rst:6
msgid ""
"Regular expressions are features used in many places in calibre to perform "
"sophisticated manipulation of e-book content and metadata. This tutorial is "
"a gentle introduction to getting you started with using regular expressions "
"in calibre."
msgstr "Le espressioni regolari sono usate in molte parti di calibre per eseguire manipolazioni avanzate del contenuto e dei metadati degli e-book. Questa guida è un'introduzione amichevole all'uso  delle espressioni regolari in calibre."

#: ../../__w/calibre/calibre/manual/regexp.rst:11
msgid "Contents"
msgstr "Contenuti"

#: ../../__w/calibre/calibre/manual/regexp.rst:14
msgid "First, a word of warning and a word of courage"
msgstr "Per prima cosa, una parola di avviso e una di incoraggiamento"

#: ../../__w/calibre/calibre/manual/regexp.rst:16
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Questa guida sarà, per forza di cose, abbastanza tecnica - dopotutto, le espressioni regolari sono uno strumento tecnico che fa cose tecniche. Dovrò usare dei tecnicismi e dei concetti che potrebbero sembrare complicati o contorti. Farò del mio meglio per spiegare quei concetti il più chiaramente possibile, ma non posso proprio fare a meno di utilizzarli. Detto ciò, non essere scoraggiato da questo gergo, perché ho provato a spiegare tutto ciò che appare per la prima volta. E sebbene le espressioni regolari stesse possano sembrare una magia oscura e misteriosa (o, per essere più prosaici, segni e lettere astrusi messi a caso in una stringa senza senso), ti assicuro che non sono poi così complicati. Anche coloro che capiscono molto bene le espressioni regolari hanno problemi a leggere le più complesse tra di esse, ma scriverle non è così complicato - l'espressione è costruita passo passo. E allora, fai un passo avanti e seguimi nella tana del Bianconiglio"

#: ../../__w/calibre/calibre/manual/regexp.rst:19
msgid "Where in calibre can you use regular expressions?"
msgstr "Dove è possibile utilizzare le espressioni regolari all'interno di calibre?"

#: ../../__w/calibre/calibre/manual/regexp.rst:21
msgid ""
"There are a few places calibre uses regular expressions. There's the "
":guilabel:`Search & replace` in conversion options, metadata detection from "
"filenames in the import settings and Search & replace when editing the "
"metadata of books in bulk. The calibre book editor can also use regular "
"expressions in its :guilabel:`Search and replace` feature. Finally, you can "
"use regular expressions when searching the calibre book list and when "
"searching inside the calibre E-book viewer."
msgstr "Ci sono vari luoghi in cui calibre utilizza le espressioni regolari. C'è :guilabel:`Cerca e sostituisci` nelle opzioni di conversione, l'estrazione dei metadati dai nomi dei file nelle impostazioni di importazione e il Cerca e sostituisci nella modifica di gruppo dei metadati dei libri. Anche l'editor di libri di calibre può usare le espressioni regolari nella sua funzione :guilabel:`Cerca e sostituisci`. Infine puoi usare le espressioni regolari quando cerchi nell'elenco dei libri di calibre e nel Lettore E-book di calibre."

#: ../../__w/calibre/calibre/manual/regexp.rst:30
msgid "What on earth *is* a regular expression?"
msgstr "Cosa diamine *è* un'espressione regolare?"

#: ../../__w/calibre/calibre/manual/regexp.rst:32
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Un'espressione regolare è un modo per descrivere insiemi di stringhe. Una singola espressione regolare può *associare* una serie di stringhe differenti. È questo che rende le espressioni regolari così potenti -- sono un modo conciso per descrivere un numero potenzialmente alto di variazioni."

#: ../../__w/calibre/calibre/manual/regexp.rst:34
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In calibre, regular expressions are case insensitive in the Search"
" bar, but not in the conversion options. There's a way to make every regular"
" expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Qui uso stringa con il significato usato nei linguaggi di programmazione: una stringa di uno o più caratteri, che includono caratteri effettivi, numeri, punteggiatura e i cosiddetti \"whitespace\" (testo a capo, tabulazioni, ecc.). Ricorda che generalmente caratteri con maiuscole differenti non sono considerati uguali, ne deriva perciò che \"a\" è un carattere di verso da \"A\", e così via. In calibre, le espressioni regolari non fanno distinzione di maiuscole nella Barra di Ricerca, ma la fanno nelle opzioni di conversione. Esiste un modo per fare in modo che nessuna espressione regolare distingua le maiuscole, ma ne parleremo più avanti. Diventa complicato perché le espressioni regolari permettono varianti nelle stringhe che trovano, e quindi a un'espressione può corrispondere più di una stringa, che è poi la ragione per cui la gente si prende il disturbo di usarle. Più informazioni fra un attimo."

#: ../../__w/calibre/calibre/manual/regexp.rst:37
msgid "Care to explain?"
msgstr "Potresti spiegare meglio?"

#: ../../__w/calibre/calibre/manual/regexp.rst:39
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "Siamo qui per questo. Primo, e questo è il concetto più importante delle espressioni regolari: *Una stringa presa da sola è un'espressione regolare che trova se stessa*. Ovverosia, se volessi trovare la stringa ``\"Ciao, Mondo!\"`` usando un'espressione regolare, l'espressione regolare da usare sarebbe ``Ciao, Mondo!``. E sì, è proprio così semplice. Ti sarai accorto, tuttavia, che questa espressione trova *solo* la stringa esatta ``\"Ciao, Mondo!\"``, non p.es. ``\"Ciao, mOndo!\"`` o ``\"ciao, mondo!\"`` o altre varianti del genere."

#: ../../__w/calibre/calibre/manual/regexp.rst:42
msgid "That doesn't sound too bad. What's next?"
msgstr "Non suona affatto male. E poi?"

#: ../../__w/calibre/calibre/manual/regexp.rst:44
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is where it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"e-book you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "Poi inizia la parte davvero interessante. Ricordi quando ti ho detto che le espressioni regolari possono trovare più di una stringa? È qui che le cose si complicano. Poniamo, come esercizio un po' più concreto, che l'e-book che volevi convertire avesse un fastidioso piè di pagina con la conta delle pagine, come \"Pagina 5 di 423\". Ovviamente il numero di pagina salirebbe da 1 a 423, per cui dovresti trovare 423 stringhe differenti, giusto? Sbagliato in realtà: le espressioni regolari ti permettono di definire set di caratteri da trovare: per definirne uno, metti tutti i caratteri che vuoi avere nel set dentro parentesi quadre. Quindi, ad esempio, il set ``[abc]`` troverebbe sia il carattere \"a\", sia \"b\" sia \"c\". *I set troveranno sempre solamente uno dei caratteri del set.* Essi \"riconoscono\" gli intervalli, ovvero, se volessi trovare tutti i caratteri minuscoli dovresti usare il set ``[a-z]``, per tutti i caratteri minuscoli e maiuscoli dovresti usare ``[a-zA-Z]``, e così via. Chiaro il concetto? Quindi, ovviamente, usando l'espressione ``Pagina [0-9] di 423`` saresti in grado di trovare le prime 9 pagine, riducendo quindi il numero di espressioni necessarie a tre: la seconda espressione ``Pagina [0-9][0-9] di 423`` troverebbe tutti i numeri di pagina di due cifre, e sono sicuro che tu possa immaginare l'aspetto della terza espressione. Esatto, vai pure. Scrivila."

#: ../../__w/calibre/calibre/manual/regexp.rst:47
msgid "Hey, neat! This is starting to make sense!"
msgstr "Ehi, ben fatto! Ora inizia ad avere un senso!"

#: ../../__w/calibre/calibre/manual/regexp.rst:49
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression). These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Speravo proprio che lo dicessi. Ma aspetta, ora diventa ancora più bello! Abbiamo appena visto che usando gli insiemi possiamo trovare un carattere tra molti inclusi. Ma puoi anche ripetere un carattere o un insieme, e ridurre così il numero di espressioni necessarie per gestire l’esempio dei numeri di pagina di poco fa a uno. Esatto, UNO! Eccitato? Dovresti esserlo! Funziona così: Alcuni cosiddetti caratteri speciali, \"+\", \"?\" e \"*\", *ripetono l’elemento singolo che li precede*. Per elemento si intende un singolo carattere, un insieme di caratteri, una sequenza di escape o un gruppo (Di questi ultimi due parleremo più avanti) – in breve ogni entità singola in un’espressione regolare. Questi caratteri sono chiamati wildcard o quantificatori. Per essere più precisi, \"?\" trova *0 o 1* dell’elemento che lo precede, \"*\" trova *0 o più* dell’elemento che lo precede e \"+\" trova *1 o più* dell’elemento che lo precede. Alcuni esempi: l’espressione ``a?`` troverebbe sia \"\" (che è la stringa vuota, non proprio utile nel nostro caso) sia \"a\", l’espressione ``a*`` troverebbe \"\", \"a\", \"aa\" o un qualsiasi numero di a messe in fila e, infine, l’espressione ``a+`` troverebbe \"a\", \"aa\" o un qualsiasi numero di a messe in fila (Nota: non troverebbe la stringa vuota!). Lo stesso vale per gli insiemi: l’espressione ``[0-9]+`` troverebbe *ogni numero intero che c’è*! So cosa stai pensando, e hai ragione: se usassi questa espressione nel caso di prima dei numeri di pagina, non sarebbe questa l’espressione unica che trova tutti i numeri di pagina? Sì, l’espressione ``Pagina [0-9]+ di 423`` troverebbe tutti I numeri di pagina in quel libro!"

#: ../../__w/calibre/calibre/manual/regexp.rst:52
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of). Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "Un appunto su questi quantificatori: di solito cercano di trovare la maggior quantità di testo possibile, quindi fai attenzione quando li usi. Questo è detto \"comportamento vorace\" - sono sicuro che capisci perché. Questo comportamento diventa problematico quando, poniamo, provi a trovare un tag. Considera per esempio la stringa ``\"<p class=\"calibre2\">Titolo qui</p>\"`` e poniamo che tu voglia trovare il tag di apertura (la parte inclusa nella prima coppia di parentesi angolari, maggiori informazioni sui tag più avanti). Ti verrebbe da pensare che l'espressione ``<p.*>`` trovi quel tag, ma in realtà trova l'intera stringa! (Il carattere \".\" è un altro carattere speciale. Trova ogni carattere tranne le interruzioni di riga quindi, in pratica, l'espressione ``.*`` troverebbe ogni singola linea immaginabile). Invece, prova a usare ``<p.*?>`` che rende il quantificatore ``\"*\"`` non vorace. Quell'espressione troverebbe solo il primo tag di apertura, come si voleva. C'è anche un altro modo per ottenere la stessa cosa, in realtà: l'espressione ``<p[^>]*>`` troverà lo stesso tag di apertura - capirai perché dopo la prossima sezione. Ricorda solo che c'è spesso più di un modo di scrivere un'espressione regolare."

#: ../../__w/calibre/calibre/manual/regexp.rst:56
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "Bene, questi caratteri speciali sono tutti molto graziosi, ma se volessi trovare un punto, o un punto di domanda?"

#: ../../__w/calibre/calibre/manual/regexp.rst:58
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "Puoi farlo, naturalmente: Basta mettere una barra rovesciata prima di ogni carattere speciale e sarà interpretato come il carattere digitato, senza alcun significato speciale. Questa coppia di barra rovesciata seguita da un carattere singolo è chiamata sequenza di escape, e l'atto di mettere una barra rovesciata prima di un carattere speciale è detto (in inglese) \"escaping the character\". Una sequenza di escape è interpretata come un singolo elemento. Naturalmente ci sono sequenze di escape che fanno di più che rappresentare semplicemente i caratteri speciali, per esempio ``\"\\t\"`` indica una tabulazione. Parleremo di alcune di queste sequenze di escape più avanti. Ah e comunque, riguardo a quei caratteri speciali: Considera che ognuno dei caratteri di cui discutiamo in questa introduzione perché hanno una certa funzione sia speciale, e che quindi abbia bisogno della barra di escape se vuoi il carattere digitato."

#: ../../__w/calibre/calibre/manual/regexp.rst:61
msgid "So, what are the most useful sets?"
msgstr "Quindi, quali sono i set più utili?"

#: ../../__w/calibre/calibre/manual/regexp.rst:63
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand:"
msgstr "Sapevo che l'avresti chiesto. Alcuni utili set sono ``[0-9]`` che trova una singola cifra, ``[a-z]`` che trova una singola lettera minuscola, ``[A-Z]`` che trova una singola lettera maiuscola, ``[a-zA-Z]`` che trova una singola lettera e ``[a-zA-Z0-9]`` che trova una singola lettera o numero. Puoi anche usare una sequenza di escape per fare più in fretta:"

#: ../../__w/calibre/calibre/manual/regexp.rst:66
msgid "``\\d``"
msgstr "``\\d``"

#: ../../__w/calibre/calibre/manual/regexp.rst:66
msgid "is equivalent to ``[0-9]``"
msgstr "è equivalente a ``[0-9]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:70
msgid "``\\w``"
msgstr "``\\w``"

#: ../../__w/calibre/calibre/manual/regexp.rst:69
msgid "is equivalent to ``[a-zA-Z0-9_]``"
msgstr "è equivalente a ``[a-zA-Z0-9_]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:73
msgid "``\\s``"
msgstr "``\\s``"

#: ../../__w/calibre/calibre/manual/regexp.rst:73
msgid "is equivalent to any whitespace"
msgstr "è equivalente a un qualunque spazio"

#: ../../__w/calibre/calibre/manual/regexp.rst:76
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed, carriage return, "
"non-breaking spaces, etc."
msgstr "Con \"spazio\" si intende qualsiasi cosa non venga stampata. Questi caratteri includono il normale spazio, il rientro (tabulazione), testo a capo, interruzione di pagina, ritorno a inizio riga, spazio unificatore, ecc."

#: ../../__w/calibre/calibre/manual/regexp.rst:78
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "Per concludere con i set, puoi anche definire un set con tutti i caratteri *esclusi* quelli nel set. Lo puoi fare includendo il carattere ``\"^\"`` come *primo carattere del set*. Così, ``[^a]`` troverebbe ogni carattere eccetto \"a\". Questo è detto integrare il set. Anche le sequenze di escape abbreviate che abbiamo visto in precedenza possono essere integrate: ``\"\\D\"`` significa qualunque carattere non numerico, essendo perciò equivalente a ``[^0-9]``. Le altre sequenze abbreviate possono essere integrate usando, hai indovinato, le rispettive lettere maiuscole invece di quelle minuscole. Quindi, tornando all'esempio ``<p[^>]*>`` della sezione precedente, ora puoi vedere che il set di caratteri utilizzato prova a trovare un qualsiasi carattere eccetto una parentesi angolare di chiusura."

#: ../../__w/calibre/calibre/manual/regexp.rst:81
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Ma se avessi alcune stringhe diverse tra loro da trovare, diventerebbe complicato?"

#: ../../__w/calibre/calibre/manual/regexp.rst:83
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in e-books, "
"it's annoying. You can group whole expressions in normal parentheses, and "
"the character ``\"|\"`` will let you match *either* the expression to its "
"right *or* the one to its left. Combine those and you're done. Too fast for "
"you? Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "Niente paura, non c'è niente di più semplice. Considera questo esempio: Il libro che stai convertendo ha scritto \"Titolo\" su tutte le pagine dispari e \"Autore\" su tutte le pagine pari. Molto carino su carta, vero? Ma in un e-book, è fastidioso. Puoi raggruppare intere espressioni tra normali parentesi tonde, e il carattere ``\"|\"`` ti farà trovare *o* l'espressione alla sua destra *o* quella alla sua sinistra. Combinale ed è fatta. Ho spiegato troppo in fretta? Va bene, per prima cosa raggruppiamo le espressioni per le pagine pari e dispari, ottenendo così le due espressioni che ci servono ``(Titolo)(Autore)``. Ora rendiamo le cose più semplici usando la barra verticale (``\"|\"`` è detto carattere di barra verticale): Se usi l'espressione ``(Titolo)|(Autore)`` troverai o un risultato per \"Titolo\" (nelle pagine dispari) o un risultato per \"Autore\" (nelle pagine pari). Abbastanza semplice, no?"

#: ../../__w/calibre/calibre/manual/regexp.rst:85
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "Naturalmente puoi usare la barra verticale anche senza le parentesi di raggruppamento. Ricordi quando ho detto che i quantificatori ripetono l'elemento che li precede? Ecco, la barra verticale funziona in un modo leggermente diverso: Anche l'espressione \"Titolo|Autore\" troverà o la stringa \"Titolo\" o la stringa \"Autore\", esattamente come l'esempio precedente con il raggruppamento. *La barra verticale sceglie tra l'intera espressione che la precede e quella che la segue*. Quindi, se volessi trovare le stringhe \"Calibre\" e \"calibre\" e volessi distinguere solo tra la \"c\" maiuscola e minuscola, dovresti usare l'espressione ``(c|C)alibre``, in cui il raggruppamento fa in modo che solo la \"c\" venga selezionata. Se invece avessi usato ``c|Calibre``, avresti ottenuto una corrispondenza con la stringa \"c\" o con la stringa \"Calibre\", che non è quello che volevamo. In breve: Nel dubbio, usa il raggruppamento insieme alla barra verticale."

#: ../../__w/calibre/calibre/manual/regexp.rst:88
msgid "You missed..."
msgstr "Ti sei dimenticato..."

#: ../../__w/calibre/calibre/manual/regexp.rst:90
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "... fermo fermo fermo, c'è un'ultima cosa molto uitle che puoi fare con i gruppi. Se hai catturato un gruppo in precedenza, puoi riferirti a quel gruppo più avanti nell'espressione stessa: I gruppi sono numerati a partire da 1, e puoi riferirti ad essi con il loro numero. Il quinto gruppo, per esempio, sarebbe richiamato da ``\\5``. Quindi, se cercassi ``([^ ]+) \\1`` nella stringa \"Test Test\", troveresti l'intera stringa!"

#: ../../__w/calibre/calibre/manual/regexp.rst:94
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "All'inizio hai detto che c'era un modo di creare un'espressione regolare che non distingue le maiuscole?"

#: ../../__w/calibre/calibre/manual/regexp.rst:96
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell "
"calibre how you want certain things handled by using something called flags."
" You include flags in your expression by using the special construct "
"``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with "
"the specific flags you want. For ignoring case, the flag is ``i``, thus you "
"include ``(?i)`` in your expression. Thus, ``(?i)test`` would match "
"\"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:98
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:101
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in calibre?"
msgstr "Penso di stare iniziando a capire queste espressioni regolari... Come le posso usare in calibre?"

#: ../../__w/calibre/calibre/manual/regexp.rst:104
msgid "Conversions"
msgstr "Conversioni"

#: ../../__w/calibre/calibre/manual/regexp.rst:106
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
":guilabel:`Search & replace` part, you can input a regexp (short for regular"
" expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what calibre \"sees\" during the conversion process. Scroll"
" down to the string you want to remove, select and copy it, paste it into "
"the regexp field on top of the window. If there are variable parts, like "
"page numbers or so, use sets and quantifiers to cover those, and while "
"you're at it, remember to escape special characters, if there are some. Hit "
"the button labeled :guilabel:`Test` and calibre highlights the parts it "
"would replace were you to use the regexp. Once you're satisfied, hit OK and "
"convert. Be careful if your conversion source has tags like this example::"
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:116
msgid ""
"(shamelessly ripped out of `this thread "
"<https://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point). The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what calibre will remove to make sure you don't remove any"
" portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, calibre tries to repair the damaged code after doing the"
" removal."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:119
msgid "Adding books"
msgstr "Aggiunta di libri"

#: ../../__w/calibre/calibre/manual/regexp.rst:121
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that calibre won't extract any meaningful data out"
" of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"calibre provides, you need to add the file extension to your testing "
"filename, otherwise you won't get any matches at all, despite using a "
"working expression."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:125
msgid "Bulk editing metadata"
msgstr "Modifica di gruppo dei metadati"

#: ../../__w/calibre/calibre/manual/regexp.rst:127
msgid ""
"The last part is regular expression :guilabel:`Search and replace` in "
"metadata fields. You can access this by selecting multiple books in the "
"library and using bulk metadata edit. Be very careful when using this last "
"feature, as it can do **Very Bad Things** to your library! Doublecheck that "
"your expressions do what you want them to using the test fields, and only "
"mark the books you really want to change! In the regular expression search "
"mode, you can search in one field, replace the text with something and even "
"write the result into another field. A practical example: Say your library "
"contained the books of Frank Herbert's Dune series, named after the fashion "
"``Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get "
"``Dune`` into the series field. You can do that by searching for ``(.*?) "
"\\d+ - .*`` in the title field and replacing it with ``\\1`` in the series "
"field. See what I did there? That's a reference to the first group you're "
"replacing the series field with. Now that you have the series all set, you "
"only need to do another search for ``.*? -`` in the title field and replace "
"it with ``\"\"`` (an empty string), again in the title field, and your "
"metadata is all neat and tidy. Isn't that great? By the way, instead of "
"replacing the entire field, you can also append or prepend to the field, so,"
" if you *wanted* the book title to be prepended with series info, you could "
"do that as well. As you by now have undoubtedly noticed, there's a checkbox "
"labeled :guilabel:`Case sensitive`, so you won't have to use flags to select"
" behaviour here."
msgstr ""

#: ../../__w/calibre/calibre/manual/regexp.rst:129
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<https://docs.python.org/library/re.html>`_."
msgstr "Bene, con ciò abbiamo quasi finito questa breve introduzione alle espressioni regolari. Con un po' di fortuna ti avrò mostrato abbastanza per farti almeno partire e permetterti di continuare a imparare per conto tuo - un buon posto dove guardare sarebbe `Python documentation for regexps <https://docs.python.org/library/re.html>`_."

#: ../../__w/calibre/calibre/manual/regexp.rst:131
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. calibre provides really great testing possibilities to see if"
" your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...). But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Un ultimo avviso, però: nonostante le espressioni regolari siano molto potenti, è anche molto facile sbagliare nel crearle. calibre fornisce ottime funzioni di prova per controllare se le tue espressioni funzionano come ti aspetti. Usale. Cerca di evitare di spararti nel piede. (Cielo, quanto mi piace questa espressione...). Ma anche se dovessi, nonostante i preavvisi, ferirti al piede (o in altre parti anatomiche), prova ad imparare da quanto successo."

#: ../../__w/calibre/calibre/manual/regexp.rst:135
msgid "Quick reference"
msgstr "Riferimenti rapidi"

#: ../../__w/calibre/calibre/manual/regexp.rst:143
msgid "Credits"
msgstr "Riconoscimenti"

#: ../../__w/calibre/calibre/manual/regexp.rst:145
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Grazie per aver contribuito con consigli, correzioni e altro:"

#: ../../__w/calibre/calibre/manual/regexp.rst:147
msgid "ldolse"
msgstr "ldolse"

#: ../../__w/calibre/calibre/manual/regexp.rst:148
msgid "kovidgoyal"
msgstr "kovidgoyal"

#: ../../__w/calibre/calibre/manual/regexp.rst:149
msgid "chaley"
msgstr "chaley"

#: ../../__w/calibre/calibre/manual/regexp.rst:150
msgid "dwanthny"
msgstr "dwanthny"

#: ../../__w/calibre/calibre/manual/regexp.rst:151
msgid "kacir"
msgstr "kacir"

#: ../../__w/calibre/calibre/manual/regexp.rst:152
msgid "Starson17"
msgstr "Starson17"

#: ../../__w/calibre/calibre/manual/regexp.rst:153
msgid "Orpheu"
msgstr "Orpheu"

#: ../../__w/calibre/calibre/manual/regexp.rst:155
msgid ""
"For more about regexps see `The Python User Manual "
"<https://docs.python.org/library/re.html>`_. The actual regular expression "
"library used by calibre is: `regex <https://bitbucket.org/mrabarnett/mrab-"
"regex/src/hg/>`_ which supports several useful enhancements over the Python "
"standard library one."
msgstr "Per più informazioni sulle regex vedi `The Python User Manual <https://docs.python.org/library/re.html>`_. In realtà la libreria usata da calibre per le espressioni regolari è `regex <https://bitbucket.org/mrabarnett/mrab-regex/src/hg/>`_, che supporta vari utili miglioramenti rispetto alla libreria standard di Python."
