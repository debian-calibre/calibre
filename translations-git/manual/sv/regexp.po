# SOME DESCRIPTIVE TITLE.
# Copyright (C) Kovid Goyal
# This file is distributed under the same license as the calibre package.
# 
# Translators:
# efef6ec5b435a041fce803c7f8af77d2_2341d43, 2020
# Jonatan Nyberg <jonatan@autistici.org>, 2016-2017,2021-2022
# Jonatan Nyberg <jonatan@autistici.org>, 2018-2021
# efef6ec5b435a041fce803c7f8af77d2_2341d43, 2017-2018
# efef6ec5b435a041fce803c7f8af77d2_2341d43, 2017
# Merarom <merarom@yahoo.es>, 2014-2015,2017
# Sebastian Rasmussen <sebras@gmail.com>, 2018
msgid ""
msgstr ""
"Project-Id-Version: calibre\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-15 08:35+0000\n"
"PO-Revision-Date: 2014-06-17 08:35+0000\n"
"Last-Translator: Jonatan Nyberg <jonatan@autistici.org>, 2016-2017,2021-2022\n"
"Language-Team: Swedish (http://www.transifex.com/calibre/calibre/language/sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: ../../__w/calibre/calibre/manual/regexp.rst:4
msgid "All about using regular expressions in calibre"
msgstr "Allt om att använda reguljära uttryck i calibre"

#: ../../__w/calibre/calibre/manual/regexp.rst:6
msgid ""
"Regular expressions are features used in many places in calibre to perform "
"sophisticated manipulation of e-book content and metadata. This tutorial is "
"a gentle introduction to getting you started with using regular expressions "
"in calibre."
msgstr "Reguljära uttryck är funktioner som används på många ställen i calibre för att utföra avancerad manipulation av e-bokens innehåll och metadata. Den här handledningen är en mild introduktion till att få dig igång med att använda vanliga uttryck i calibre."

#: ../../__w/calibre/calibre/manual/regexp.rst:11
msgid "Contents"
msgstr "Innehåll"

#: ../../__w/calibre/calibre/manual/regexp.rst:14
msgid "First, a word of warning and a word of courage"
msgstr "Först, ett varningens ord och ett modets ord"

#: ../../__w/calibre/calibre/manual/regexp.rst:16
msgid ""
"This is, inevitably, going to be somewhat technical- after all, regular "
"expressions are a technical tool for doing technical stuff. I'm going to "
"have to use some jargon and concepts that may seem complicated or "
"convoluted. I'm going to try to explain those concepts as clearly as I can, "
"but really can't do without using them at all. That being said, don't be "
"discouraged by any jargon, as I've tried to explain everything new. And "
"while regular expressions themselves may seem like an arcane, black magic "
"(or, to be more prosaic, a random string of mumbo-jumbo letters and signs), "
"I promise that they are not all that complicated. Even those who understand "
"regular expressions really well have trouble reading the more complex ones, "
"but writing them isn't as difficult- you construct the expression step by "
"step. So, take a step and follow me into the rabbit hole."
msgstr "Detta kommer, oundvikligen, att vara något tekniska trots allt, reguljära uttryck är ett tekniskt verktyg för att göra tekniska saker. Jag kommer att behöva använda en del jargong och begrepp som kan verka komplicerat och invecklat. Jag ska försöka förklara dessa begrepp så tydligt som jag kan, men egentligen kan jag inte göra det utan att använda dem alla. Med detta sagt, förkasta inte detta på grund av all jargong, jag har försökt att förklara allt nytt. Och medan reguljära uttryck själva kan verka som en svårbegripliga, svart magi (eller för att vara mer prosaisk, en slumpad sträng av rappakalja bokstäver och tecken), jag lovar att det är inte så komplicerat. Även de som förstår vanliga uttryck riktigt bra kan ha problem med att läsa de mer komplexa, men att skriva dem är inte så svårt - du konstruerar uttrycket steg för steg. Så, ta ett steg och följa mig in i kaninhålet."

#: ../../__w/calibre/calibre/manual/regexp.rst:19
msgid "Where in calibre can you use regular expressions?"
msgstr "Var i calibre kan man använda reguljära uttryck?"

#: ../../__w/calibre/calibre/manual/regexp.rst:21
msgid ""
"There are a few places calibre uses regular expressions. There's the "
":guilabel:`Search & replace` in conversion options, metadata detection from "
"filenames in the import settings and Search & replace when editing the "
"metadata of books in bulk. The calibre book editor can also use regular "
"expressions in its :guilabel:`Search and replace` feature. Finally, you can "
"use regular expressions when searching the calibre book list and when "
"searching inside the calibre E-book viewer."
msgstr "Det finns ett fåtal platser calibre använder reguljära uttryck. Det finns :guilabel:`Sök & ersätt` i konverteringsalternativ, metadatadetektering från filnamn i importinställningar och Sök och ersätt när du redigerar metadata för böcker i grupp. calibres redigerare kan även använda reguljära uttryck i sin :guilabel:`Sök och ersätt` funktion. Slutligen kan du använda reguljära uttryck när du söker i calibre-boklistan och när du söker i calibres e-bokvisare."

#: ../../__w/calibre/calibre/manual/regexp.rst:30
msgid "What on earth *is* a regular expression?"
msgstr "Vad i hela världen *är* ett reguljärt uttryck?"

#: ../../__w/calibre/calibre/manual/regexp.rst:32
msgid ""
"A regular expression is a way to describe sets of strings. A single regular "
"expression can *match* a number of different strings. This is what makes "
"regular expression so powerful -- they are a concise way of describing a "
"potentially large number of variations."
msgstr "Ett reguljärt uttryck är ett sätt att beskriva en uppsättningar strängar. En enda reguljära uttryck kan *matcha* flera olika strängar. Det är det som gör reguljära uttryck så kraftfulla -- de är ett kortfattad sätt att beskriva ett potentiellt stort antal varianter."

#: ../../__w/calibre/calibre/manual/regexp.rst:34
msgid ""
"I'm using string here in the sense it is used in programming languages: a "
"string of one or more characters, characters including actual characters, "
"numbers, punctuation and so-called whitespace (linebreaks, tabulators etc.)."
" Please note that generally, uppercase and lowercase characters are not "
"considered the same, thus \"a\" being a different character from \"A\" and "
"so forth. In calibre, regular expressions are case insensitive in the Search"
" bar, but not in the conversion options. There's a way to make every regular"
" expression case insensitive, but we'll discuss that later. It gets "
"complicated because regular expressions allow for variations in the strings "
"it matches, so one expression can match multiple strings, which is why "
"people bother using them at all. More on that in a bit."
msgstr "Jag använder sträng här i den mening den används i programspråk: en sträng av ett eller flera tecken, tecken inklusive faktiska tecken, siffror, skiljetecken och s.k. whitespace (radbrytningar, tabulatorer o.s.v.). Observera att i allmänhet anses inte stora och små bokstäver vara samma, alltså \"a\" som en annan karaktär från \"A\" och så vidare. I calibre, är reguljära uttryck skiftlägesokänslig i sökfältet, men inte i konverteringsalternativet. Det finns ett sätt att göra alla reguljära uttryck fall okänsligt, men vi kommer att diskutera det senare. Det blir komplicerat eftersom reguljära uttryck tillåter variationer i strängar som matchar, så ett uttryck kan matcha flera strängar, vilket är varför folk bryr sig att använda dem. Mer om det om ett tag."

#: ../../__w/calibre/calibre/manual/regexp.rst:37
msgid "Care to explain?"
msgstr "Har du lust att förklara?"

#: ../../__w/calibre/calibre/manual/regexp.rst:39
msgid ""
"Well, that's why we're here. First, this is the most important concept in "
"regular expressions: *A string by itself is a regular expression that "
"matches itself*. That is to say, if I wanted to match the string ``\"Hello, "
"World!\"`` using a regular expression, the regular expression to use would "
"be ``Hello, World!``. And yes, it really is that simple. You'll notice, "
"though, that this *only* matches the exact string ``\"Hello, World!\"``, not"
" e.g. ``\"Hello, wOrld!\"`` or ``\"hello, world!\"`` or any other such "
"variation."
msgstr "Tja, det är därför vi är här. För det första är detta det viktigaste konceptet i reguljära uttryck: *En sträng i sig är ett reguljärt uttryck som matchar sig själv*. Det vill säga, om jag ville matcha strängen ``\"Hej, Värld!\"`` genom att använda ett reguljärt uttryck, skulle det reguljära uttrycket för att använda vara ``Hej, Värld!``. Och ja, det är verkligen så enkelt. Du kommer att märka dock att detta *endast* matchar den exakta strängen ``\"Hej, Värld!\"``, inte t.ex. ``\"Hej vÄrlden!\"`` eller ``\"hej, värld!\"`` eller någon annan sådan variation."

#: ../../__w/calibre/calibre/manual/regexp.rst:42
msgid "That doesn't sound too bad. What's next?"
msgstr "Det låter inte så illa. Vad kommer härnäst?"

#: ../../__w/calibre/calibre/manual/regexp.rst:44
msgid ""
"Next is the beginning of the really good stuff. Remember where I said that "
"regular expressions can match multiple strings? This is where it gets a "
"little more complicated. Say, as a somewhat more practical exercise, the "
"e-book you wanted to convert had a nasty footer counting the pages, like "
"\"Page 5 of 423\". Obviously the page number would rise from 1 to 423, thus "
"you'd have to match 423 different strings, right? Wrong, actually: regular "
"expressions allow you to define sets of characters that are matched: To "
"define a set, you put all the characters you want to be in the set into "
"square brackets. So, for example, the set ``[abc]`` would match either the "
"character \"a\", \"b\" or \"c\". *Sets will always only match one of the "
"characters in the set*. They \"understand\" character ranges, that is, if "
"you wanted to match all the lower case characters, you'd use the set "
"``[a-z]`` for lower- and uppercase characters you'd use ``[a-zA-Z]`` and so "
"on. Got the idea? So, obviously, using the expression ``Page [0-9] of 423`` "
"you'd be able to match the first 9 pages, thus reducing the expressions "
"needed to three: The second expression ``Page [0-9][0-9] of 423`` would "
"match all two-digit page numbers, and I'm sure you can guess what the third "
"expression would look like. Yes, go ahead. Write it down."
msgstr "Nästa är början på riktigt bra grejer. Kom ihåg var jag sa att reguljära uttryck kan matcha flera strängar? Det är här det blir lite mer komplicerat. Säg, som en något mer praktisk övning, e-boken du ville konvertera hade en otäck sidfot som räknar sidor, \"Sida 5 av 423\". Uppenbarligen skulle sidnumret stiga från 1 till 423, så du skulle behöva matcha 423 olika strängar, eller hur? Fel, faktiskt: reguljära uttryck tillåter dig definiera uppsättningar av tecken som matchar: För att definiera en uppsättning, lägger du alla de tecken du vill att ska vara i uppsättningen inom hakparenteser. Så, till exempel uppsättningen `` [abc]`` skulle matcha antingen tecknet \"a\", \"b\" eller \"c\". *Uppsättningarna kommer alltid bara matcha en av karaktärerna i uppsättningen*. De \"förstår\" teckenformattering, det vill säga om du ville matcha mot alla små bokstäver, skulle du använda uppsättningen ``[az]`` för gemener och för versaler skulle du använda `` [a-zA-Z]`` o.s.v. Förstår du principen? Så, självklart, med hjälp av uttrycket ``Sida [0-9] av 423`` skulle du kunna matcha de första nio sidorna, vilket minskar uttrycken som behövs för tre: Det andra uttrycket ``Sida [0-9] [0-9] av 423`` skulle matcha alla tvåsiffriga sidnummer, och jag är säker på att du kan gissa hur det tredje uttryck skulle se ut. Ja, gå vidare. Skriv ner det."

#: ../../__w/calibre/calibre/manual/regexp.rst:47
msgid "Hey, neat! This is starting to make sense!"
msgstr "Hej, snyggt! Detta börjar låta vettigt!"

#: ../../__w/calibre/calibre/manual/regexp.rst:49
msgid ""
"I was hoping you'd say that. But brace yourself, now it gets even better! We"
" just saw that using sets, we could match one of several characters at once."
" But you can even repeat a character or set, reducing the number of "
"expressions needed to handle the above page number example to one. Yes, ONE!"
" Excited? You should be! It works like this: Some so-called special "
"characters, \"+\", \"?\" and \"*\", *repeat the single element preceding "
"them*. (Element means either a single character, a character set, an escape "
"sequence or a group (we'll learn about those last two later)- in short, any "
"single entity in a regular expression). These characters are called "
"wildcards or quantifiers. To be more precise, \"?\" matches *0 or 1* of the "
"preceding element, \"*\" matches *0 or more* of the preceding element and "
"\"+\" matches *1 or more* of the preceding element. A few examples: The "
"expression ``a?`` would match either \"\" (which is the empty string, not "
"strictly useful in this case) or \"a\", the expression ``a*`` would match "
"\"\", \"a\", \"aa\" or any number of a's in a row, and, finally, the "
"expression ``a+`` would match \"a\", \"aa\" or any number of a's in a row "
"(Note: it wouldn't match the empty string!). Same deal for sets: The "
"expression ``[0-9]+`` would match *every integer number there is*! I know "
"what you're thinking, and you're right: If you use that in the above case of"
" matching page numbers, wouldn't that be the single one expression to match "
"all the page numbers? Yes, the expression ``Page [0-9]+ of 423`` would match"
" every page number in that book!"
msgstr "Jag hoppades att du skulle säga det. Men håll i dig själv, nu blir det ännu bättre! Vi såg precis att med uppsättning kan vi matcha en av flera tecken samtidigt. Men du kan även upprepa ett tecken eller uppsättning, för att minska antalet uttryck som behövs för att hantera ovan sidnummerexemplet till ett. Ja, ETT! Upphetsad? Du borde vara det! Det fungerar så här: Några så kallade specialtecken \"+\", \"?\" och \"*\", * upprepa det enda elementet som föregår dem*. (Element betyder antingen ett enda tecken, en teckenuppsättning, en flyktsekvens eller en grupp (vi ska lära oss om de två sista senare) - kort sagt vilken enskild enhet som helst i ett reguljärt uttryck). Dessa tecken kallas jokertecken eller kvantifierare. För att vara mer exakt, \"?\" matchar *0 eller 1* förekomster av det föregående elementet, \"*\" matchar *0 eller flera* för det föregående elementet och \"+\" matchar *1 eller flera* av det föregående elementet. Några exempel: Uttrycket ``a?`` skulle matcha antingen \"\" (som är den tomma strängen, inte strikt användbar i detta fall) eller \"a\", uttrycket ``a*`` skulle matcha \"\", \"a\", \"aa\" eller valfritt antal a i rad, och slutligen uttrycket ``a+`` skulle matcha \"a\", \"aa\" eller valfritt antal a i rad (Observera: det skulle inte matcha den tomma strängen!). Samma gäller för uppsättningar: Uttrycket `` [0-9]+`` skulle matcha *varje heltal som finns*! Jag vet vad du tänker, och du har rätt: Om du använder fallet med matchande sidnummer ovan, skulle inte det vara det enda uttrycket för att matcha alla sidnummer? Ja, uttrycket ``Page [0-9]+ of 423`` skulle matcha varje sidnummer i den boken!"

#: ../../__w/calibre/calibre/manual/regexp.rst:52
msgid ""
"A note on these quantifiers: They generally try to match as much text as "
"possible, so be careful when using them. This is called \"greedy "
"behaviour\"- I'm sure you get why. It gets problematic when you, say, try to"
" match a tag. Consider, for example, the string ``\"<p "
"class=\"calibre2\">Title here</p>\"`` and let's say you'd want to match the "
"opening tag (the part between the first pair of angle brackets, a little "
"more on tags later). You'd think that the expression ``<p.*>`` would match "
"that tag, but actually, it matches the whole string! (The character \".\" is"
" another special character. It matches anything *except* linebreaks, so, "
"basically, the expression ``.*`` would match any single line you can think "
"of). Instead, try using ``<p.*?>`` which makes the quantifier ``\"*\"`` non-"
"greedy. That expression would only match the first opening tag, as intended."
" There's actually another way to accomplish this: The expression "
"``<p[^>]*>`` will match that same opening tag- you'll see why after the next"
" section. Just note that there quite frequently is more than one way to "
"write a regular expression."
msgstr "En kommentar om dessa kvantifierare: De försöker i allmänhet att matcha så mycket text som möjligt, så var försiktig när du använder dem. Detta kallas \"girigt beteende\" - Jag är säker på att du förstår varför. Det blir problematiskt när man, säg, försöker matcha en tagg. Tänk dig, till exempel strängen ``\"<p class =\" calibre2\">Titel här</p>\"`` och låt oss säga att du skulle vilja matcha öppningstaggen (delen mellan det första paret vinkelfästen, lite mer om taggar senare). Man skulle kunna tro att uttrycket ``<p.*>`` skulle matcha den taggen men faktiskt, den matchar hela strängen! (Tecknet \".\" Är ett annat specialtecken. Den matchar något *utom* radbrytningar, så i grund och botten, uttrycket ``.*`` Skulle matcha vilken rad du än kan tänka dig). Försök istället att använda ``<p.*?>`` som gör kvantifierare ``\"*\"`` ogiriga. Detta uttryck skulle endast matcha den första öppningstaggen, som avsett. Det finns faktiskt ett annat sätt att åstadkomma detta: Uttrycket ``<p[^>]*>`` matchar denna öppningstagg- du kommer se varför efter nästa avsnitt. Bara konstatera att det ganska ofta finns mer än ett sätt att skriva ett reguljärt uttryck."

#: ../../__w/calibre/calibre/manual/regexp.rst:56
msgid ""
"Well, these special characters are very neat and all, but what if I wanted "
"to match a dot or a question mark?"
msgstr "Tja, dessa specialtecken är mycket snygga och allt, men vad händer om jag ville matcha en punkt eller ett frågetecken?"

#: ../../__w/calibre/calibre/manual/regexp.rst:58
msgid ""
"You can of course do that: Just put a backslash in front of any special "
"character and it is interpreted as the literal character, without any "
"special meaning. This pair of a backslash followed by a single character is "
"called an escape sequence, and the act of putting a backslash in front of a "
"special character is called escaping that character. An escape sequence is "
"interpreted as a single element. There are of course escape sequences that "
"do more than just escaping special characters, for example ``\"\\t\"`` means"
" a tabulator. We'll get to some of the escape sequences later. Oh, and by "
"the way, concerning those special characters: Consider any character we "
"discuss in this introduction as having some function to be special and thus "
"needing to be escaped if you want the literal character."
msgstr "Du kan självklart göra det: Lägg bara ett bakåtsnedstreck framför valfritt specialtecken och det tolkas som det bokstavliga tecknet, utan någon speciell betydelse. Detta par av ett bakåtsnedstreck följt av ett enstaka tecken kallas en flyktsekvensen, och handlingen att sätta ett bakåtsnedstreck framför ett specialtecken kallas ett flykttecken. En flyktsekvens tolkas som ett enda element. Det finns givetvis flyktsekvensener som gör mer än att bara flykttecken, till exempel betyder ``\"\\t\"`` en tabulator. Vi kommer till några av flyktsekvenserna senare. Åh, och förresten, angående dessa specialtecken: Betrakta alla tecken som vi diskuterar i den här introduktionen som att de har någon speciell funktion och därför måste flyktmarkeras om du vill ha det bokstavliga tecknet."

#: ../../__w/calibre/calibre/manual/regexp.rst:61
msgid "So, what are the most useful sets?"
msgstr "Så, vilka är de användbaraste uppsättningarna?"

#: ../../__w/calibre/calibre/manual/regexp.rst:63
msgid ""
"Knew you'd ask. Some useful sets are ``[0-9]`` matching a single number, "
"``[a-z]`` matching a single lowercase letter, ``[A-Z]`` matching a single "
"uppercase letter, ``[a-zA-Z]`` matching a single letter and ``[a-zA-Z0-9]`` "
"matching a single letter or number. You can also use an escape sequence as "
"shorthand:"
msgstr "Visste att du skulle fråga. Några användbara uppsättningar är ``[0-9]`` matchar en enda siffra, ``[a-z]`` matchar en enda gemen, ``[A-Z]`` matchar en enda versal, ``[a-zA-Z]`` matchar en enda bokstav och ``[a-zA-Z0-9]`` matchar en enda bokstav eller siffra. Du kan också använda en flyktsekvens som stenografi:"

#: ../../__w/calibre/calibre/manual/regexp.rst:70
msgid "``\\d``"
msgstr "``\\d``"

#: ../../__w/calibre/calibre/manual/regexp.rst:70
msgid "is equivalent to ``[0-9]``"
msgstr "motsvarar ``[0-9]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:74
msgid "``\\w``"
msgstr "``\\w``"

#: ../../__w/calibre/calibre/manual/regexp.rst:73
msgid "is equivalent to ``[a-zA-Z0-9_]``"
msgstr "motsvarar ``[a-zA-Z0-9_]``"

#: ../../__w/calibre/calibre/manual/regexp.rst:77
msgid "``\\s``"
msgstr "``\\s``"

#: ../../__w/calibre/calibre/manual/regexp.rst:77
msgid "is equivalent to any whitespace"
msgstr "motsvarar alla whitespace"

#: ../../__w/calibre/calibre/manual/regexp.rst:80
msgid ""
"\"Whitespace\" is a term for anything that won't be printed. These "
"characters include space, tabulator, line feed, form feed, carriage return, "
"non-breaking spaces, etc."
msgstr "\"Whitespace\" är en term för allt som inte kommer att skrivas ut. Dessa tecken inkluderar blanksteg, tabulator, radmatning, formulärmatning, vagnretur, icke-brytande blanksteg o.s.v."

#: ../../__w/calibre/calibre/manual/regexp.rst:83
msgid ""
"The upper and lower case sets may match both upper and lowercase if the "
"setting to make searches case insensitive is enabled. Such settings are "
"found, for instance in Preferences->Searching in calibre itself and on the "
"Search panel in the calibre :guilabel:`E-book viewer` as well as the calibre"
" :guilabel:`Edit book` tool."
msgstr "Uppsättningarna med versaler och gemener kan matcha både versaler och gemener om inställningen för att göra sökningar okänsliga för skiftlägen är aktiverad. Sådana inställningar finns, till exempel i Inställningar->Sökning i själva calibre och i sökpanelen i verktyget calibre :guilabel:`e-bokvisaren` samt calibre-verktyget :guilabel:`Redigera bok`."

#: ../../__w/calibre/calibre/manual/regexp.rst:89
msgid ""
"As a last note on sets, you can also define a set as any character *but* "
"those in the set. You do that by including the character ``\"^\"`` as the "
"*very first character in the set*. Thus, ``[^a]`` would match any character "
"excluding \"a\". That's called complementing the set. Those escape sequence "
"shorthands we saw earlier can also be complemented: ``\"\\D\"`` means any "
"non-number character, thus being equivalent to ``[^0-9]``. The other "
"shorthands can be complemented by, you guessed it, using the respective "
"uppercase letter instead of the lowercase one. So, going back to the example"
" ``<p[^>]*>`` from the previous section, now you can see that the character "
"set it's using tries to match any character except for a closing angle "
"bracket."
msgstr "Som en sista anteckning om uppsättningar kan du också definiera en uppsättning som valfritt tecken *utom* de i uppsättningen. Du gör det genom att inkludera tecknet ``\"^\"`` som det *allra första tecknet i uppsättningen*. Således skulle ``[^a]`` matcha alla tecken utom \"a\". Det kallas att komplettera uppsättningen. Dessa flyktsekvensstenografier som vi såg tidigare kan också kompletteras: ``\"\\D\"`` betyder vilket tecken som helst som inte är numeriskt, och är alltså ekvivalent med ``[^0-9]``. De andra stenografierna kan kompletteras med, du gissade rätt, att använda respektive versaler istället för gemener. Så, om du går tillbaka till exemplet ``<p[^>]*>`` från föregående avsnitt, kan du nu se att teckenuppsättningen den använder försöker matcha vilket tecken som helst förutom en avslutande vinkelparentes."

#: ../../__w/calibre/calibre/manual/regexp.rst:94
msgid ""
"But if I had a few varying strings I wanted to match, things get "
"complicated?"
msgstr "Men om jag hade några olika strängar jag ville matcha, blir saker komplicerade?"

#: ../../__w/calibre/calibre/manual/regexp.rst:96
msgid ""
"Fear not, life still is good and easy. Consider this example: The book "
"you're converting has \"Title\" written on every odd page and \"Author\" "
"written on every even page. Looks great in print, right? But in e-books, "
"it's annoying. You can group whole expressions in normal parentheses, and "
"the character ``\"|\"`` will let you match *either* the expression to its "
"right *or* the one to its left. Combine those and you're done. Too fast for "
"you? Okay, first off, we group the expressions for odd and even pages, thus "
"getting ``(Title)(Author)`` as our two needed expressions. Now we make "
"things simpler by using the vertical bar (``\"|\"`` is called the vertical "
"bar character): If you use the expression ``(Title|Author)`` you'll either "
"get a match for \"Title\" (on the odd pages) or you'd match \"Author\" (on "
"the even pages). Well, wasn't that easy?"
msgstr "Frukta inte, livet är fortfarande bra och enkelt. Tänk på detta exempel: Boken du konverterar har \"Titel\" skrivet på varje udda sida och \"Författare\" skrivet på varje jämn sida. Ser bra i tryck, eller hur? Men i e-böcker är det irriterande. Du kan gruppera hela uttryck i normala parenteser och tecknet ``\"|\"`` låter dig matcha *antingen* uttrycket till höger *eller* det till vänster. Kombinera dem så är du klar. För snabbt för dig? Okej, först och främst grupperar vi uttryck för udda och jämna sidor och på så sätt får ``(Titel)(Författare)`` som våra två nödvändiga uttryck. Nu gör vi det enklare genom att använda det lodräta strecket (``\"|\"`` kallas vertikala stapeltecknet): Om du använder uttrycket ``(Titel|Författare)`` får du antingen en träff för \"Titel\" (på udda sidorna) eller så får du en träff för \"Författare\" (på jämna sidorna). Var det inte lätt?"

#: ../../__w/calibre/calibre/manual/regexp.rst:98
msgid ""
"You can, of course, use the vertical bar without using grouping parentheses,"
" as well. Remember when I said that quantifiers repeat the element preceding"
" them? Well, the vertical bar works a little differently: The expression "
"\"Title|Author\" will also match either the string \"Title\" or the string "
"\"Author\", just as the above example using grouping. *The vertical bar "
"selects between the entire expression preceding and following it*. So, if "
"you wanted to match the strings \"Calibre\" and \"calibre\" and wanted to "
"select only between the upper- and lowercase \"c\", you'd have to use the "
"expression ``(c|C)alibre``, where the grouping ensures that only the \"c\" "
"will be selected. If you were to use ``c|Calibre``, you'd get a match on the"
" string \"c\" or on the string \"Calibre\", which isn't what we wanted. In "
"short: If in doubt, use grouping together with the vertical bar."
msgstr "Du kan naturligtvis använda det lodräta strecket utan att använda grupperingsparenteser, lika så. Kommer du ihåg när jag sa att kvantifierare upprepar elementet som föregår dem? Tja, det vertikala strecket fungerar lite annorlunda: Uttrycket \"Titel|Författare\" kommer också att matcha antingen strängen \"Titel\" eller strängen \"Författare\", precis som ovanstående exempel med hjälp av gruppering. *Det vertikala strecket väljer mellan hela uttrycket före och efter den*. Så, om du ville matcha strängarna \"Calibre\" och \"calibre\" och ville bara välja mellan det övre och små bokstäver \"c\", skulle du behöva använda uttrycket ``(c|C)alibre``, där grupperingen säkerställer att endast \"c\" kommer att väljas. Om du skulle använda ``c|Calibre``, du skulle få en match på strängen \"c\" eller på strängen \"Calibre\", vilket inte är vad vi ville ha. Kort sagt: Om du är osäker, använd gruppering tillsammans med det vertikala strecket."

#: ../../__w/calibre/calibre/manual/regexp.rst:101
msgid "You missed..."
msgstr "Du missade..."

#: ../../__w/calibre/calibre/manual/regexp.rst:103
msgid ""
"... wait just a minute, there's one last, really neat thing you can do with "
"groups. If you have a group that you previously matched, you can use "
"references to that group later in the expression: Groups are numbered "
"starting with 1, and you reference them by escaping the number of the group "
"you want to reference, thus, the fifth group would be referenced as ``\\5``."
" So, if you searched for ``([^ ]+) \\1`` in the string \"Test Test\", you'd "
"match the whole string!"
msgstr "... vänta lite, det finns en sista, riktigt snygg sak du kan göra med uppsättningar. Om du har en uppsättning som du tidigare matchade kan du använda referenser till uppsättningen senare i uttrycket: Uppsättningar är numrerade med början 1, och du refererar till dem genom att flyktnumret på den uppsättning som du vill referera till, alltså den femte gruppen skulle kallad ``\\5``. Så, om du sökte ``([^]+)\\1`` i strängen \"Test Test\", skulle du matcha hela strängen!"

#: ../../__w/calibre/calibre/manual/regexp.rst:107
msgid ""
"In the beginning, you said there was a way to make a regular expression case"
" insensitive?"
msgstr "I början sa du att det fanns ett sätt att göra ett reguljärt uttryck skiftlägesokänsligt?"

#: ../../__w/calibre/calibre/manual/regexp.rst:109
msgid ""
"Yes, I did, thanks for paying attention and reminding me. You can tell "
"calibre how you want certain things handled by using something called flags."
" You include flags in your expression by using the special construct "
"``(?flags go here)`` where, obviously, you'd replace \"flags go here\" with "
"the specific flags you want. For ignoring case, the flag is ``i``, thus you "
"include ``(?i)`` in your expression. Thus, ``(?i)test`` would match "
"\"Test\", \"tEst\", \"TEst\" and any case variation you could think of."
msgstr "Ja, det gjorde jag, tack för att uppmärksammande och att du påminde mig. Du kan berätta för calibre hur du vill vissa saker hanteras med hjälp av något som kallas flaggor. Du inkluderar flaggor i ditt uttryck med hjälp av speciella konstruktionen ``(?flaggor finns här)`` där, naturligtvis, skulle du ersätta \"flaggor finns här\" med de specifika flaggor du vill ha. För att ignorera teckenskiftläge finns flaggan ``i`` därmed inkluderar du ``(?i)`` i ditt uttryck. Således ``(?i)test`` skulle matcha \"Test\", \"tEst\", \"TEst\", och varje fall variation du kan tänka dig."

#: ../../__w/calibre/calibre/manual/regexp.rst:111
msgid ""
"Another useful flag lets the dot match any character at all, *including* the"
" newline, the flag ``s``. If you want to use multiple flags in an "
"expression, just put them in the same statement: ``(?is)`` would ignore case"
" and make the dot match all. It doesn't matter which flag you state first, "
"``(?si)`` would be equivalent to the above."
msgstr "En annan användbar flagga låter punkten matcha vilket tecken som helst, *inklusive* den nyrad, flaggan ``s``. Om du vill använda flera flaggor i en sats, lägg dem bara i samma sats: ``(?is)`` skulle ignorera skiftläge och göra att punkten matchar alla. Det spelar ingen roll vilken flagga som du anger först, ``(?si)`` skulle motsvara ovanstående."

#: ../../__w/calibre/calibre/manual/regexp.rst:114
msgid ""
"I think I'm beginning to understand these regular expressions now... how do "
"I use them in calibre?"
msgstr "Jag tror jag börjar förstå dessa reguljära uttryck nu... hur använder jag dem i calibre?"

#: ../../__w/calibre/calibre/manual/regexp.rst:117
msgid "Conversions"
msgstr "Konverteringar"

#: ../../__w/calibre/calibre/manual/regexp.rst:119
msgid ""
"Let's begin with the conversion settings, which is really neat. In the "
":guilabel:`Search & replace` part, you can input a regexp (short for regular"
" expression) that describes the string that will be replaced during the "
"conversion. The neat part is the wizard. Click on the wizard staff and you "
"get a preview of what calibre \"sees\" during the conversion process. Scroll"
" down to the string you want to remove, select and copy it, paste it into "
"the regexp field on top of the window. If there are variable parts, like "
"page numbers or so, use sets and quantifiers to cover those, and while "
"you're at it, remember to escape special characters, if there are some. Hit "
"the button labeled :guilabel:`Test` and calibre highlights the parts it "
"would replace were you to use the regexp. Once you're satisfied, hit OK and "
"convert. Be careful if your conversion source has tags like this example::"
msgstr "Låt oss börja med konverteringsinställningarna, vilket är riktigt snyggt. I Sök- och ersättsdel, kan mata in en regexp (kort för reguljära uttryck) som beskriver den sträng som kommer att ersättas under konverteringen. Den nätta delen är guiden. Klicka på guiden och du får en förhandsvisning av vad calibre \"ser\" under konverteringen. Bläddra ner till den sträng som du vill ta bort, välj och kopiera den, klistra in den i regexp fältet högst upp i fönstret. Om det finns variabla delar, t.ex. sidnummer eller så använder uppsättningar och kvantifierare för att täcka dem, och medan du ändå håller på, kom ihåg att undkomma specialtecken, om det finns några. Klicka på knappen :guilabel:`Test` och calibre belyser delarna som skulle ersättas om du använder regexp. När du är nöjd, klicka på OK och konvertera. Var försiktig om din konverteringskällan har taggar som detta exempel::"

#: ../../__w/calibre/calibre/manual/regexp.rst:129
msgid ""
"(shamelessly ripped out of `this thread "
"<https://www.mobileread.com/forums/showthread.php?t=75594\">`_). You'd have "
"to remove some of the tags as well. In this example, I'd recommend beginning"
" with the tag ``<b class=\"calibre2\">``, now you have to end with the "
"corresponding closing tag (opening tags are ``<tag>``, closing tags are "
"``</tag>``), which is simply the next ``</b>`` in this case. (Refer to a "
"good HTML manual or ask in the forum if you are unclear on this point). The "
"opening tag can be described using ``<b.*?>``, the closing tag using "
"``</b>``, thus we could remove everything between those tags using "
"``<b.*?>.*?</b>``. But using this expression would be a bad idea, because it"
" removes everything enclosed by <b>- tags (which, by the way, render the "
"enclosed text in bold print), and it's a fair bet that we'll remove portions"
" of the book in this way. Instead, include the beginning of the enclosed "
"string as well, making the regular expression "
"``<b.*?>\\s*Generated\\s+by\\s+ABC\\s+Amber\\s+LIT.*?</b>`` The ``\\s`` with"
" quantifiers are included here instead of explicitly using the spaces as "
"seen in the string to catch any variations of the string that might occur. "
"Remember to check what calibre will remove to make sure you don't remove any"
" portions you want to keep if you test a new expression. If you only check "
"one occurrence, you might miss a mismatch somewhere else in the text. Also "
"note that should you accidentally remove more or fewer tags than you "
"actually wanted to, calibre tries to repair the damaged code after doing the"
" removal."
msgstr "(skamlöst utslitet från `denna tråd <https://www.mobileread.com/forums/showthread.php?t=75594\">`_). Du skulle behöva ta bort en del av taggarna också. I detta exempel jag skulle rekommendera börjar med taggen ``<b class=\"calibre2\">``, nu måste du sluta med motsvarande sluttagg (öppningstaggar är ``<tag>``, sluttaggar är ``</tag>``), vilket är helt enkelt nästa ``</b>`` i detta fall. (Se en bra HTML-handboken eller fråga i forumet om du är osäker på den här punkten). Öppningstaggen kan vara beskrivas med ``<b.*?>``, den avslutande taggen med hjälp av ``</b>``, vilket vi kunde ta bort allt mellan dessa taggar med ``<b.*?>.*?</b>``. Men att använda detta uttryck skulle vara en dålig idé, eftersom det tar bort allt omges av <b>- taggar (som förresten, återger den medföljande texten i fetstil), och det är en rimlig satsning som vi tar bort delar av boken på detta sätt. Istället inkluderar början av den medföljande strängen också, vilket gör det reguljära uttrycket ``<b.*?>\\s*Skapa\\s+genom\\s+ABC\\s+Amber\\s+LIT.*?</b>`` Den ``\\s`` med kvantifierare som ingår här i stället för explicit använda blanksteg som sedda i strängen för att fånga några varianter av strängen som kan uppstå. Kom ihåg att kontrollera vad calibre kommer att ta bort för att se till att du inte bort några delar som du vill behålla om du testar ett nytt uttryck. Om du bara kontrollera en händelse, kanske du missar en obalans någon annanstans i texten. Observera också att om du av misstag tar bort fler eller färre taggar än du faktiskt ville försöker calibre för att reparera den skadade koden efter att ha gjort borttagningen."

#: ../../__w/calibre/calibre/manual/regexp.rst:132
msgid "Adding books"
msgstr "Lägga till böcker"

#: ../../__w/calibre/calibre/manual/regexp.rst:134
msgid ""
"Another thing you can use regular expressions for is to extract metadata "
"from filenames. You can find this feature in the \"Adding books\" part of "
"the settings. There's a special feature here: You can use field names for "
"metadata fields, for example ``(?P<title>)`` would indicate that calibre "
"uses this part of the string as book title. The allowed field names are "
"listed in the windows, together with another nice test field. An example: "
"Say you want to import a whole bunch of files named like ``Classical Texts: "
"The Divine Comedy by Dante Alighieri.mobi``. (Obviously, this is already in "
"your library, since we all love classical italian poetry) or ``Science "
"Fiction epics: The Foundation Trilogy by Isaac Asimov.epub``. This is "
"obviously a naming scheme that calibre won't extract any meaningful data out"
" of - its standard expression for extracting metadata is ``(?P<title>.+) - "
"(?P<author>[^_]+)``. A regular expression that works here would be "
"``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Please note that, inside the"
" group for the metadata field, you need to use expressions to describe what "
"the field actually matches. And also note that, when using the test field "
"calibre provides, you need to add the file extension to your testing "
"filename, otherwise you won't get any matches at all, despite using a "
"working expression."
msgstr "En annan sak du kan använda reguljära uttryck för är att utvinna metadata från filnamn. Du hittar den här funktionen \"Lägga till böcker\" i en del av inställningarna. Det finns en speciell funktion här: Du kan använda fältnamn för metadatafält, till exempel ``(?P<titel>)`` skulle indikera att calibre använder den här delen av strängen som boktitel. De tillåtna fältnamnen listas i fönstren, tillsammans med ett annat fint testfält. Ett exempel: Säg att du vill importera en hel massa filer som heter ``Klassiska texter: Den gudomliga komedin av Dante Alighieri.mobi``. (Uppenbarligen finns detta redan i ditt bibliotek, eftersom vi alla älskar klassisk italiensk poesi) eller ``Science Fiction epos: Stiftelseserien av Isaac Asimov.epub``. Detta är naturligtvis ett namngivningssystem som calibre inte kommer att utvinna några meningsfulla uppgifter ur - dess standarduttryck för att utvinna metadata är ``(?P<title>.+) - (?P<author>[^_]+)``. Ett reguljärt uttryck som fungerar här skulle vara ``[a-zA-Z]+: (?P<title>.+) by (?P<author>.+)``. Observera att i gruppen för metadatafältet måste du använda uttryck för att beskriva vad fältet faktiskt matchar. Och observera också att vid användning av testfältet calibre tillhandahåller måste du lägga till filändelsen till ditt testfilnamn, annars får du inga matchningar alls, trots att du använder ett fungerande uttryck."

#: ../../__w/calibre/calibre/manual/regexp.rst:138
msgid "Bulk editing metadata"
msgstr "Redigera metadata i grupp"

#: ../../__w/calibre/calibre/manual/regexp.rst:140
msgid ""
"The last part is regular expression :guilabel:`Search and replace` in "
"metadata fields. You can access this by selecting multiple books in the "
"library and using bulk metadata edit. Be very careful when using this last "
"feature, as it can do **Very Bad Things** to your library! Doublecheck that "
"your expressions do what you want them to using the test fields, and only "
"mark the books you really want to change! In the regular expression search "
"mode, you can search in one field, replace the text with something and even "
"write the result into another field. A practical example: Say your library "
"contained the books of Frank Herbert's Dune series, named after the fashion "
"``Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` and so on. Now you want to get "
"``Dune`` into the series field. You can do that by searching for ``(.*?) "
"\\d+ - .*`` in the title field and replacing it with ``\\1`` in the series "
"field. See what I did there? That's a reference to the first group you're "
"replacing the series field with. Now that you have the series all set, you "
"only need to do another search for ``.*? -`` in the title field and replace "
"it with ``\"\"`` (an empty string), again in the title field, and your "
"metadata is all neat and tidy. Isn't that great? By the way, instead of "
"replacing the entire field, you can also append or prepend to the field, so,"
" if you *wanted* the book title to be prepended with series info, you could "
"do that as well. As you by now have undoubtedly noticed, there's a checkbox "
"labeled :guilabel:`Case sensitive`, so you won't have to use flags to select"
" behaviour here."
msgstr "Den sista delen är reguljära uttryck :guilabel:`Sök och ersätt` i metadatafält. Du kan komma åt detta genom att välja flera böcker i biblioteket och genom att redigera metadata i grupp. Var mycket försiktig när du använder den här sista funktionen, eftersom det kan göra **mycket dåliga saker** till ditt bibliotek! Dubbelkontrollera att dina uttryck verkligen gör vad du vill att de ska göra med hjälp av testfälten, och välj bara de böcker du verkligen vill ändra! I det sökläget för reguljära uttryck kan du söka i ett annat fält, ersätta texten med något och till och med skriva in resultatet i ett annat fält. Ett praktiskt exempel: Säg att ditt bibliotek innehöll böckerna i Frank Herberts Dune-serie, uppkallad efter stilen ``Dune 1 - Dune``, ``Dune 2 - Dune Messiah`` och så vidare. Nu vill du få ``Dune`` in i seriefältet. Du kan göra det genom att söka efter ``\\d+(*.?) -.*`` i titelfältet och ersätta det med ``\\1`` i seriefältet. Ser du vad jag gjorde där? Det är en referens till den första gruppen som du ersätter seriefältet med. Nu när du har serien klar behöver du bara göra en ny sökning efter ``.*? -`` i titelfältet och ersätta det med ``\"\"`` (en tom sträng), igen i titelfältet, och dina metadata är snygga och prydliga. Är inte det bra? Förresten, istället för att ersätta hela fältet kan du också lägga till eller låta föregå fältet, så om du *ville* att boktiteln ska infogas med serieinformation, kunde du göra det också. Som du vid det här laget utan tvekan har märkt, finns det en kryssruta markerad :guilabel:`Skiftlägeskänslig`, så att du inte behöver använda flaggor för att välja beteende här."

#: ../../__w/calibre/calibre/manual/regexp.rst:142
msgid ""
"Well, that just about concludes the very short introduction to regular "
"expressions. Hopefully I'll have shown you enough to at least get you "
"started and to enable you to continue learning by yourself- a good starting "
"point would be the `Python documentation for regexps "
"<https://docs.python.org/library/re.html>`_."
msgstr "Nåväl, det avslutar nästan den mycket korta introduktionen till reguljära uttryck. Förhoppningsvis har jag ha visat dig tillräckligt för att åtminstone komma igång och så att du kan fortsätta lära dig själv - en bra utgångspunkt är `Python-dokumentationen för reguljära uttryck <https://docs.python.org/library/re.html>`_."

#: ../../__w/calibre/calibre/manual/regexp.rst:144
msgid ""
"One last word of warning, though: Regexps are powerful, but also really easy"
" to get wrong. calibre provides really great testing possibilities to see if"
" your expressions behave as you expect them to. Use them. Try not to shoot "
"yourself in the foot. (God, I love that expression...). But should you, "
"despite the warning, injure your foot (or any other body parts), try to "
"learn from it."
msgstr "Ett sista ord av varning, dock: Regexps är kraftfulla, men också väldigt lätta att få fel. calibre ger riktigt bra testmöjligheter för att se om dina uttryck beter sig som du förväntar dig. Använd dem. Försök att inte skjuta dig själv i foten. (Gud, jag älskar det uttrycket...). Men skulle du, trots varningen, skada din fot (eller andra kroppsdelar), försök att lära dig av det."

#: ../../__w/calibre/calibre/manual/regexp.rst:148
msgid "Quick reference"
msgstr "Snabbreferens"

#: ../../__w/calibre/calibre/manual/regexp.rst:156
msgid "Credits"
msgstr "Förtjänst"

#: ../../__w/calibre/calibre/manual/regexp.rst:158
msgid "Thanks for helping with tips, corrections and such:"
msgstr "Tack för hjälpen med tips, rättningar och sådant:"

#: ../../__w/calibre/calibre/manual/regexp.rst:160
msgid "ldolse"
msgstr "ldolse"

#: ../../__w/calibre/calibre/manual/regexp.rst:161
msgid "kovidgoyal"
msgstr "kovidgoyal"

#: ../../__w/calibre/calibre/manual/regexp.rst:162
msgid "chaley"
msgstr "chaley"

#: ../../__w/calibre/calibre/manual/regexp.rst:163
msgid "dwanthny"
msgstr "dwanthny"

#: ../../__w/calibre/calibre/manual/regexp.rst:164
msgid "kacir"
msgstr "kacir"

#: ../../__w/calibre/calibre/manual/regexp.rst:165
msgid "Starson17"
msgstr "Starson17"

#: ../../__w/calibre/calibre/manual/regexp.rst:166
msgid "Orpheu"
msgstr "Orpheu"

#: ../../__w/calibre/calibre/manual/regexp.rst:168
msgid ""
"For more about regexps see `The Python User Manual "
"<https://docs.python.org/library/re.html>`_. The actual regular expression "
"library used by calibre is: `regex <https://bitbucket.org/mrabarnett/mrab-"
"regex/src/hg/>`_ which supports several useful enhancements over the Python "
"standard library one."
msgstr "Mer information om regexps finns i `Python-användarmanualen <https://docs.python.org/library/re.html>`_. Det verkliga reguljära uttrycksbiblioteket som används av calibre är: `regex <https://bitbucket.org/mrabarnett/mrab-regex/src/hg/>`_ som stöder flera användbara förbättringar över ett Python-standardbibliotek."
